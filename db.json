{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/937bb/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/937bb/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/937bb/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/comment_bg.png","path":"img/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/512.png","path":"img/512.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/default_cover.jpg","path":"img/default_cover.jpg","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/siteicon/16.png","path":"img/siteicon/16.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/siteicon/apple-icon-180.png","path":"img/siteicon/apple-icon-180.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/siteicon/manifest-icon-512.maskable.png","path":"img/siteicon/manifest-icon-512.maskable.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/siteicon/32.png","path":"img/siteicon/32.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/img/siteicon/manifest-icon-192.maskable.png","path":"img/siteicon/manifest-icon-192.maskable.png","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/anzhiyu/ai_abstract.js","path":"js/anzhiyu/ai_abstract.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/anzhiyu/people.js","path":"js/anzhiyu/people.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/anzhiyu/comment_barrage.js","path":"js/anzhiyu/comment_barrage.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/anzhiyu/random_friends_post.js","path":"js/anzhiyu/random_friends_post.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/anzhiyu/right_click_menu.js","path":"js/anzhiyu/right_click_menu.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/937bb/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"source/images/logo.jpg","path":"images/logo.jpg","modified":0,"renderable":0},{"_id":"source/images/bg/pexels1.jpg","path":"images/bg/pexels1.jpg","modified":0,"renderable":0},{"_id":"source/images/post/docker/docker.jpg","path":"images/post/docker/docker.jpg","modified":0,"renderable":0},{"_id":"source/images/post/git/git.jpg","path":"images/post/git/git.jpg","modified":0,"renderable":0},{"_id":"source/images/post/linux/linux.jpg","path":"images/post/linux/linux.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_data/about.yml","hash":"413e350831705c3c41c5e914e49b647506d73e37","modified":1749043961498},{"_id":"source/_data/album.yml","hash":"ec9e5f56a3a3f59acc5dd8ad1a61777b7156064f","modified":1749312520402},{"_id":"source/_data/link.yml","hash":"b1043f8196d483b707b71b1bdf3e20ca98289798","modified":1749311933662},{"_id":"source/_posts/GIT常用命令1.md","hash":"98bfb5506f2c90d0ca251e8db9f7c6daa56603dd","modified":1749311933665},{"_id":"source/_data/creativity.yml","hash":"a21abaaabd7a21c48f83e5c713ce94aa015e2520","modified":1749043961498},{"_id":"source/_data/essay.yml","hash":"41aecb4b79083772e58a0c37c018d28d1ac82bee","modified":1749311933661},{"_id":"source/_posts/Linxu常用命令1.md","hash":"2e5b73319dc96a1bd1fcccc9e76d6ff7705daab9","modified":1749311933665},{"_id":"source/about/index.md","hash":"19fa93fa17d722638870fe4f77d00ae6125cf102","modified":1749043961513},{"_id":"source/album/index.md","hash":"db407c20431a93cc564fea49398505cf0c9af1ec","modified":1749313175274},{"_id":"source/essay/index.md","hash":"a8540d9a2a140dbadeedbdeddabf7c37eb79fb4f","modified":1749311933666},{"_id":"source/categories/index.md","hash":"af72bba59e176ecdd475d7e63d3206efc71f69dd","modified":1749311933665},{"_id":"source/music/index.md","hash":"133ef41ce49770289c5bc2e9b1948fc323f8ab9e","modified":1749311933687},{"_id":"source/link/index.md","hash":"c90791f69d8a298b0f0cf9cd15dbc90a2f49e15c","modified":1749043961515},{"_id":"source/tags/index.md","hash":"a1b8976938736d74925030cb4f61e04b0e8ff61f","modified":1749043961515},{"_id":"source/json/music.json","hash":"d1b4ce1b0a5a8130a3136f73188eb5e65a25fcb0","modified":1749311933686},{"_id":"source/_posts/Docker/Docker Compose 字段详解篇（一）：服务配置（services）.md","hash":"937b58ca10f53af02fddef001f9abe782d4acc90","modified":1749311933662},{"_id":"source/_posts/Docker/Docker Compose 字段详解篇（二）：volumes、networks、configs、secrets.md","hash":"3cba9ac1a7009edc500c012653cd6014877d7c97","modified":1749311933662},{"_id":"source/_posts/Docker/Docker Compose 教程（含字段注释）.md","hash":"47d2cee5009383f127498dd4452f400efa69bfce","modified":1749311933663},{"_id":"source/_posts/Docker/Docker Compose 常用命令篇（三）：运行、管理和停止你的应用.md","hash":"96f805790efed378e40ff628be7bf94b5f9c478e","modified":1749311933663},{"_id":"source/_posts/Docker/Docker Compose 深入服务配置篇（七）：实战与最佳实践指南.md","hash":"5b799e4c22c347945690c9272aa1bff5b31cb047","modified":1749311933663},{"_id":"source/_posts/Docker/Docker Compose 深入服务配置篇（六）：资源限制与其他字段.md","hash":"2c2a593ef70a3d526119b8560899c98e55bdc31c","modified":1749311933664},{"_id":"source/_posts/Docker/Docker Compose 灵活配置篇（五）：环境变量与多环境管理.md","hash":"c09c9058f3257527f96917c550fcd8f35bc8921d","modified":1749311933664},{"_id":"source/_posts/Docker/Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战.md","hash":"cc7a637391abe3fae6ac7edd194df5a93b3dc233","modified":1749311933664},{"_id":"source/_posts/Docker/Docker 从零开始入门教程（超详细）.md","hash":"5c46f714294fe5408a7b6b86b30550ffdb12e150","modified":1749311933665},{"_id":"source/albumDetail/dailyPhoto/index.md","hash":"65cc80745e97a0a4ea1e3116326235b012203213","modified":1749312427297},{"_id":"source/albumDetail/wordScenery/index.md","hash":"23ed7433203ecb5bc28fc835b145e8d48f6eaa53","modified":1749312444091},{"_id":"source/images/post/git/git.jpg","hash":"05bd71ab195815cea739527ea4f40cd373322849","modified":1749311933685},{"_id":"source/images/post/linux/linux.jpg","hash":"011ff4a7a5e22fcd3447ffb462c824e724271afd","modified":1749311933686},{"_id":"source/images/logo.jpg","hash":"4ac1fa67a3eb045f5e8e76d66690c88c337becea","modified":1749043961515},{"_id":"source/images/post/docker/docker.jpg","hash":"ce8d21bb37955571ec2834db2607568d63c7b351","modified":1749311933684},{"_id":"themes/937bb/source/css/_extra/home_top/random-banner.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1749311933948},{"_id":"themes/937bb/.gitignore","hash":"17b9594db1006e57f76e109924db33e54f0f2d87","modified":1749311933690},{"_id":"themes/937bb/README.md","hash":"2342370ab20c202c24ee530d80749f158d416fc3","modified":1749311933691},{"_id":"themes/937bb/LICENSE","hash":"1eba7caf09a39110ad2f542e3ed8700d1a69c6d3","modified":1749311933690},{"_id":"themes/937bb/README_EN.md","hash":"23597148859005cb89e9b6a0be708bf95ae557fb","modified":1749311933691},{"_id":"themes/937bb/package.json","hash":"a7f83155236c1dd6a309171efaa0680e78afd748","modified":1749311933910},{"_id":"themes/937bb/_config.yml","hash":"29230ec95617ac134c0707d106ebed1bd48a6a0f","modified":1749311933692},{"_id":"themes/937bb/plugins.yml","hash":"1b66b55771dbac1866909fa306358d11b255821e","modified":1749311933911},{"_id":"themes/937bb/languages/default.yml","hash":"8f22a9946744a2a4682564cf2c7e5f8dde6f1c25","modified":1749311933692},{"_id":"themes/937bb/sw-rules.js","hash":"91eb0c94682ce1bffdbbd07a5bb7e5c6e00aa8c6","modified":1749311933994},{"_id":"themes/937bb/languages/zh-CN.yml","hash":"3c84d57e1d3cceffb33da9bdeb6375d15024890d","modified":1749311933693},{"_id":"themes/937bb/languages/en.yml","hash":"824f3a5bfe0f5848cc4a919c183bae214e660242","modified":1749311933693},{"_id":"themes/937bb/layout/archive.pug","hash":"6a61277de07cf2724c865f251cb6f2385a6664ae","modified":1749311933693},{"_id":"themes/937bb/layout/category.pug","hash":"3028789225ac853000b7a84aa3a0715afd7bfb0a","modified":1749311933694},{"_id":"themes/937bb/languages/zh-TW.yml","hash":"00d538fc38c1a88fd126c2e57c29dd860e9bc2bd","modified":1749311933693},{"_id":"themes/937bb/layout/post.pug","hash":"666241d431679ea7f9c94ce345bac8405f6bc5e7","modified":1749311933910},{"_id":"themes/937bb/layout/index.pug","hash":"818aeebcd24466aade30e632ee5275f92e73baea","modified":1749311933909},{"_id":"themes/937bb/source/favicon.ico","hash":"7332d277065dfe31cc830f50119bfb3eca6eb574","modified":1749311933975},{"_id":"themes/937bb/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"1c50c14dd6b66ab636a8852e9b967c40671f1200","modified":1749311933687},{"_id":"themes/937bb/layout/tag.pug","hash":"fe81f8e8193dae2db7693e5464d4746704bbecdf","modified":1749311933910},{"_id":"themes/937bb/layout/page.pug","hash":"57db7a52cbf647256b0346e6c0cd1539732a77e8","modified":1749311933909},{"_id":"themes/937bb/.github/ISSUE_TEMPLATE/config.yml","hash":"9d8e5494501458ed1cfeb2eb9e9a57b124dc5010","modified":1749311933688},{"_id":"themes/937bb/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"0aaafd614172a6ca77a9b41fd3e81e885e8cfec7","modified":1749311933688},{"_id":"themes/937bb/.github/workflows/issue_duplicate.yml","hash":"9ce2c4845fd229e7a01d9f61da1c9b1fa0c030ec","modified":1749311933689},{"_id":"themes/937bb/.github/workflows/issue_close_question.yml","hash":"a83655836dee52bcec1470bc394aa7dbc2cb487e","modified":1749311933688},{"_id":"themes/937bb/.github/workflows/issue_invalid.yml","hash":"a4f2e5af1651d4683e2988137c7b366f5dc37bdf","modified":1749311933689},{"_id":"themes/937bb/.github/workflows/issue_close_stale.yml","hash":"b7b75a00b86da3b9361d37e5e17926e66e376d13","modified":1749311933689},{"_id":"themes/937bb/.github/workflows/issue_question.yml","hash":"7a10849dedf026ddcab8b0d3c8205ad6fe5b8327","modified":1749311933689},{"_id":"themes/937bb/layout/includes/404.pug","hash":"799817011e194e6b1fc9ccb5530f5d96d59cfcc0","modified":1749311933695},{"_id":"themes/937bb/.github/workflows/issue_wontfix.yml","hash":"288b1971d78e4e6d284e96d924c87c264737830d","modified":1749311933690},{"_id":"themes/937bb/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1749311933690},{"_id":"themes/937bb/layout/includes/additional-js.pug","hash":"5940f3f42d441667ac3ad2ff76b7b9ba79343e9a","modified":1749311933695},{"_id":"themes/937bb/layout/includes/bbTimeList.pug","hash":"ab2f111678bac295de77434b641df624843ba9aa","modified":1749311933697},{"_id":"themes/937bb/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1749311933690},{"_id":"themes/937bb/layout/includes/categoryGroup.pug","hash":"0869154dd4409c2942458075826f97793c4673a1","modified":1749311933697},{"_id":"themes/937bb/layout/includes/head.pug","hash":"792dc07e81b09b385ca1daeb5cc508804b0f22d0","modified":1749311933698},{"_id":"themes/937bb/layout/includes/layout.pug","hash":"9b19516e186b6145441e38ed575eab6c065da001","modified":1749311933702},{"_id":"themes/937bb/layout/includes/footer.pug","hash":"bcc45f9b91ddaa561fc3239e834381238964aad7","modified":1749311933698},{"_id":"themes/937bb/layout/includes/mourn.pug","hash":"fec8325d90968ccf376fc87b81671e26ba8fc702","modified":1749311933705},{"_id":"themes/937bb/layout/includes/rightside.pug","hash":"5462d757964e470d1d7abe0a7ba3d6a9566e0e00","modified":1749311933713},{"_id":"themes/937bb/layout/includes/music.pug","hash":"f45cee9da98d854f78f7fdd8f14c4be427a09d51","modified":1749311933705},{"_id":"themes/937bb/layout/includes/pagination.pug","hash":"7884c6ef7b71dd3f4ebb5a3de2c062d7668b96a5","modified":1749311933709},{"_id":"themes/937bb/layout/includes/shortcutKey.pug","hash":"738d2932e68a782be2a80a6af2db1014c272cfe7","modified":1749311933713},{"_id":"themes/937bb/layout/includes/sidebar.pug","hash":"fc56ee028770e230d4705ab74cba054c174ae500","modified":1749311933713},{"_id":"themes/937bb/scripts/events/404.js","hash":"16484d781b273f20c4fbddf27ca283e03d7c0910","modified":1749311933911},{"_id":"themes/937bb/scripts/events/comment.js","hash":"176332aa4d01728d0bd084e9b02c60167dc307dd","modified":1749311933912},{"_id":"themes/937bb/scripts/filters/post_lazyload.js","hash":"19f85dc094e3d2b72244cc0ef59e60f88373b779","modified":1749311933914},{"_id":"themes/937bb/scripts/events/cdn.js","hash":"fec4fbd14b29611684cc5a9ec1ba7a5b8a5cc996","modified":1749311933912},{"_id":"themes/937bb/scripts/events/init.js","hash":"404b1200a3be17dbc14ccbb293aa17389d3a834b","modified":1749311933912},{"_id":"themes/937bb/scripts/events/merge_config.js","hash":"38de538f3398c1be907c91f611344f4cc1009555","modified":1749311933912},{"_id":"themes/937bb/scripts/filters/random_cover.js","hash":"17497ecec828b68005762d627c54dde42de0806f","modified":1749311933914},{"_id":"themes/937bb/scripts/events/stylus.js","hash":"c4de22ef3e1e84a96f9e48d450b3dbaeb5b85ecf","modified":1749311933913},{"_id":"themes/937bb/scripts/events/welcome.js","hash":"51f3f67ca5b403ed9338166cba2c6158b76f0051","modified":1749311933913},{"_id":"themes/937bb/scripts/tag/Introduction-card.js","hash":"15d1a82549af21ef55dd40758c16ddf26a17fe22","modified":1749311933918},{"_id":"themes/937bb/scripts/tag/bilibili.js","hash":"cc3f9f29f777dea0e4714ce08be4edb301c0b768","modified":1749311933919},{"_id":"themes/937bb/scripts/tag/btns.js","hash":"84992525efbccb9e87bbc72dfef2968212cabf2e","modified":1749311933919},{"_id":"themes/937bb/scripts/tag/dogeplayer.js","hash":"facf3251b8eb2fd26f2d78906934d463d0adbd0f","modified":1749311933920},{"_id":"themes/937bb/scripts/tag/checkbox.js","hash":"636cef0f4500a14b123c6b21187fb67989472cbd","modified":1749311933919},{"_id":"themes/937bb/scripts/tag/button.js","hash":"8f6d382ea394bef44da90cdf197dd2e207d5c7db","modified":1749311933919},{"_id":"themes/937bb/scripts/tag/flink.js","hash":"f987ce74edeee13a83fe526c234626eeae0588f0","modified":1749311933920},{"_id":"themes/937bb/scripts/tag/folding.js","hash":"93f56903a307b4ce54963b40050fbb9aeb5baf47","modified":1749311933921},{"_id":"themes/937bb/scripts/tag/gallery.js","hash":"3fb27bd4b176b15f2e3a54d452ae4ef922c763d3","modified":1749311933921},{"_id":"themes/937bb/scripts/tag/hide.js","hash":"8c9275fd1a357670a84577306b5e9568ab875a7b","modified":1749311933921},{"_id":"themes/937bb/scripts/tag/inline-labels.js","hash":"eaaedc3d65384e0beb4306534ef4ed202b46da18","modified":1749311933933},{"_id":"themes/937bb/scripts/tag/iconfont.js","hash":"ea983f7c8dd060ed411044df1c10aa6b72dec34f","modified":1749311933932},{"_id":"themes/937bb/scripts/tag/image.js","hash":"382cae620f3917cc99762942ad40b3ff146216ba","modified":1749311933933},{"_id":"themes/937bb/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1749311933933},{"_id":"themes/937bb/scripts/tag/label.js","hash":"160cce6b5d58187dea0cb907116cda2bbfe6ee1c","modified":1749311933934},{"_id":"themes/937bb/scripts/tag/media.js","hash":"ebe4a6ebe34e8d77c0652c63bd5f763439743eb2","modified":1749311933934},{"_id":"themes/937bb/scripts/tag/link.js","hash":"9b7f81107a7c9d887060f6d3309f444090d7ccc3","modified":1749311933934},{"_id":"themes/937bb/scripts/tag/mermaid.js","hash":"e1a5e8e412cbbb3fc361136e9a5408170b7d93f8","modified":1749311933935},{"_id":"themes/937bb/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1749311933935},{"_id":"themes/937bb/scripts/tag/site.js","hash":"b085ab9682b8465b1399c60889283d809a91e980","modified":1749311933935},{"_id":"themes/937bb/scripts/tag/tabs.js","hash":"5dac02bb83aab3ff2afb3317ef7a2a626440671f","modified":1749311933935},{"_id":"themes/937bb/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1749311933936},{"_id":"themes/937bb/scripts/tag/span.js","hash":"89aaa0678188aa85ec18116af4b036f80ca7c073","modified":1749311933935},{"_id":"themes/937bb/source/css/index.styl","hash":"10e57f33d5326128dd736135d15c8d46162d27de","modified":1749311933974},{"_id":"themes/937bb/source/css/var.styl","hash":"2feb0a5b49075ef48fc609ffad36e86ba3bd64ae","modified":1749311933975},{"_id":"themes/937bb/scripts/tag/tip.js","hash":"0c2833f461168fa04c23bfd87f1274976d611fc1","modified":1749311933936},{"_id":"themes/937bb/source/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1749311933977},{"_id":"themes/937bb/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1749311933977},{"_id":"themes/937bb/scripts/helpers/aside_archives.js","hash":"12be80b9828008e9dd6aa7f57e875acda88e7046","modified":1749311933914},{"_id":"themes/937bb/source/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1749311933976},{"_id":"themes/937bb/source/img/favicon.ico","hash":"7332d277065dfe31cc830f50119bfb3eca6eb574","modified":1749311933978},{"_id":"themes/937bb/source/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1749311933977},{"_id":"themes/937bb/scripts/helpers/aside_categories.js","hash":"6e97bc9b99fac73561793bc746e9199636f1cf78","modified":1749311933915},{"_id":"themes/937bb/scripts/helpers/catalog_list.js","hash":"f2ba64e35ee507ecbcaa4a3516ea95f1f7abefac","modified":1749311933915},{"_id":"themes/937bb/scripts/helpers/findArchiveLength.js","hash":"612acfe4fd0d1d86676496dbb8e3e78dba030605","modified":1749311933915},{"_id":"themes/937bb/scripts/helpers/page.js","hash":"b0a3c347ae90ac998fa17e9e67b7cd290d4d7ab7","modified":1749311933916},{"_id":"themes/937bb/scripts/helpers/get_version.js","hash":"799ae97c1368c395649444b9e5a71f9074852522","modified":1749311933915},{"_id":"themes/937bb/scripts/helpers/inject_head_js.js","hash":"52f710f99904521c37fc1f19a33929799ceeafe2","modified":1749311933916},{"_id":"themes/937bb/scripts/helpers/random.js","hash":"feeabd29864fe8a2e50edc4d6c7523897f38aaca","modified":1749311933917},{"_id":"themes/937bb/scripts/helpers/related_post.js","hash":"b6960063129984f1c6760e21c8215a4739fdbac5","modified":1749311933917},{"_id":"themes/937bb/scripts/helpers/tags_page_list.js","hash":"59b5ae1970f4575d8e32309d7b4040fe55acee38","modified":1749311933918},{"_id":"themes/937bb/scripts/helpers/sort_attr_post.js","hash":"1cf55b611e4342f5a0c0e26bf69cf2a401cdcfff","modified":1749311933918},{"_id":"themes/937bb/scripts/helpers/year.js","hash":"94f15ddba7d29cdcc4dd52ed6c35c9c29cc19d37","modified":1749311933918},{"_id":"themes/937bb/source/js/main.js","hash":"8bc37a63493e52779ab649b0ffa95c99cfb88673","modified":1749311933992},{"_id":"themes/937bb/source/js/tw_cn.js","hash":"b3dfb877a3f2e66086b9e4f714f906df6f104700","modified":1749311933993},{"_id":"themes/937bb/source/js/utils.js","hash":"e89fd7c47ef287bc8832d286f4411f71d699fb61","modified":1749311933993},{"_id":"themes/937bb/layout/includes/anzhiyu/ai-info.pug","hash":"73ca24d63adbab59ef206771107a90f3afb61d56","modified":1749311933695},{"_id":"themes/937bb/layout/includes/anzhiyu/console.pug","hash":"90bf61681776979186de9cfcd6dcbd3586de8362","modified":1749311933696},{"_id":"themes/937bb/layout/includes/anzhiyu/clock.pug","hash":"475ef93ee833f283e02a0a0e4e5a0ab8743e7e19","modified":1749311933695},{"_id":"themes/937bb/layout/includes/anzhiyu/log-js.pug","hash":"1ae3784af16357679e4b5f4f7a201660e1f9ce53","modified":1749311933696},{"_id":"themes/937bb/layout/includes/anzhiyu/rightmenu.pug","hash":"60a6829fed3cfebf7bdab3475a4c0291a82a678c","modified":1749311933696},{"_id":"themes/937bb/layout/includes/anzhiyu/tags-group-all.pug","hash":"b3fd7a18a9b87500348eb36be62ca29e91b58dd8","modified":1749311933696},{"_id":"themes/937bb/layout/includes/bili-banner/index.pug","hash":"e3954ae43a708a560894fb28a21ac369a5b2d422","modified":1749311933697},{"_id":"themes/937bb/layout/includes/head/Open_Graph.pug","hash":"2f0a172bd29333a2c6301ba4b86a74173f5502d3","modified":1749311933699},{"_id":"themes/937bb/layout/includes/head/config.pug","hash":"41f77ddd5c3259d7f74f831b40dfa6ab202a990a","modified":1749311933699},{"_id":"themes/937bb/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1749311933699},{"_id":"themes/937bb/layout/includes/head/config_site.pug","hash":"c50d21cd3ee0d45d8fe65ed679c4d131ef4ed7e6","modified":1749311933699},{"_id":"themes/937bb/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1749311933700},{"_id":"themes/937bb/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1749311933700},{"_id":"themes/937bb/layout/includes/header/menu_item.pug","hash":"c3f390d17d92da630892f275dc935f04a7a18dbf","modified":1749311933702},{"_id":"themes/937bb/layout/includes/header/index.pug","hash":"b4a9f655175fca7cfe9ef3ba3866d763271fa081","modified":1749311933701},{"_id":"themes/937bb/layout/includes/head/preconnect.pug","hash":"01cf3be31783c0432ee2c79a8dc4c1422832cbe0","modified":1749311933700},{"_id":"themes/937bb/layout/includes/head/pwa.pug","hash":"0fc38262a891a66f98972fe0389ad9a5e1abdb7d","modified":1749311933701},{"_id":"themes/937bb/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1749311933701},{"_id":"themes/937bb/layout/includes/header/nav.pug","hash":"846131493ff841e15ff7dd145033331851b5af18","modified":1749311933702},{"_id":"themes/937bb/layout/includes/header/post-info.pug","hash":"0c43738c963d97cc3e28c95004d0d689fb395217","modified":1749311933702},{"_id":"themes/937bb/layout/includes/loading/index.pug","hash":"81362a8c82029119d02b33f0f7bed249950040f0","modified":1749311933703},{"_id":"themes/937bb/layout/includes/loading/fullpage-loading.pug","hash":"1ffb745ce3a56f5ab180cdf08907d3e3ea20d387","modified":1749311933703},{"_id":"themes/937bb/layout/includes/header/social.pug","hash":"7e9ee70012fdef99e80aa92fb301e27900a8ec6b","modified":1749311933702},{"_id":"themes/937bb/layout/includes/mixins/article-sort.pug","hash":"7527afa245ae66e8913d72627e9bea7bdc38ad50","modified":1749311933704},{"_id":"themes/937bb/layout/includes/loading/pace.pug","hash":"8f25b42cb6c2c07ea609ad69c243bb11463d8b60","modified":1749311933703},{"_id":"themes/937bb/layout/includes/page/about.pug","hash":"9c5d1fc2a91caf9c1bab01570fe07a5f6f35cb40","modified":1749311933705},{"_id":"themes/937bb/layout/includes/page/album.pug","hash":"f1d152c97a9328bf4446f822ea45733080978de1","modified":1749312793356},{"_id":"themes/937bb/layout/includes/page/categories.pug","hash":"2a9ad7e38cda70a54e7a65a513f0748fdee3ca9e","modified":1749311933706},{"_id":"themes/937bb/layout/includes/mixins/post-ui.pug","hash":"4b9b6377d14e3bdf977ed130324c8d043945f057","modified":1749311933704},{"_id":"themes/937bb/layout/includes/page/album_detail.pug","hash":"b056b5cc18876665316e235b60247cdc589c8f99","modified":1749311933706},{"_id":"themes/937bb/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1749311933706},{"_id":"themes/937bb/layout/includes/page/equipment.pug","hash":"7bd7f12123eb8d6b5ea65397642fec92cdbcdb1e","modified":1749311933707},{"_id":"themes/937bb/layout/includes/page/fcircle.pug","hash":"42998c6f90aa1e5ec87ba628e42b2a16889970e1","modified":1749311933707},{"_id":"themes/937bb/layout/includes/page/essay.pug","hash":"0e317d13c40e8393962cf5fa39fee6cf82601007","modified":1749311933707},{"_id":"themes/937bb/layout/includes/page/flink.pug","hash":"7cf8f32581202e60fdc960f2f73ef9bcec5ff27f","modified":1749311933708},{"_id":"themes/937bb/layout/includes/page/music.pug","hash":"2cee254ce63d5890e6cabb358b29e0c01275abc3","modified":1749311933708},{"_id":"themes/937bb/layout/includes/page/tags.pug","hash":"affa27b6fa972c2868dc7a445342becea43476b9","modified":1749311933708},{"_id":"themes/937bb/layout/includes/page/room.pug","hash":"c509876ab0488cdc3a21f0dcbea01abdcae58a31","modified":1749311933708},{"_id":"themes/937bb/layout/includes/popup/index.pug","hash":"d7144d918882727b60af84269761e6e4ce1987ad","modified":1749311933709},{"_id":"themes/937bb/layout/includes/post/post-copyright.pug","hash":"c0849c39a27d1e2952dc59df1f0200856e21068a","modified":1749311933710},{"_id":"themes/937bb/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1749311933768},{"_id":"themes/937bb/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1749311933716},{"_id":"themes/937bb/layout/includes/post/ptool.pug","hash":"90ad5d7c0ab8da38d71b514c6d4e14488f5c66c8","modified":1749311933710},{"_id":"themes/937bb/layout/includes/post/reward.pug","hash":"22af38003ab111e6449c029310a32021bb2a00a3","modified":1749311933713},{"_id":"themes/937bb/layout/includes/third-party/footerBarSubtitle.pug","hash":"62cefd8319c3819e2d0606a047cb90583c28cb78","modified":1749311933768},{"_id":"themes/937bb/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1749311933813},{"_id":"themes/937bb/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1749311933815},{"_id":"themes/937bb/layout/includes/third-party/pjax.pug","hash":"e0f26227c21544960b9abeb9ef7e9e5a02fffc64","modified":1749311933815},{"_id":"themes/937bb/layout/includes/third-party/subtitle.pug","hash":"d561d36229692e2c8a9ee45a7c24c0c2b3599170","modified":1749311933862},{"_id":"themes/937bb/source/css/_global/function.styl","hash":"67ae8fa268d4dfe7ac691adbb1b0fdf7d2afab8f","modified":1749311933953},{"_id":"themes/937bb/source/css/_layout/404.styl","hash":"6c984a3a6ac4599ea11f56f218ab575242a6217e","modified":1749311933957},{"_id":"themes/937bb/source/css/_global/icon.styl","hash":"0a8e0470910209033479ef515013bb968db9e4b5","modified":1749311933954},{"_id":"themes/937bb/source/css/_highlight/highlight.styl","hash":"4bf0c5d14a399eb06d488eefc400445a6f96000f","modified":1749311933955},{"_id":"themes/937bb/source/css/_global/index.styl","hash":"32a48c5f66bd01a62ade6e8a0e92d6462673e20f","modified":1749311933954},{"_id":"themes/937bb/source/css/_global/loading.styl","hash":"0dea01a2d462685b952fa41f51de784149b45e4f","modified":1749311933954},{"_id":"themes/937bb/source/css/_layout/banner.styl","hash":"31df78e8a76590d735d27c82196b9ce0ba6e722f","modified":1749311933957},{"_id":"themes/937bb/source/css/_layout/aside.styl","hash":"4512ffd225230a243fe02f09e8e9cde4b4a6144b","modified":1749311933957},{"_id":"themes/937bb/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1749311933958},{"_id":"themes/937bb/source/css/_layout/comments.styl","hash":"74a11d371c2e3a7f02ab314f769483960399b2b0","modified":1749311933958},{"_id":"themes/937bb/source/css/_layout/footer.styl","hash":"fe3004296f8eff61155b7095f78bfa7bc2331d08","modified":1749311933958},{"_id":"themes/937bb/source/css/_layout/head.styl","hash":"f093d83d13d778cd0e0053e1b4dde63d66d4bce2","modified":1749311933959},{"_id":"themes/937bb/source/css/_layout/nav.styl","hash":"978915633e99e1d49bd06b94bea2eb405c8fcba0","modified":1749311933959},{"_id":"themes/937bb/source/css/_highlight/theme.styl","hash":"fd8115debce97b92c31927abb877de1bdf55fa83","modified":1749311933956},{"_id":"themes/937bb/source/css/_layout/home_top.styl","hash":"1df055ba6519f6920029cc4400fc39d89602440f","modified":1749311933959},{"_id":"themes/937bb/source/css/_layout/pagination.styl","hash":"e12ff8f89458b17659e58dc65fdd2b9e7d7b4c68","modified":1749311933960},{"_id":"themes/937bb/source/css/_layout/oneGraphFlow.styl","hash":"3a2a8549df55fb053871576be20e7e85fe4cda37","modified":1749311933960},{"_id":"themes/937bb/source/css/_layout/relatedposts.styl","hash":"96825d6fec11a7caca5d7be6ce67b985a5be8bb2","modified":1749311933961},{"_id":"themes/937bb/source/css/_layout/ptool.styl","hash":"d9ca5e1a7b584c96246fb626aa74f85766c481aa","modified":1749311933961},{"_id":"themes/937bb/source/css/_layout/post.styl","hash":"ec6a5d69475f528dfd08a7cc0877d904a4b4bcbf","modified":1749311933960},{"_id":"themes/937bb/source/css/_layout/rightmenu.styl","hash":"67ed9f69ce7e88af1d96667e112f5592d1435730","modified":1749311933961},{"_id":"themes/937bb/source/css/_mode/darkmode.styl","hash":"c0e081e0fac44041942c1dcb2f799095c4116e20","modified":1749311933963},{"_id":"themes/937bb/source/css/_layout/reward.styl","hash":"a1db997b40d35bcbb270937d76bf54021bccdda2","modified":1749311933961},{"_id":"themes/937bb/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1749311933964},{"_id":"themes/937bb/source/css/_layout/shortcutKey.styl","hash":"9f45ebfba4fd0c6bde7877b06d7e1b3b1e7da405","modified":1749311933962},{"_id":"themes/937bb/source/css/_mode/readmode.styl","hash":"618694850dfa8fac81e21ea369fb8f5589ac0d0f","modified":1749311933963},{"_id":"themes/937bb/source/css/_layout/rightside.styl","hash":"5d92b9bb99515d391323ddcaa91bfcdc5be41f44","modified":1749311933962},{"_id":"themes/937bb/source/css/_layout/sidebar.styl","hash":"20dd100be44ab3e2b5ed22c187b73543d6b340a4","modified":1749311933962},{"_id":"themes/937bb/source/css/_layout/third-party.styl","hash":"b5f366f4c5286ca4321c832852feddda1f18c960","modified":1749311933962},{"_id":"themes/937bb/source/css/_page/archives.styl","hash":"f70bfb4e5b5b59c5713695927c2140957dc7aa1f","modified":1749311933964},{"_id":"themes/937bb/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1749311933965},{"_id":"themes/937bb/source/css/_page/about.styl","hash":"08e81e2fa5b5e761211115c733e657f56fbdc507","modified":1749311933964},{"_id":"themes/937bb/source/css/_page/common.styl","hash":"2ad261e7a747e2e43757f4c11324c9ed459fdbc5","modified":1749311933965},{"_id":"themes/937bb/source/css/_page/equipment.styl","hash":"5a4cbddb41aee76cb2a9c5433b7b5a487f118da7","modified":1749311933965},{"_id":"themes/937bb/source/css/_page/flink.styl","hash":"342b32142741c6a51f5219c93b9e3fad95430145","modified":1749311933966},{"_id":"themes/937bb/source/css/_page/reward.styl","hash":"bbe91f4f0525a01901be2794f698ed99f5cb58bd","modified":1749311933966},{"_id":"themes/937bb/source/css/_page/homepage.styl","hash":"8310390419d1eb5b23ae48aced4a87b0318e85be","modified":1749311933966},{"_id":"themes/937bb/source/css/_page/music.styl","hash":"cfeba567ccb6bc421261d71a2e50242a955ba099","modified":1749311933966},{"_id":"themes/937bb/source/css/_page/tag_page.styl","hash":"7a93cd4509a16b845ce2a9044320f43214dbcdc5","modified":1749311933967},{"_id":"themes/937bb/source/css/_tags/Introduction-card.styl","hash":"12a3b3ad1e97d0a4fa63521c4eaf2b1025a95719","modified":1749311933968},{"_id":"themes/937bb/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1749311933967},{"_id":"themes/937bb/source/css/_search/algolia.styl","hash":"e1dda3de7bbfce226bb8300db15a930176289a27","modified":1749311933967},{"_id":"themes/937bb/source/css/_tags/bilbili.styl","hash":"e909f60fbbdcbd072fcb1a4c2eeafa237a13b6b0","modified":1749311933969},{"_id":"themes/937bb/source/css/_search/index.styl","hash":"c315988ee28ad853aaa2060055d10aa88225a131","modified":1749311933968},{"_id":"themes/937bb/source/css/_search/local-search.styl","hash":"45792c13c7c439d412b7dc597d74d24f3b598406","modified":1749311933968},{"_id":"themes/937bb/source/css/_tags/btns.styl","hash":"0e22fdd43f698d2b27999301ca2a8bb392ac04cf","modified":1749311933969},{"_id":"themes/937bb/source/css/_tags/gallery.styl","hash":"99f2edcee8318b8cf5911fe344b89f58df7f313c","modified":1749311933970},{"_id":"themes/937bb/source/css/_tags/button.styl","hash":"ea2018ba7cbc2e11d413231556d5b001cdbd5117","modified":1749311933969},{"_id":"themes/937bb/source/css/_tags/checkbox.styl","hash":"3f1fcb0973ccea197afef26e0d515b3800dae348","modified":1749311933969},{"_id":"themes/937bb/source/css/_tags/folding.styl","hash":"f4c117ccd9ffec997a36347358050021e60df498","modified":1749311933969},{"_id":"themes/937bb/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1749311933970},{"_id":"themes/937bb/source/css/_tags/image.styl","hash":"f0043e6d5542e63a919162a545fa228acc8e1ef9","modified":1749311933971},{"_id":"themes/937bb/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1749311933971},{"_id":"themes/937bb/source/css/_tags/hide.styl","hash":"4de1984c5fdf774ef2f8e856ea188729d06743b6","modified":1749311933970},{"_id":"themes/937bb/source/css/_tags/site-card.styl","hash":"d497a9c654b927e1579a8a8513573bafacc7150a","modified":1749311933972},{"_id":"themes/937bb/source/css/_tags/note.styl","hash":"c991d29f0b970d4b738656501847cc70161dc594","modified":1749311933972},{"_id":"themes/937bb/source/css/_tags/inline-labels.styl","hash":"25a32624cab8b623634bb797cde7f2c6baff5a15","modified":1749311933971},{"_id":"themes/937bb/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1749311933971},{"_id":"themes/937bb/source/css/_tags/span.styl","hash":"252220ebb7f8e3bbff620b4d254a4703dfea7f3e","modified":1749311933972},{"_id":"themes/937bb/source/css/_third-party/normalize.min.css","hash":"a1d57065668c1695a10032cea26dc4b5cd143690","modified":1749311933974},{"_id":"themes/937bb/source/css/_tags/media.styl","hash":"da94e08918d1468871e69e265969d501310d3553","modified":1749311933972},{"_id":"themes/937bb/source/css/_tags/timeline.styl","hash":"f538fe0525c6491ac24b23ae2f9c1d2c396494fd","modified":1749311933973},{"_id":"themes/937bb/source/css/_third-party/snackbar.styl","hash":"86a40c9b534498dadbf5076c1d6f84c030da5184","modified":1749311933974},{"_id":"themes/937bb/source/css/_tags/tabs.styl","hash":"ead8a25eb164a361990c8a4cef3afb45d9dc33d9","modified":1749311933973},{"_id":"themes/937bb/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1749311933865},{"_id":"themes/937bb/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1749311933867},{"_id":"themes/937bb/source/css/_third-party/twikoo.styl","hash":"5a69b4128fbe7594994b68a73b81a018a7faaacb","modified":1749311933974},{"_id":"themes/937bb/source/css/_tags/tip.styl","hash":"4682fa963d6e667e24fe35a18b5d351c640a2769","modified":1749311933973},{"_id":"themes/937bb/layout/includes/widget/card_announcement.pug","hash":"ac60c45ae916120aab1e5c5039444029042eb3a4","modified":1749311933865},{"_id":"themes/937bb/layout/includes/top/top.pug","hash":"2b68f90a9f14f29828602289da867226b2e3c144","modified":1749311933863},{"_id":"themes/937bb/layout/includes/widget/card_author.pug","hash":"fd12d544418d11495878dedd6dc0155078cc48bb","modified":1749311933867},{"_id":"themes/937bb/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1749311933870},{"_id":"themes/937bb/layout/includes/widget/card_archives.pug","hash":"aea77a8644328f08b79f18d3b43702b0d8eb853c","modified":1749311933865},{"_id":"themes/937bb/layout/includes/widget/card_console_archives.pug","hash":"cd4626a66fe724241d8a219e78308136b4919c6f","modified":1749311933870},{"_id":"themes/937bb/layout/includes/widget/card_console_newest_comment.pug","hash":"a45b47a3674302cb5760c77689d519dae4b8fefe","modified":1749311933872},{"_id":"themes/937bb/layout/includes/widget/card_console_tags.pug","hash":"2d9385004542fe1ce615a9b4f33e45e98eb7befc","modified":1749311933872},{"_id":"themes/937bb/layout/includes/widget/card_newest_comment.pug","hash":"590cf2b84c8c6292857a0e7f4313dcb3d0162f1a","modified":1749311933873},{"_id":"themes/937bb/layout/includes/widget/card_recent_post.pug","hash":"1740e6ef4e483c108dd6af5808ed7e99c644a4d0","modified":1749311933908},{"_id":"themes/937bb/layout/includes/widget/card_post_toc.pug","hash":"9c849ba0451a314a1d97016be7b12f04c3ce6444","modified":1749311933873},{"_id":"themes/937bb/layout/includes/widget/card_tags.pug","hash":"b8315b369164ee12c79cd0d1ebc11753e3c26f4d","modified":1749311933908},{"_id":"themes/937bb/layout/includes/widget/card_weixin.pug","hash":"7725687c5db4329d989350f2d3e1de72b6e69156","modified":1749311933909},{"_id":"themes/937bb/source/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1749311933988},{"_id":"themes/937bb/layout/includes/widget/card_webinfo.pug","hash":"7d3cae5dac3e0b2993798839df3d3cfac1fd97e9","modified":1749311933909},{"_id":"themes/937bb/layout/includes/widget/index.pug","hash":"0b9a2e3509e500d83a77c9a8e72b1e30cef05c34","modified":1749311933909},{"_id":"themes/937bb/source/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1749311933988},{"_id":"themes/937bb/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1749311933908},{"_id":"themes/937bb/source/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1749311933989},{"_id":"themes/937bb/source/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1749311933988},{"_id":"themes/937bb/source/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1749311933989},{"_id":"themes/937bb/source/js/anzhiyu/ai_abstract.js","hash":"c857f20164ed3efddc284bbf7ef56eee8cc37bcd","modified":1749311933990},{"_id":"themes/937bb/source/js/anzhiyu/people.js","hash":"c76d30b73f575cd9e0659600b05cf3819f20b17c","modified":1749311933991},{"_id":"themes/937bb/source/js/anzhiyu/comment_barrage.js","hash":"1fb6922cb6d9345fc73d7f516c48a3799d7cdebd","modified":1749311933990},{"_id":"themes/937bb/source/js/search/local-search.js","hash":"23e1b201d825afc1063b51031c5c172dfdeb49d4","modified":1749311933992},{"_id":"themes/937bb/source/js/anzhiyu/random_friends_post.js","hash":"03b34e7fc4c0b5748f036a45e822be75b282b86c","modified":1749311933991},{"_id":"themes/937bb/source/js/anzhiyu/right_click_menu.js","hash":"0de57a2c37a799fec0979ea3195f4dd3827e9514","modified":1749311933991},{"_id":"themes/937bb/source/js/search/algolia.js","hash":"51bcf73660635454d66dd2b7a906caf69afa9518","modified":1749311933992},{"_id":"themes/937bb/layout/includes/third-party/card-post-count/artalk.pug","hash":"32b1ec70a6e350c7839b50110a0949d39b827db8","modified":1749311933716},{"_id":"themes/937bb/layout/includes/third-party/card-post-count/index.pug","hash":"5a6072e73874997e27dce1bf47f3d37922430336","modified":1749311933718},{"_id":"themes/937bb/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1749311933719},{"_id":"themes/937bb/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1749311933721},{"_id":"themes/937bb/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1749311933719},{"_id":"themes/937bb/layout/includes/third-party/card-post-count/waline.pug","hash":"6dd328b615f7ecf604fb0a1fbb1479e89674ea4b","modified":1749311933719},{"_id":"themes/937bb/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1749311933721},{"_id":"themes/937bb/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1749311933722},{"_id":"themes/937bb/layout/includes/third-party/comments/artalk.pug","hash":"d3fc4c539bb4e70539ba0f90debd06791be28466","modified":1749311933761},{"_id":"themes/937bb/layout/includes/third-party/chat/index.pug","hash":"085b6ec501eef02bb82157712cde35bf5cdf639e","modified":1749311933760},{"_id":"themes/937bb/layout/includes/third-party/chat/tidio.pug","hash":"26bbedadf03ca8e1d8a8f1d39444cbe3413f8872","modified":1749311933761},{"_id":"themes/937bb/layout/includes/third-party/comments/giscus.pug","hash":"52db09844df436f026f6f0896190bdbf6f15a473","modified":1749311933762},{"_id":"themes/937bb/layout/includes/third-party/comments/index.pug","hash":"dffbe34a6030c9c4022928b3bdb7df71c93a0aa3","modified":1749311933762},{"_id":"themes/937bb/layout/includes/third-party/comments/js.pug","hash":"6bdb7e04d7e6c2a1608ad5a43866ced2fca9955e","modified":1749311933763},{"_id":"themes/937bb/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1749311933770},{"_id":"themes/937bb/layout/includes/third-party/comments/twikoo.pug","hash":"a60562048ff32bde1ceb8b5975158c85db2e16f2","modified":1749311933763},{"_id":"themes/937bb/layout/includes/third-party/comments/valine.pug","hash":"cfcbc39104ff3bb44bdb41d9b6dab8388005b750","modified":1749311933765},{"_id":"themes/937bb/layout/includes/third-party/comments/waline.pug","hash":"2fed41601733bf3b1a437aa40b9101987b9a95a2","modified":1749311933767},{"_id":"themes/937bb/layout/includes/third-party/math/katex.pug","hash":"65a432d2c54b9269ddaa68715dbcd8724ed32efb","modified":1749311933770},{"_id":"themes/937bb/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1749311933771},{"_id":"themes/937bb/layout/includes/third-party/newest-comments/artalk.pug","hash":"c46c9af5f626063aaafe5b0c027f4f6be06d4fcf","modified":1749311933811},{"_id":"themes/937bb/layout/includes/third-party/math/mermaid.pug","hash":"0b0123024cf64a23de92f9668d71f61558cf8f60","modified":1749311933810},{"_id":"themes/937bb/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"630372998c8d908fd706f529702266a2f6e05772","modified":1749311933812},{"_id":"themes/937bb/layout/includes/third-party/runtime/runtime-js.pug","hash":"f76b4d84993a26e919bbc7cd531c5da5c5edd0c0","modified":1749311933816},{"_id":"themes/937bb/layout/includes/third-party/newest-comments/index.pug","hash":"cb4021a8bbb4045c2ecca1a161921ea45fb1506f","modified":1749311933811},{"_id":"themes/937bb/layout/includes/third-party/search/algolia.pug","hash":"7d48985c136472a9a3170d4c57758bb275f6ec7b","modified":1749311933818},{"_id":"themes/937bb/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1749311933861},{"_id":"themes/937bb/layout/includes/third-party/search/docsearch.pug","hash":"4e0b2a779654022dff37f74aaad24e1f04280657","modified":1749311933818},{"_id":"themes/937bb/layout/includes/third-party/share/index.pug","hash":"a47fe41f39f0073d98baa72adbde87b2d1499049","modified":1749311933861},{"_id":"themes/937bb/layout/includes/third-party/search/local-search.pug","hash":"928accb5fb5978b851b1d19abcd464258dd10e06","modified":1749311933860},{"_id":"themes/937bb/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1749311933818},{"_id":"themes/937bb/layout/includes/third-party/share/share-js.pug","hash":"b45fc15c3ae7db3a0fbce0d6da74a72a95ca8a2b","modified":1749311933862},{"_id":"themes/937bb/source/css/_extra/anzhiyu/custom.css","hash":"262291db00a343991c5472131804a4fd00deed4f","modified":1749311933938},{"_id":"themes/937bb/source/css/_extra/aside_weixin/aside_weixin.css","hash":"a96b0559ca915f2aa1f2a80412bb75cfce6fea38","modified":1749311933938},{"_id":"themes/937bb/source/css/_extra/catalog_list/catalog_list.css","hash":"027a9fb2d501c82d4bb6d69e2e76a7fa8be27f11","modified":1749311933938},{"_id":"themes/937bb/source/css/_extra/album/album.css","hash":"d79cc995aca04bb0072b206668a8530ff4bdacb6","modified":1749311933937},{"_id":"themes/937bb/source/css/_extra/album/album_detail.css","hash":"868db4e9e51e2bbe2d6555c957ecf56d50032c3c","modified":1749311933937},{"_id":"themes/937bb/source/css/_extra/categoryBar/categoryBar.css","hash":"07ef90cb816c5fef8114031bfbe7f7741b6b9b98","modified":1749311933939},{"_id":"themes/937bb/source/css/_extra/clock/clock.css","hash":"581be0a5214a5534e4cf81ceb3184737e5f2d987","modified":1749311933939},{"_id":"themes/937bb/source/css/_extra/code/details_summary.css","hash":"71d98974fca9d899bcb5c429b3ab3e9e1cb88bba","modified":1749311933940},{"_id":"themes/937bb/source/css/_extra/code/code.css","hash":"bb9e145a87748f2db0441ab2ea79ef4a7e03356e","modified":1749311933940},{"_id":"themes/937bb/source/css/_extra/commentBarrage/commentBarrage.css","hash":"335861ca0fc4aa4be700b769c871038743ea95dd","modified":1749311933941},{"_id":"themes/937bb/source/css/_extra/console/console.css","hash":"344fdfa0ac6b6de4894f2cb327b7c532e9b1a982","modified":1749311933941},{"_id":"themes/937bb/source/css/_extra/essay_page/essay_page.css","hash":"99d7a0fece8d6e69da5ba570acb77016e92113fd","modified":1749311933941},{"_id":"themes/937bb/source/css/_extra/fix/aplayer.css","hash":"d8beefb88560e30178b8baab596791e51b4d5451","modified":1749311933942},{"_id":"themes/937bb/source/css/_extra/fix/bilibili-bangumi.css","hash":"65f809858d4c1c4dbf2204a18813cd9605d4f56c","modified":1749311933942},{"_id":"themes/937bb/source/css/_extra/essay_page/home_essay_bar.css","hash":"ef550c0940378782401770ddd41bc0ba7daf1993","modified":1749311933942},{"_id":"themes/937bb/source/css/_extra/fix/bilibili-ratio.css","hash":"628352103e72c98e6d2b25f1cdb39070bd0f021c","modified":1749311933943},{"_id":"themes/937bb/layout/includes/third-party/newest-comments/valine.pug","hash":"836d25b645aba02c7148547aed4a1be4f6146e07","modified":1749311933813},{"_id":"themes/937bb/source/css/_extra/fix/categories.css","hash":"b6f7f3e384f0497926ffda4a6db1ccfc90307651","modified":1749311933943},{"_id":"themes/937bb/layout/includes/third-party/newest-comments/waline.pug","hash":"5aaffe9f673e5148493e14c84ceab50652e8a0e6","modified":1749311933813},{"_id":"themes/937bb/source/css/_extra/fix/clock.css","hash":"adb0616fdb157a880d1ab01bfb51e522df8c3523","modified":1749311933943},{"_id":"themes/937bb/source/css/_extra/fix/dark.css","hash":"dfc609b95f31544177babc76dade1720fe7cda42","modified":1749311933944},{"_id":"themes/937bb/source/css/_extra/fix/comments.css","hash":"7c2a30ceeb7519c96eda1c2ef67b6873ba3f24d2","modified":1749311933943},{"_id":"themes/937bb/source/css/_extra/fix/fcircle_page.css","hash":"16833b57f9dbb1d72cdf4a3cd80751a315a0bb27","modified":1749311933944},{"_id":"themes/937bb/source/css/_extra/fix/gitcalendar.css","hash":"b3081e90ff9994e0ed0206065bbb07daa90d6e29","modified":1749311933945},{"_id":"themes/937bb/source/css/_extra/fix/hexo-tag-dplayer.css","hash":"7ded42d62e0ba475b9789977ed7236a6c1b32007","modified":1749311933945},{"_id":"themes/937bb/source/css/_extra/fix/hide-block.css","hash":"cb6319200511548acd5642f4c6d9a3115a778b35","modified":1749311933945},{"_id":"themes/937bb/source/css/_extra/friends/friends.css","hash":"171868650c64cb995cfab069b3c128b5d07e3d38","modified":1749311933947},{"_id":"themes/937bb/source/css/_extra/fix/link_page.css","hash":"ced162602659f3cb0e423ef15c532cc7c99d6123","modified":1749311933945},{"_id":"themes/937bb/source/css/_extra/footer/footer.css","hash":"497980fa313ff7045c0756a32dc08101dcc3013d","modified":1749311933946},{"_id":"themes/937bb/source/css/_extra/fix/overflow.css","hash":"b2dafcb1bc1fa4c06f648245f11acdaf7a878d05","modified":1749311933945},{"_id":"themes/937bb/source/css/_extra/greeting_box/greeting_box.css","hash":"9c54f33a8f22064e803b2a8324f93549021f5aa4","modified":1749311933947},{"_id":"themes/937bb/source/css/_extra/home_top/categorygroup.css","hash":"b38d1dd55da2ff3e18e32628a5484e46e880d6b9","modified":1749311933947},{"_id":"themes/937bb/source/css/_extra/home_top/home_top.css","hash":"954a9eca322a5eb3fd04ad5a71f61927b0c35400","modified":1749311933948},{"_id":"themes/937bb/source/css/_extra/home_top/home_top_post_group.css","hash":"4f60d12d4f174453223be2070ed608de4ad5d14d","modified":1749311933948},{"_id":"themes/937bb/source/css/_extra/home_top/swiperstyle.css","hash":"33f5a0731ac439871dd54aad7528431df091b551","modified":1749311933948},{"_id":"themes/937bb/source/css/_extra/reset/reset.css","hash":"4651067de360b4e00dd361795a74a7ed2a5a62ff","modified":1749311933950},{"_id":"themes/937bb/source/css/_extra/home_top/top_group_banner.css","hash":"4b3090b0f5f01dbd4b1706e4104962b15c05f8d0","modified":1749311933949},{"_id":"themes/937bb/source/css/_extra/local_search/local_search.css","hash":"9fc79ed81a5f0476172fe688ecba08e7b8e3be03","modified":1749311933949},{"_id":"themes/937bb/source/css/_extra/runtime/runtime.css","hash":"6e8dbcf6e505cd96192c8b75970ff65f98acf51c","modified":1749311933951},{"_id":"themes/937bb/source/css/_extra/room/room.css","hash":"5a730fdec4fd9e1d8b38e407ba1d139abd6a17d2","modified":1749311933951},{"_id":"themes/937bb/source/css/_extra/reward/about-reward.css","hash":"2201faa78b7a9ded910f59abe28df2b897fd23b0","modified":1749311933950},{"_id":"themes/937bb/source/css/_extra/fix/radius.css","hash":"a55321b326f241d0788359d5366172d7aeb734e1","modified":1749311933946},{"_id":"themes/937bb/source/css/_extra/single_card/single_card.css","hash":"f7690f0dde69437f2222a9889ea957a185a7fbb6","modified":1749311933952},{"_id":"themes/937bb/source/css/_extra/skills/skills.css","hash":"12901c0c77345fbd92edf591ee98266919eed259","modified":1749311933952},{"_id":"themes/937bb/source/css/_extra/fix/site-card.css","hash":"f56eff8b96c773ae6a8e97ef0e1c822feabe5854","modified":1749311933946},{"_id":"themes/937bb/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1749311933956},{"_id":"themes/937bb/source/css/_extra/tag/site.css","hash":"8735ce339b410a72fc314af37f5d7ffd783fad05","modified":1749311933953},{"_id":"themes/937bb/source/css/_extra/tag/link.css","hash":"da429802cbe2cf45b66115d03c682e9463c34dc1","modified":1749311933953},{"_id":"themes/937bb/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1749311933955},{"_id":"themes/937bb/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1749311933956},{"_id":"themes/937bb/source/css/_highlight/prismjs/index.styl","hash":"78398d5c407a30a561c1c98baccaabd9633edd27","modified":1749311933956},{"_id":"themes/937bb/source/css/_highlight/highlight/index.styl","hash":"58680cd4ff5767afeabe4d4cfb621c0c2d7a68e4","modified":1749311933955},{"_id":"themes/937bb/source/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1749311933976},{"_id":"themes/937bb/source/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1749311933982},{"_id":"themes/937bb/source/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1749311933987},{"_id":"source/images/bg/pexels1.jpg","hash":"908ae192e629d2745e51a56f8df602274eb49e7f","modified":1749311933683},{"_id":"public/json/music.json","hash":"305c37be063d582110889b657bebcb66c0122252","modified":1749313339028},{"_id":"public/baidusitemap.xml","hash":"92213ab48faf9dcb5440b6c0e769005d90ad675a","modified":1749313339028},{"_id":"public/sitemap.xml","hash":"7a11909e08a4e4d9888eb4ac6d8d68896bb954db","modified":1749313339028},{"_id":"public/anzhiyu/random.js","hash":"2a843fc565fc0e82187efb20f9f64c92d9f21f51","modified":1749313339028},{"_id":"public/sitemap.txt","hash":"eb155bfe33f1d9f96661a66af1b807be3b8ed8de","modified":1749313339028},{"_id":"public/404.html","hash":"11f8f219a66be61c962a19389159aea71e968979","modified":1749313339028},{"_id":"public/about/index.html","hash":"8bef89bd1a5d50bb4921d83d7a2da126171a45ef","modified":1749313339028},{"_id":"public/essay/index.html","hash":"900e5eea68091ba6891ab0b814e4ab210833f13b","modified":1749313339028},{"_id":"public/album/index.html","hash":"ecccf8a04c4b5f25b41573691d3a839f448c82e8","modified":1749313339028},{"_id":"public/music/index.html","hash":"dafcc5981d552e3cfd548a1997bc223ba95542f7","modified":1749313339028},{"_id":"public/categories/index.html","hash":"9418d424f0ec8f9f93124765bfeca52608340c03","modified":1749313339028},{"_id":"public/link/index.html","hash":"29ea50bde0afdad5631ebc39bb914a5afccbc548","modified":1749313339028},{"_id":"public/tags/index.html","hash":"31aaf6740d5c1aea0ab877bbf53fe6b9c8efe5e6","modified":1749313339028},{"_id":"public/albumDetail/dailyPhoto/index.html","hash":"66ed8d50d449e485e43c14f421abbd0fbbb74d42","modified":1749313339028},{"_id":"public/albumDetail/wordScenery/index.html","hash":"1c69d0f682ed36434aae10dc2a318b004192af98","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 深入服务配置篇（七）：实战与最佳实践指南/index.html","hash":"726453214cd3606ae1d1da82eb65ec84aa5394f1","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 深入服务配置篇（六）：资源限制与其他字段/index.html","hash":"a03f2a3bf6002ec316efe8b5b6308b9f446e14ec","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 灵活配置篇（五）：环境变量与多环境管理/index.html","hash":"a9e5b91b3d7edbb40c41d7662ed019028fd8cab5","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战/index.html","hash":"0bdabc921492f15139693f40c3a3b91d7cc1c705","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 常用命令篇（三）：运行、管理和停止你的应用/index.html","hash":"5dfd8ec5dde5626d209b63c728a98d9a83398879","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 字段详解篇（二）：volumes、networks、configs、secrets/index.html","hash":"00fde7462b78b159ed2785056bfa349cb98032d8","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 字段详解篇（一）：服务配置（services）/index.html","hash":"9af2ed5840ed5f093760efd760da6238421d8512","modified":1749313339028},{"_id":"public/2025/06/07/Docker/Docker Compose 教程（含字段注释）/index.html","hash":"7d2c472f54dda28b29533fecf8859528bb21ab45","modified":1749313339028},{"_id":"public/2025/06/06/GIT常用命令1/index.html","hash":"c924c2f22381381261286a6845f2270d54c53aff","modified":1749313339028},{"_id":"public/2025/06/06/Linxu常用命令1/index.html","hash":"6149be83cbb4a6035dba774cddfa34ba5a48dee3","modified":1749313339028},{"_id":"public/2025/06/06/Docker/Docker 从零开始入门教程（超详细）/index.html","hash":"6b9cd308e3f64667f9a904838d14263d020d9593","modified":1749313339028},{"_id":"public/archives/index.html","hash":"0f88e763d62ea6e919b71c4f23a01ae5a3a22530","modified":1749313339028},{"_id":"public/archives/page/2/index.html","hash":"8ee5a6d7789ae8608b0f55e172c5e3047ecb22e3","modified":1749313339028},{"_id":"public/archives/2025/index.html","hash":"fac775791b3bf7a98300e7c6c92cdc5cb1c88b10","modified":1749313339028},{"_id":"public/archives/2025/page/2/index.html","hash":"0ccadb16f496c4a19bfdaefce871b8a037e06b03","modified":1749313339028},{"_id":"public/archives/2025/06/index.html","hash":"e68363a236aafa148665225b0e22b15a92d6899e","modified":1749313339028},{"_id":"public/archives/2025/06/page/2/index.html","hash":"8fb2ed5e062f4e31880145bfd7e3df4da780eaf5","modified":1749313339028},{"_id":"public/categories/GIT/index.html","hash":"8df89b99efd0fbbb71a73d4ce68818979be85d67","modified":1749313339028},{"_id":"public/categories/Linux/index.html","hash":"2af4f229b286f9f5617bfa6d50517c9168459f09","modified":1749313339028},{"_id":"public/categories/Docker/index.html","hash":"89b002c467e1bd3da7be1dae36aa60033f25ba77","modified":1749313339028},{"_id":"public/index.html","hash":"40cf25317929018b6f4aeda56de1673b6ce30829","modified":1749313339028},{"_id":"public/page/2/index.html","hash":"d62a965beb4212243a9b6ca3a59dc554fa8a7fb0","modified":1749313339028},{"_id":"public/tags/教程/index.html","hash":"0d75d246eb328b3e24d116edde0ce3d1899f21d9","modified":1749313339028},{"_id":"public/tags/教程/page/2/index.html","hash":"9c98e557ce90ee118f6618436e41eeb2f16aa4dd","modified":1749313339028},{"_id":"public/tags/GIT/index.html","hash":"1c652ae0187b66e2beae95c34e0bb5c197d7de93","modified":1749313339028},{"_id":"public/tags/Linux/index.html","hash":"47e9639bbdbbbb524ff17b08e646fd8c79054720","modified":1749313339028},{"_id":"public/tags/Docker/index.html","hash":"73f227235abfe6497e91235ac087bc9a0ec169f1","modified":1749313339028},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1749313339028},{"_id":"public/img/comment_bg.png","hash":"91612a887446fb436e9151981e2289f2a426a3e5","modified":1749313339028},{"_id":"public/img/512.png","hash":"6988b23a31304d9de45b95a1e7c05dd42024e560","modified":1749313339028},{"_id":"public/favicon.ico","hash":"7332d277065dfe31cc830f50119bfb3eca6eb574","modified":1749313339028},{"_id":"public/img/default_cover.jpg","hash":"455fa65e2736f61ac36360dd4f76fc1ab6a1cdd5","modified":1749313339028},{"_id":"public/img/favicon.ico","hash":"7332d277065dfe31cc830f50119bfb3eca6eb574","modified":1749313339028},{"_id":"public/img/siteicon/16.png","hash":"8dc6ca32ff1264f7c1c3a8f62727a8c96ea7525b","modified":1749313339028},{"_id":"public/img/siteicon/manifest-icon-512.maskable.png","hash":"6f8b4b3df8d1498db55a559f7106dc9b6e6af647","modified":1749313339028},{"_id":"public/img/siteicon/apple-icon-180.png","hash":"7f580ec4819c9ef10b1306102152f4473f037a98","modified":1749313339028},{"_id":"public/img/siteicon/32.png","hash":"147aae33224066ef2a5987c3cbbfa4309c49cef4","modified":1749313339028},{"_id":"public/images/post/git/git.jpg","hash":"05bd71ab195815cea739527ea4f40cd373322849","modified":1749313339028},{"_id":"public/images/post/linux/linux.jpg","hash":"011ff4a7a5e22fcd3447ffb462c824e724271afd","modified":1749313339028},{"_id":"public/img/siteicon/manifest-icon-192.maskable.png","hash":"528b94ebcd34fb55436d64fdda76ef43ccbf031f","modified":1749313339028},{"_id":"public/images/logo.jpg","hash":"4ac1fa67a3eb045f5e8e76d66690c88c337becea","modified":1749313339028},{"_id":"public/images/post/docker/docker.jpg","hash":"ce8d21bb37955571ec2834db2607568d63c7b351","modified":1749313339028},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1749313339028},{"_id":"public/js/search/local-search.js","hash":"3ad66c75b4a0fc28a14a5478ee8a19fde72f837f","modified":1749313339028},{"_id":"public/js/search/algolia.js","hash":"5c2a0d0489c51c6d9e54f5a3b0c6e66a5f649450","modified":1749313339028},{"_id":"public/js/anzhiyu/random_friends_post.js","hash":"1548fdc0a8cb4291bc8793dc8d321c59c097c08e","modified":1749313339028},{"_id":"public/js/anzhiyu/people.js","hash":"f3d2a3d0c730124d9f64dbf59486145c05a42ac6","modified":1749313339028},{"_id":"public/js/anzhiyu/ai_abstract.js","hash":"be52eb13a416b18337d3b1142277920072e698c3","modified":1749313339028},{"_id":"public/js/anzhiyu/comment_barrage.js","hash":"1b30f922238f626c6a90ce2705789ba2362a2a9e","modified":1749313339028},{"_id":"public/js/anzhiyu/right_click_menu.js","hash":"d605ee0cab24604f97ccef5747bfacaa108645ba","modified":1749313339028},{"_id":"public/css/index.css","hash":"4b7ce37323c7cd457f6906e562abd91ef6871e6e","modified":1749313339028},{"_id":"public/js/tw_cn.js","hash":"6cbec565e98cbd49aa75e6161d8fa996ae3be91a","modified":1749313339028},{"_id":"public/js/main.js","hash":"855a84f49c050f8ce890e60e1872606bb5704a38","modified":1749313339028},{"_id":"public/js/utils.js","hash":"39bb91d68687016b92dafb73a648c5b1b6886cb0","modified":1749313339028},{"_id":"public/img/404.jpg","hash":"030b9c7c9d654b3d67c1249a6e5900bf40c79373","modified":1749313339028},{"_id":"public/img/friend_404.gif","hash":"4c0a482bce3710942aff900d62c48333827e5a53","modified":1749313339028},{"_id":"public/img/loading.gif","hash":"b9e8d78b86bc48d565e26c8c1ea275c2c758fb0d","modified":1749313339028},{"_id":"public/images/bg/pexels1.jpg","hash":"908ae192e629d2745e51a56f8df602274eb49e7f","modified":1749313339028}],"Category":[{"name":"GIT","_id":"cmbmfzww20004pkrc71c0bvao"},{"name":"Linux","_id":"cmbmfzww5000cpkrc70fx6zao"},{"name":"Docker","_id":"cmbmfzww7000jpkrc5v4keyk9"}],"Data":[{"_id":"about","data":[{"class_name":"关于页","subtitle":"生活明朗，万物可爱✨","avatarImg":"/images/logo.jpg","avatarSkills":{"left":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙"],"right":["专修交互与设计 🤝","脚踏实地行动派 🏃","团队小组发动机 🧱","壮汉人狠话不多 💢"]},"name":"937bb","description":"是一名 全工程师、学生、独立开发者、博主","aboutsiteTips":{"tips":"追求","title1":"源于","title2":"热爱而去 感受","word":["学习","生活","程序","体验"]},"helloAbout":"Hello World!","skillsTips":{"tips":"技能","title":"开启创造力"},"careers":{"tips":"生涯","title":"无限进步","list":[{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"},{"desc":"EDU,软件工程专业","color":"#357ef5"}],"img":"https://bu.dusays.com/2023/04/21/644287166329b.png"},"statistic":{"link":"/archives","text":"文章隧道","cover":"https://bu.dusays.com/2023/05/01/644f4b037b930.jpg"},"map":{"title":"我现在住在","StrengthenTitle":"中国，长沙市","background":"https://bu.dusays.com/2023/07/05/64a4c61cb20ef.jpg","backgroundDark":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg"},"selfInfo":{"selfInfoTips1":"生于","selfInfoContentYear":2002,"selfInfoTips2":"湖南信息学院","selfInfoContent2":"软件工程","selfInfoTips3":"现在职业","selfInfoContent3":"大三学生👨‍🎓"},"personalities":{"author_name":"提倡者","personality_type":"INFJ-A","photo_url":"https://bu.dusays.com/2023/07/05/64a4c63495ac5.jpg","personality_img":"https://q2.itc.cn/q_70/images03/20241105/f4fe4e3ea8ca41da806fa83965003309.png","name_url":"https://www.16personalities.com/ch/esfj-%E4%BA%BA%E6%A0%BC"},"maxim":{"maxim_tips":"座右铭","maxim_top":"生活明朗，","maxim_bottom":"万物可爱。"},"buff":{"buff_tips":"特长","buff_top":"脑回路新奇的 酸菜鱼","buff_bottom":"二次元指数 MAX"},"game":{"game_tips":"爱好游戏","game_title":"原神","game_uid":"UID: 125766904","game_bg":"https://bu.dusays.com/2023/04/22/64433bf26e25d.webp"},"comic":{"comic_tips":null,"comic_title":null},"like":{"like_tips":"关注偏好","like_title":"数码科技","like_bg":"https://bu.dusays.com/2022/12/06/638f5f05ce1f7.jpg","like_bottom":"手机、电脑软硬件"},"music":{"music_tips":"音乐偏好","music_title":"许嵩、民谣、华语流行","music_bg":"https://p2.music.126.net/Mrg1i7DwcwjWBvQPIMt_Mg==/79164837213438.jpg","music_link":"/music"},"reward_list":[{"name":"海阔蓝","amount":8.8,"datatime":"2023-03-28T00:00:00.000Z"},{"name":"LK66","amount":66.6,"datatime":"2023-03-24T00:00:00.000Z"},{"name":"张时貳","amount":6.6,"datatime":"2023-01-22T00:00:00.000Z"},{"name":"ZeroAf","amount":9.9,"datatime":"2022-12-14T00:00:00.000Z"},{"name":"LuckyWangXi","amount":6.6,"datatime":"2022-12-14T00:00:00.000Z"},{"name":"刀中日月长","amount":10,"datatime":"2022-11-16T00:00:00.000Z"},{"name":"鹿啵包","amount":10,"datatime":"2022-11-08T00:00:00.000Z"},{"name":"疾速k","amount":50,"datatime":"2022-09-20T00:00:00.000Z"},{"name":"伴舟先生大霖子","amount":4.03,"datatime":"2022-10-27T00:00:00.000Z","suffix":"贝壳"},{"name":"Magica_0x0","amount":3.36,"datatime":"2022-10-07T00:00:00.000Z","suffix":"贝壳"},{"name":"名字就是要短像这样","amount":3.36,"datatime":"2022-08-25T00:00:00.000Z","suffix":"贝壳"},{"name":"Leviathan520","amount":1.34,"datatime":"2022-08-23T00:00:00.000Z","suffix":"贝壳"},{"name":"托马斯","amount":10,"datatime":"2022-08-19T00:00:00.000Z"},{"name":"哇是猫猫欸","amount":1.34,"datatime":"2022-08-19T00:00:00.000Z","suffix":"贝壳"}]}]},{"_id":"album","data":[{"class_name":"世界各地夕阳与风景","path_name":"/albumDetail/wordScenery","type":2,"description":"因为到不了世界各地，所以请网友们发来了各地的夕阳与风景🌇。","cover":"https://bu.dusays.com/2023/04/09/64329399d1175.jpg","top_background":"https://bu.dusays.com/2023/06/30/649e546ada7dd.webp","rowHeight":220,"limit":10,"lazyload":true,"btnLazyload":false,"url":false,"top_link":"/album","top_btn_text":"返回","album_list":[{"date":"2022/10/26 01:00:00","content":"湘潭的一角。","address":"湖南湘潭","from":"再吃一口就减肥","image":["https://bu.dusays.com/2023/04/09/64329399db122.webp"]},{"date":"2022-10-25T00:00:00.000Z","content":"洛阳暴雨后的天空。","address":"河南洛阳","from":"紫菜卷","image":["https://bu.dusays.com/2023/04/09/64329399db122.webp","https://bu.dusays.com/2023/04/09/64329399db2e1.webp"]}]},{"class_name":"我的日常","path_name":"/albumDetail/dailyPhoto","type":1,"description":"这里存放的是有关我自己的一些沙雕生活与有趣的事情。","top_link":"/album","top_btn_text":"返回","top_background":"https://bu.dusays.com/2023/04/09/64329399cea5a.webp","cover":"https://bu.dusays.com/2023/04/09/64329399cea5a.webp","album_list":[{"date":"2022-10-24T00:00:00.000Z","content":"老妹的画","image":["https://bu.dusays.com/2023/04/09/643293997b92b.jpeg"]}]}]},{"_id":"link","data":[{"class_name":"框架","flink_style":"flexcard","hundredSuffix":"","link_list":[{"name":"937blog","link":"https://blog.937b.cn","avatar":"/images/logo.jpg","descr":"让自己简单点","siteshot":"/images/logo.jpg"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网站框架","siteshot":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg"}]},{"class_name":"推荐博客","flink_style":"telescopic","hundredSuffix":"","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网站框架","siteshot":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","color":"vip","tag":"技术"}]},{"class_name":"小伙伴","class_desc":"那些人，那些事","flink_style":"anzhiyu","hundredSuffix":"","link_list":[{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、简单且强大的网站框架","siteshot":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","recommend":true}]}]},{"_id":"creativity","data":[{"class_name":"开启创造力","creativity_list":[{"name":"Java","color":"#fff","icon":"https://bu.dusays.com/2023/04/09/643293b1184e9.jpg"},{"name":"Docker","color":"#57b6e6","icon":"https://bu.dusays.com/2023/04/09/643293b0f0abe.png"},{"name":"Photoshop","color":"#4082c3","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c240e.png"},{"name":"Node","color":"#333","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.1.1/img/svg/node-logo.svg"},{"name":"Webpack","color":"#2e3a41","icon":"https://bu.dusays.com/2023/04/09/643293b68026c.png"},{"name":"Pinia","color":"#fff","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/pinia-logo.svg"},{"name":"Python","color":"#fff","icon":"https://bu.dusays.com/2023/04/09/643293b1230f7.png"},{"name":"Vite","color":"#937df7","icon":"https://npm.elemecdn.com/anzhiyu-blog@2.0.8/img/svg/vite-logo.svg"},{"name":"Flutter","color":"#4499e4","icon":"https://bu.dusays.com/2023/04/09/643293b1055c2.png"},{"name":"Vue","color":"#b8f0ae","icon":"https://bu.dusays.com/2023/04/09/643293b6788bd.png"},{"name":"React","color":"#222","icon":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K"},{"name":"CSS3","color":"#2c51db","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c251e.png"},{"name":"JS","color":"#f7cb4f","icon":"https://bu.dusays.com/2023/04/09/643293b121f02.png"},{"name":"HTML","color":"#e9572b","icon":"https://bu.dusays.com/2022/12/15/639aa3a5c241c.png"},{"name":"Git","color":"#df5b40","icon":"https://bu.dusays.com/2023/04/09/643293b10ccdd.webp"},{"name":"Apifox","color":"#e65164","icon":"https://bu.dusays.com/2022/11/19/6378d6458c6b6.png"}]}]},{"_id":"essay","data":[{"title":"瞬间","subTitle":"全干实习中。","tips":"希望在新的一年继续呜呼起飞","buttonText":"关于我","buttonLink":"/about/","limit":30,"home_essay":true,"top_background":"/images/bg/pexels1.jpg","essay_list":[{"content":"站点创建成功","date":"2025/01/01"}]}]}],"Page":[{"title":"关于","date":"2021-03-30T07:57:51.000Z","aside":false,"top_img":false,"background":"#f8f9fe","comments":0,"type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2021-03-30 15:57:51\naside: false\ntop_img: false\nbackground: \"#f8f9fe\"\ncomments: false\ntype: \"about\"\n---","updated":"2025-06-04T13:32:41.513Z","path":"about/index.html","layout":"page","_id":"cmbmfzwvx0000pkrc3oargjsf","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"即刻","date":"2020-07-22T14:06:17.000Z","comments":1,"aside":false,"top_img":false,"type":"essay","_content":"","source":"essay/index.md","raw":"---\ntitle: 即刻\ndate: 2020-07-22 22:06:17\ncomments: true\naside: false\ntop_img: false\ntype: essay\n---","updated":"2025-06-07T15:58:53.666Z","path":"essay/index.html","layout":"page","_id":"cmbmfzww10002pkrc6ko371ed","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"相册集","date":"2022-10-23T07:57:51.000Z","aside":false,"top_img":false,"top_background":"/images/bg/pexels1.jpg","type":"album","_content":"","source":"album/index.md","raw":"---\ntitle: 相册集\ndate: 2022-10-23 15:57:51\naside: false\ntop_img: false\ntop_background: /images/bg/pexels1.jpg\ntype: \"album\"\n---","updated":"2025-06-07T16:19:35.274Z","path":"album/index.html","comments":1,"layout":"page","_id":"cmbmfzww30006pkrc6ixq1uk7","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"音乐馆","date":"2021-04-24T13:41:30.000Z","type":"music","aplayer":true,"top_img":false,"comments":0,"aside":false,"_content":"","source":"music/index.md","raw":"---\ntitle: 音乐馆\ndate: 2021-04-24 21:41:30\ntype: music\naplayer: true\ntop_img: false\ncomments: false\naside: false\n---","updated":"2025-06-07T15:58:53.687Z","path":"music/index.html","layout":"page","_id":"cmbmfzww40008pkrcftl124ik","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"分类","date":"2022-02-23T09:56:00.000Z","aside":false,"top_img":false,"type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-02-23 17:56:00\naside: false\ntop_img: false\ntype: \"categories\"\ncomments: false\n---","updated":"2025-06-07T15:58:53.665Z","path":"categories/index.html","layout":"page","_id":"cmbmfzww5000apkrchr6wfj0n","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"link","date":"2020-12-01T14:19:45.000Z","type":"link","aside":false,"_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2020-12-01 22:19:45\ntype: \"link\"\naside: false\n---","updated":"2025-06-04T13:32:41.515Z","path":"link/index.html","comments":1,"layout":"page","_id":"cmbmfzww5000epkrc3yqw0m9n","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"标签","date":"2021-04-06T04:01:51.000Z","type":"tags","comments":0,"top_img":false,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-04-06 12:01:51\ntype: \"tags\"\ncomments: false\ntop_img: false\n---","updated":"2025-06-04T13:32:41.515Z","path":"tags/index.html","layout":"page","_id":"cmbmfzww6000gpkrcgq7n4cs5","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"_content":"[\n\t{\n\t\t\"name\": \"青花瓷\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n\t},\n\t{\n\t\t\"name\": \"稻香\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n\t},\n\t{\n\t\t\"name\": \"晴天\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n\t},\n\t{\n\t\t\"name\": \"七里香\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n\t},\n\t{\n\t\t\"name\": \"花海\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n\t},\n\t{\n\t\t\"name\": \"反方向的钟\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n\t},\n\t{\n\t\t\"name\": \"兰亭序\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n\t},\n\t{\n\t\t\"name\": \"说好的辛福呢\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n\t},\n\t{\n\t\t\"name\": \"等你下课 (with 杨瑞代)\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n\t},\n\t{\n\t\t\"name\": \"我落泪情绪零碎\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n\t},\n\t{\n\t\t\"name\": \"听妈妈的话\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n\t},\n\t{\n\t\t\"name\": \"明明就\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n\t},\n\t{\n\t\t\"name\": \"我是如此相信\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n\t},\n\t{\n\t\t\"name\": \"发如雪\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n\t},\n\t{\n\t\t\"name\": \"以父之名\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n\t},\n\t{\n\t\t\"name\": \"园游会\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n\t},\n\t{\n\t\t\"name\": \"本草纲目\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n\t},\n\t{\n\t\t\"name\": \"龙卷风\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n\t}\n]\n","source":"json/music.json","raw":"[\n\t{\n\t\t\"name\": \"青花瓷\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n\t},\n\t{\n\t\t\"name\": \"稻香\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n\t},\n\t{\n\t\t\"name\": \"晴天\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n\t},\n\t{\n\t\t\"name\": \"七里香\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n\t},\n\t{\n\t\t\"name\": \"花海\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n\t},\n\t{\n\t\t\"name\": \"反方向的钟\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n\t},\n\t{\n\t\t\"name\": \"兰亭序\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n\t},\n\t{\n\t\t\"name\": \"说好的辛福呢\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n\t},\n\t{\n\t\t\"name\": \"等你下课 (with 杨瑞代)\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n\t},\n\t{\n\t\t\"name\": \"我落泪情绪零碎\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n\t},\n\t{\n\t\t\"name\": \"听妈妈的话\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n\t},\n\t{\n\t\t\"name\": \"明明就\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n\t},\n\t{\n\t\t\"name\": \"我是如此相信\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n\t},\n\t{\n\t\t\"name\": \"发如雪\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n\t},\n\t{\n\t\t\"name\": \"以父之名\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n\t},\n\t{\n\t\t\"name\": \"园游会\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n\t},\n\t{\n\t\t\"name\": \"本草纲目\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n\t},\n\t{\n\t\t\"name\": \"龙卷风\",\n\t\t\"artist\": \"周杰伦\",\n\t\t\"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n\t\t\"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n\t\t\"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n\t}\n]\n","date":"2025-06-07T15:58:53.686Z","updated":"2025-06-07T15:58:53.686Z","path":"json/music.json","layout":"false","title":"","comments":1,"_id":"cmbmfzww8000lpkrc9w53dm0u","content":"[{\"name\":\"青花瓷\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"},{\"name\":\"稻香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"},{\"name\":\"晴天\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"},{\"name\":\"七里香\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"},{\"name\":\"花海\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"},{\"name\":\"反方向的钟\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"},{\"name\":\"兰亭序\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"},{\"name\":\"说好的辛福呢\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"},{\"name\":\"等你下课 (with 杨瑞代)\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"},{\"name\":\"我落泪情绪零碎\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"},{\"name\":\"听妈妈的话\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"},{\"name\":\"明明就\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"},{\"name\":\"我是如此相信\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"},{\"name\":\"发如雪\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"},{\"name\":\"以父之名\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"},{\"name\":\"园游会\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"},{\"name\":\"本草纲目\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"},{\"name\":\"龙卷风\",\"artist\":\"周杰伦\",\"url\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\"cover\":\"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\"lrc\":\"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"}]"},{"title":"日常生活","date":"2022-10-23T07:57:51.000Z","aside":false,"top_img":false,"type":"album_detail","_content":"","source":"albumDetail/dailyPhoto/index.md","raw":"---\ntitle: 日常生活\ndate: 2022-10-23 15:57:51\naside: false\ntop_img: false\ntype: \"album_detail\"\n---","updated":"2025-06-07T16:07:07.297Z","path":"albumDetail/dailyPhoto/index.html","comments":1,"layout":"page","_id":"cmbmfzww9000opkrc9myf3xyq","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""},{"title":"世界各地风景","date":"2022-10-23T07:57:51.000Z","aside":false,"top_img":false,"type":"album_detail","_content":"","source":"albumDetail/wordScenery/index.md","raw":"---\ntitle: 世界各地风景\ndate: 2022-10-23 15:57:51\naside: false\ntop_img: false\ntype: \"album_detail\"\n---","updated":"2025-06-07T16:07:24.091Z","path":"albumDetail/wordScenery/index.html","comments":1,"layout":"page","_id":"cmbmfzww9000tpkrccjyqah1r","content":"","cover":"/img/default_cover.jpg","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"GIT常用命令1 - 🧠 Git 使用教程（附公司级协作流程）","top_img":"/images/post/git/git.jpg","cover":"/images/post/git/git.jpg","abbrlink":28112,"date":"2025-06-05T16:00:00.000Z","_content":"\n\n# 🧠 Git 使用教程（附公司级协作流程）\n\nGit 是最流行的分布式版本控制系统，广泛应用于团队协作开发中。本文将从零讲解 Git 的基本操作，并重点介绍在公司中的使用规范和协作流程。\n\n---\n\n## 📦 一、什么是 Git？\n\nGit 是一个**版本控制工具**，可以记录文件的修改历史，方便多人协作、代码回滚、版本发布等。\n\n- 本地 Git 仓库：每个开发者都有完整历史记录\n- 远程仓库（如 GitHub/GitLab）：集中托管协作开发\n\n---\n\n## 🛠️ 二、安装与配置\n\n### 安装 Git\n\n- 官网：https://git-scm.com/\n\nWindows 用户可以下载安装包，其他平台推荐使用包管理器。\n\n### 基本配置\n\n```bash\ngit config --global user.name \"你的姓名\"\ngit config --global user.email \"你的公司邮箱\"\ngit config --global core.editor \"code\"  # 设置 VSCode 为默认编辑器\n```\n\n---\n\n## 🔍 三、Git 常用命令速查\n\n| 命令                   | 说明           |\n| ---------------------- | -------------- |\n| `git init`             | 初始化本地仓库 |\n| `git clone 仓库地址`   | 克隆远程仓库   |\n| `git status`           | 查看当前状态   |\n| `git add 文件名`       | 暂存改动       |\n| `git commit -m \"注释\"` | 提交改动       |\n| `git push`             | 推送到远程     |\n| `git pull`             | 拉取最新改动   |\n| `git checkout 分支名`  | 切换分支       |\n| `git branch`           | 查看本地分支   |\n| `git merge 分支名`     | 合并分支       |\n\n---\n\n## 🧬 四、Git 工作流程图解\n\n```\n 本地工作区\n    ↓\n 暂存区 (add)\n    ↓\n本地仓库 (commit)\n    ↓\n远程仓库 (push)\n```\n\n> 📌 提交之前一定要 `git pull`，避免冲突！\n\n---\n\n## 👥 五、公司级 Git 协作流程（推荐）\n\n在企业中，协作流程应当规范，常见模式如下：\n\n### 🔁 Git 分支模型推荐（Git Flow 简化版）\n\n```\nmain（线上稳定分支）\n│\n├── dev（开发集成分支）\n│   ├── feature/xxx（功能开发分支）\n│   └── bugfix/xxx（缺陷修复分支）\n└── release/xxx（预发布分支，可选）\n```\n\n### 🏢 公司协作流程典型步骤\n\n1. ✅ **从远程克隆项目**\n\n```bash\ngit clone git@company.gitlab.com:team/project.git\ncd project\n```\n\n2. ✅ **创建功能分支**\n\n```bash\ngit checkout dev         # 确保从 dev 分支切出\ngit pull                 # 拉取最新代码\ngit checkout -b feature/login-page\n```\n\n3. ✅ **开发并提交代码**\n\n```bash\ngit add .\ngit commit -m \"feat: 完成登录页面功能\"\n```\n\n4. ✅ **推送分支到远程**\n\n```bash\ngit push origin feature/login-page\n```\n\n5. ✅ **提交 Merge Request（MR/PR）**\n\n- 到 GitLab/GitHub 上发起合并请求\n- 选择合并到 `dev` 分支\n- 请求同事进行代码审核（Code Review）\n\n6. ✅ **审核通过后合并**\n\n- 审核人合并到 `dev`\n- 如有冲突，开发者需解决后重新提交\n\n7. ✅ **测试通过后，发布到 `main`**\n\n由项目负责人将 `dev` 合并到 `main`，进行线上发布。\n\n---\n\n## 🧪 六、常用高级命令与技巧\n\n### 1. 修改最近一次提交（不影响历史）\n\n```bash\ngit commit --amend\n```\n\n### 2. 查看提交历史图\n\n```bash\ngit log --oneline --graph --all\n```\n\n### 3. 恢复误删文件\n\n```bash\ngit checkout HEAD -- 被删文件路径\n```\n\n### 4. 取消 add 操作\n\n```bash\ngit reset HEAD 文件名\n```\n\n### 5. 创建忽略文件 `.gitignore`\n\n```\nnode_modules/\ndist/\n.env\n*.log\n```\n\n---\n\n## 🧯 七、常见问题排查\n\n### ❓ 合并冲突怎么办？\n\n```bash\n# 编辑冲突文件，手动选择保留的部分\n# 然后执行：\ngit add 冲突文件\ngit commit\n```\n\n### ❓ 提交被拒：需要先 pull？\n\n```bash\ngit pull --rebase\n```\n\n### ❓ 推送失败：权限被拒绝？\n\n- 确认你添加了 SSH Key\n- 查看 GitLab/GitHub 是否绑定了你的 Key\n\n---\n\n## 📚 八、团队协作建议\n\n- ✅ 每次开发新功能都新建分支，命名清晰（如 `feature/login-ui`）\n- ✅ 提交信息规范，如：\n  - `feat: 新增注册页面`\n  - `fix: 修复登录错误提示`\n  - `refactor: 重构表单逻辑`\n- ✅ 每次提交前都 `git pull`，避免代码冲突\n- ✅ 开启 MR 的代码审核流程，提高代码质量\n\n---\n\n## 📘 九、参考资料\n\n- 官方文档：https://git-scm.com/doc\n- Git 图形化客户端：Sourcetree、Fork、GitHub Desktop\n- 推荐阅读：  \n  - 《Pro Git 中文版》 https://git-scm.com/book/zh/v2\n  - 阮一峰的 Git 教程：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\n---\n\n> 作者：**[937bb]**  \n> 本文适用于中小型企业开发协作流程，欢迎转发分享，转载请注明出处 🙌\n","source":"_posts/GIT常用命令1.md","raw":"---\ntitle: \"GIT常用命令1 - \\U0001F9E0 Git 使用教程（附公司级协作流程）\"\ntop_img: /images/post/git/git.jpg\ncover: /images/post/git/git.jpg\ncategories:\n  - GIT\ntags:\n  - 教程\n  - GIT\nabbrlink: 28112\ndate: 2025-06-06 00:00:00\n---\n\n\n# 🧠 Git 使用教程（附公司级协作流程）\n\nGit 是最流行的分布式版本控制系统，广泛应用于团队协作开发中。本文将从零讲解 Git 的基本操作，并重点介绍在公司中的使用规范和协作流程。\n\n---\n\n## 📦 一、什么是 Git？\n\nGit 是一个**版本控制工具**，可以记录文件的修改历史，方便多人协作、代码回滚、版本发布等。\n\n- 本地 Git 仓库：每个开发者都有完整历史记录\n- 远程仓库（如 GitHub/GitLab）：集中托管协作开发\n\n---\n\n## 🛠️ 二、安装与配置\n\n### 安装 Git\n\n- 官网：https://git-scm.com/\n\nWindows 用户可以下载安装包，其他平台推荐使用包管理器。\n\n### 基本配置\n\n```bash\ngit config --global user.name \"你的姓名\"\ngit config --global user.email \"你的公司邮箱\"\ngit config --global core.editor \"code\"  # 设置 VSCode 为默认编辑器\n```\n\n---\n\n## 🔍 三、Git 常用命令速查\n\n| 命令                   | 说明           |\n| ---------------------- | -------------- |\n| `git init`             | 初始化本地仓库 |\n| `git clone 仓库地址`   | 克隆远程仓库   |\n| `git status`           | 查看当前状态   |\n| `git add 文件名`       | 暂存改动       |\n| `git commit -m \"注释\"` | 提交改动       |\n| `git push`             | 推送到远程     |\n| `git pull`             | 拉取最新改动   |\n| `git checkout 分支名`  | 切换分支       |\n| `git branch`           | 查看本地分支   |\n| `git merge 分支名`     | 合并分支       |\n\n---\n\n## 🧬 四、Git 工作流程图解\n\n```\n 本地工作区\n    ↓\n 暂存区 (add)\n    ↓\n本地仓库 (commit)\n    ↓\n远程仓库 (push)\n```\n\n> 📌 提交之前一定要 `git pull`，避免冲突！\n\n---\n\n## 👥 五、公司级 Git 协作流程（推荐）\n\n在企业中，协作流程应当规范，常见模式如下：\n\n### 🔁 Git 分支模型推荐（Git Flow 简化版）\n\n```\nmain（线上稳定分支）\n│\n├── dev（开发集成分支）\n│   ├── feature/xxx（功能开发分支）\n│   └── bugfix/xxx（缺陷修复分支）\n└── release/xxx（预发布分支，可选）\n```\n\n### 🏢 公司协作流程典型步骤\n\n1. ✅ **从远程克隆项目**\n\n```bash\ngit clone git@company.gitlab.com:team/project.git\ncd project\n```\n\n2. ✅ **创建功能分支**\n\n```bash\ngit checkout dev         # 确保从 dev 分支切出\ngit pull                 # 拉取最新代码\ngit checkout -b feature/login-page\n```\n\n3. ✅ **开发并提交代码**\n\n```bash\ngit add .\ngit commit -m \"feat: 完成登录页面功能\"\n```\n\n4. ✅ **推送分支到远程**\n\n```bash\ngit push origin feature/login-page\n```\n\n5. ✅ **提交 Merge Request（MR/PR）**\n\n- 到 GitLab/GitHub 上发起合并请求\n- 选择合并到 `dev` 分支\n- 请求同事进行代码审核（Code Review）\n\n6. ✅ **审核通过后合并**\n\n- 审核人合并到 `dev`\n- 如有冲突，开发者需解决后重新提交\n\n7. ✅ **测试通过后，发布到 `main`**\n\n由项目负责人将 `dev` 合并到 `main`，进行线上发布。\n\n---\n\n## 🧪 六、常用高级命令与技巧\n\n### 1. 修改最近一次提交（不影响历史）\n\n```bash\ngit commit --amend\n```\n\n### 2. 查看提交历史图\n\n```bash\ngit log --oneline --graph --all\n```\n\n### 3. 恢复误删文件\n\n```bash\ngit checkout HEAD -- 被删文件路径\n```\n\n### 4. 取消 add 操作\n\n```bash\ngit reset HEAD 文件名\n```\n\n### 5. 创建忽略文件 `.gitignore`\n\n```\nnode_modules/\ndist/\n.env\n*.log\n```\n\n---\n\n## 🧯 七、常见问题排查\n\n### ❓ 合并冲突怎么办？\n\n```bash\n# 编辑冲突文件，手动选择保留的部分\n# 然后执行：\ngit add 冲突文件\ngit commit\n```\n\n### ❓ 提交被拒：需要先 pull？\n\n```bash\ngit pull --rebase\n```\n\n### ❓ 推送失败：权限被拒绝？\n\n- 确认你添加了 SSH Key\n- 查看 GitLab/GitHub 是否绑定了你的 Key\n\n---\n\n## 📚 八、团队协作建议\n\n- ✅ 每次开发新功能都新建分支，命名清晰（如 `feature/login-ui`）\n- ✅ 提交信息规范，如：\n  - `feat: 新增注册页面`\n  - `fix: 修复登录错误提示`\n  - `refactor: 重构表单逻辑`\n- ✅ 每次提交前都 `git pull`，避免代码冲突\n- ✅ 开启 MR 的代码审核流程，提高代码质量\n\n---\n\n## 📘 九、参考资料\n\n- 官方文档：https://git-scm.com/doc\n- Git 图形化客户端：Sourcetree、Fork、GitHub Desktop\n- 推荐阅读：  \n  - 《Pro Git 中文版》 https://git-scm.com/book/zh/v2\n  - 阮一峰的 Git 教程：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\n---\n\n> 作者：**[937bb]**  \n> 本文适用于中小型企业开发协作流程，欢迎转发分享，转载请注明出处 🙌\n","slug":"GIT常用命令1","published":1,"updated":"2025-06-07T15:58:53.665Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzwvz0001pkrc6kkoh208","content":"<h1 id=\"🧠-Git-使用教程（附公司级协作流程）\"><a href=\"#🧠-Git-使用教程（附公司级协作流程）\" class=\"headerlink\" title=\"🧠 Git 使用教程（附公司级协作流程）\"></a>🧠 Git 使用教程（附公司级协作流程）</h1><p>Git 是最流行的分布式版本控制系统，广泛应用于团队协作开发中。本文将从零讲解 Git 的基本操作，并重点介绍在公司中的使用规范和协作流程。</p>\n<hr>\n<h2 id=\"📦-一、什么是-Git？\"><a href=\"#📦-一、什么是-Git？\" class=\"headerlink\" title=\"📦 一、什么是 Git？\"></a>📦 一、什么是 Git？</h2><p>Git 是一个<strong>版本控制工具</strong>，可以记录文件的修改历史，方便多人协作、代码回滚、版本发布等。</p>\n<ul>\n<li>本地 Git 仓库：每个开发者都有完整历史记录</li>\n<li>远程仓库（如 GitHub&#x2F;GitLab）：集中托管协作开发</li>\n</ul>\n<hr>\n<h2 id=\"🛠️-二、安装与配置\"><a href=\"#🛠️-二、安装与配置\" class=\"headerlink\" title=\"🛠️ 二、安装与配置\"></a>🛠️ 二、安装与配置</h2><h3 id=\"安装-Git\"><a href=\"#安装-Git\" class=\"headerlink\" title=\"安装 Git\"></a>安装 Git</h3><ul>\n<li>官网：<a href=\"https://git-scm.com/\">https://git-scm.com/</a></li>\n</ul>\n<p>Windows 用户可以下载安装包，其他平台推荐使用包管理器。</p>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;你的姓名&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;你的公司邮箱&quot;</span></span><br><span class=\"line\">git config --global core.editor <span class=\"string\">&quot;code&quot;</span>  <span class=\"comment\"># 设置 VSCode 为默认编辑器</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔍-三、Git-常用命令速查\"><a href=\"#🔍-三、Git-常用命令速查\" class=\"headerlink\" title=\"🔍 三、Git 常用命令速查\"></a>🔍 三、Git 常用命令速查</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>git init</code></td>\n<td>初始化本地仓库</td>\n</tr>\n<tr>\n<td><code>git clone 仓库地址</code></td>\n<td>克隆远程仓库</td>\n</tr>\n<tr>\n<td><code>git status</code></td>\n<td>查看当前状态</td>\n</tr>\n<tr>\n<td><code>git add 文件名</code></td>\n<td>暂存改动</td>\n</tr>\n<tr>\n<td><code>git commit -m &quot;注释&quot;</code></td>\n<td>提交改动</td>\n</tr>\n<tr>\n<td><code>git push</code></td>\n<td>推送到远程</td>\n</tr>\n<tr>\n<td><code>git pull</code></td>\n<td>拉取最新改动</td>\n</tr>\n<tr>\n<td><code>git checkout 分支名</code></td>\n<td>切换分支</td>\n</tr>\n<tr>\n<td><code>git branch</code></td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td><code>git merge 分支名</code></td>\n<td>合并分支</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧬-四、Git-工作流程图解\"><a href=\"#🧬-四、Git-工作流程图解\" class=\"headerlink\" title=\"🧬 四、Git 工作流程图解\"></a>🧬 四、Git 工作流程图解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 本地工作区</span><br><span class=\"line\">    ↓</span><br><span class=\"line\"> 暂存区 (add)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">本地仓库 (commit)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">远程仓库 (push)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>📌 提交之前一定要 <code>git pull</code>，避免冲突！</p>\n</blockquote>\n<hr>\n<h2 id=\"👥-五、公司级-Git-协作流程（推荐）\"><a href=\"#👥-五、公司级-Git-协作流程（推荐）\" class=\"headerlink\" title=\"👥 五、公司级 Git 协作流程（推荐）\"></a>👥 五、公司级 Git 协作流程（推荐）</h2><p>在企业中，协作流程应当规范，常见模式如下：</p>\n<h3 id=\"🔁-Git-分支模型推荐（Git-Flow-简化版）\"><a href=\"#🔁-Git-分支模型推荐（Git-Flow-简化版）\" class=\"headerlink\" title=\"🔁 Git 分支模型推荐（Git Flow 简化版）\"></a>🔁 Git 分支模型推荐（Git Flow 简化版）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main（线上稳定分支）</span><br><span class=\"line\">│</span><br><span class=\"line\">├── dev（开发集成分支）</span><br><span class=\"line\">│   ├── feature/xxx（功能开发分支）</span><br><span class=\"line\">│   └── bugfix/xxx（缺陷修复分支）</span><br><span class=\"line\">└── release/xxx（预发布分支，可选）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🏢-公司协作流程典型步骤\"><a href=\"#🏢-公司协作流程典型步骤\" class=\"headerlink\" title=\"🏢 公司协作流程典型步骤\"></a>🏢 公司协作流程典型步骤</h3><ol>\n<li>✅ <strong>从远程克隆项目</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@company.gitlab.com:team/project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>✅ <strong>创建功能分支</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev         <span class=\"comment\"># 确保从 dev 分支切出</span></span><br><span class=\"line\">git pull                 <span class=\"comment\"># 拉取最新代码</span></span><br><span class=\"line\">git checkout -b feature/login-page</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>✅ <strong>开发并提交代码</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;feat: 完成登录页面功能&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>✅ <strong>推送分支到远程</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login-page</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>✅ <strong>提交 Merge Request（MR&#x2F;PR）</strong></li>\n</ol>\n<ul>\n<li>到 GitLab&#x2F;GitHub 上发起合并请求</li>\n<li>选择合并到 <code>dev</code> 分支</li>\n<li>请求同事进行代码审核（Code Review）</li>\n</ul>\n<ol start=\"6\">\n<li>✅ <strong>审核通过后合并</strong></li>\n</ol>\n<ul>\n<li>审核人合并到 <code>dev</code></li>\n<li>如有冲突，开发者需解决后重新提交</li>\n</ul>\n<ol start=\"7\">\n<li>✅ <strong>测试通过后，发布到 <code>main</code></strong></li>\n</ol>\n<p>由项目负责人将 <code>dev</code> 合并到 <code>main</code>，进行线上发布。</p>\n<hr>\n<h2 id=\"🧪-六、常用高级命令与技巧\"><a href=\"#🧪-六、常用高级命令与技巧\" class=\"headerlink\" title=\"🧪 六、常用高级命令与技巧\"></a>🧪 六、常用高级命令与技巧</h2><h3 id=\"1-修改最近一次提交（不影响历史）\"><a href=\"#1-修改最近一次提交（不影响历史）\" class=\"headerlink\" title=\"1. 修改最近一次提交（不影响历史）\"></a>1. 修改最近一次提交（不影响历史）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看提交历史图\"><a href=\"#2-查看提交历史图\" class=\"headerlink\" title=\"2. 查看提交历史图\"></a>2. 查看提交历史图</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --oneline --graph --all</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-恢复误删文件\"><a href=\"#3-恢复误删文件\" class=\"headerlink\" title=\"3. 恢复误删文件\"></a>3. 恢复误删文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD -- 被删文件路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-取消-add-操作\"><a href=\"#4-取消-add-操作\" class=\"headerlink\" title=\"4. 取消 add 操作\"></a>4. 取消 add 操作</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD 文件名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-创建忽略文件-gitignore\"><a href=\"#5-创建忽略文件-gitignore\" class=\"headerlink\" title=\"5. 创建忽略文件 .gitignore\"></a>5. 创建忽略文件 <code>.gitignore</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/</span><br><span class=\"line\">dist/</span><br><span class=\"line\">.env</span><br><span class=\"line\">*.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-七、常见问题排查\"><a href=\"#🧯-七、常见问题排查\" class=\"headerlink\" title=\"🧯 七、常见问题排查\"></a>🧯 七、常见问题排查</h2><h3 id=\"❓-合并冲突怎么办？\"><a href=\"#❓-合并冲突怎么办？\" class=\"headerlink\" title=\"❓ 合并冲突怎么办？\"></a>❓ 合并冲突怎么办？</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑冲突文件，手动选择保留的部分</span></span><br><span class=\"line\"><span class=\"comment\"># 然后执行：</span></span><br><span class=\"line\">git add 冲突文件</span><br><span class=\"line\">git commit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❓-提交被拒：需要先-pull？\"><a href=\"#❓-提交被拒：需要先-pull？\" class=\"headerlink\" title=\"❓ 提交被拒：需要先 pull？\"></a>❓ 提交被拒：需要先 pull？</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❓-推送失败：权限被拒绝？\"><a href=\"#❓-推送失败：权限被拒绝？\" class=\"headerlink\" title=\"❓ 推送失败：权限被拒绝？\"></a>❓ 推送失败：权限被拒绝？</h3><ul>\n<li>确认你添加了 SSH Key</li>\n<li>查看 GitLab&#x2F;GitHub 是否绑定了你的 Key</li>\n</ul>\n<hr>\n<h2 id=\"📚-八、团队协作建议\"><a href=\"#📚-八、团队协作建议\" class=\"headerlink\" title=\"📚 八、团队协作建议\"></a>📚 八、团队协作建议</h2><ul>\n<li>✅ 每次开发新功能都新建分支，命名清晰（如 <code>feature/login-ui</code>）</li>\n<li>✅ 提交信息规范，如：<ul>\n<li><code>feat: 新增注册页面</code></li>\n<li><code>fix: 修复登录错误提示</code></li>\n<li><code>refactor: 重构表单逻辑</code></li>\n</ul>\n</li>\n<li>✅ 每次提交前都 <code>git pull</code>，避免代码冲突</li>\n<li>✅ 开启 MR 的代码审核流程，提高代码质量</li>\n</ul>\n<hr>\n<h2 id=\"📘-九、参考资料\"><a href=\"#📘-九、参考资料\" class=\"headerlink\" title=\"📘 九、参考资料\"></a>📘 九、参考资料</h2><ul>\n<li>官方文档：<a href=\"https://git-scm.com/doc\">https://git-scm.com/doc</a></li>\n<li>Git 图形化客户端：Sourcetree、Fork、GitHub Desktop</li>\n<li>推荐阅读：  <ul>\n<li>《Pro Git 中文版》 <a href=\"https://git-scm.com/book/zh/v2\">https://git-scm.com/book/zh/v2</a></li>\n<li>阮一峰的 Git 教程：<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适用于中小型企业开发协作流程，欢迎转发分享，转载请注明出处 🙌</p>\n</blockquote>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🧠-Git-使用教程（附公司级协作流程）\"><a href=\"#🧠-Git-使用教程（附公司级协作流程）\" class=\"headerlink\" title=\"🧠 Git 使用教程（附公司级协作流程）\"></a>🧠 Git 使用教程（附公司级协作流程）</h1><p>Git 是最流行的分布式版本控制系统，广泛应用于团队协作开发中。本文将从零讲解 Git 的基本操作，并重点介绍在公司中的使用规范和协作流程。</p>\n<hr>\n<h2 id=\"📦-一、什么是-Git？\"><a href=\"#📦-一、什么是-Git？\" class=\"headerlink\" title=\"📦 一、什么是 Git？\"></a>📦 一、什么是 Git？</h2><p>Git 是一个<strong>版本控制工具</strong>，可以记录文件的修改历史，方便多人协作、代码回滚、版本发布等。</p>\n<ul>\n<li>本地 Git 仓库：每个开发者都有完整历史记录</li>\n<li>远程仓库（如 GitHub&#x2F;GitLab）：集中托管协作开发</li>\n</ul>\n<hr>\n<h2 id=\"🛠️-二、安装与配置\"><a href=\"#🛠️-二、安装与配置\" class=\"headerlink\" title=\"🛠️ 二、安装与配置\"></a>🛠️ 二、安装与配置</h2><h3 id=\"安装-Git\"><a href=\"#安装-Git\" class=\"headerlink\" title=\"安装 Git\"></a>安装 Git</h3><ul>\n<li>官网：<a href=\"https://git-scm.com/\">https://git-scm.com/</a></li>\n</ul>\n<p>Windows 用户可以下载安装包，其他平台推荐使用包管理器。</p>\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;你的姓名&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">&quot;你的公司邮箱&quot;</span></span><br><span class=\"line\">git config --global core.editor <span class=\"string\">&quot;code&quot;</span>  <span class=\"comment\"># 设置 VSCode 为默认编辑器</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🔍-三、Git-常用命令速查\"><a href=\"#🔍-三、Git-常用命令速查\" class=\"headerlink\" title=\"🔍 三、Git 常用命令速查\"></a>🔍 三、Git 常用命令速查</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>git init</code></td>\n<td>初始化本地仓库</td>\n</tr>\n<tr>\n<td><code>git clone 仓库地址</code></td>\n<td>克隆远程仓库</td>\n</tr>\n<tr>\n<td><code>git status</code></td>\n<td>查看当前状态</td>\n</tr>\n<tr>\n<td><code>git add 文件名</code></td>\n<td>暂存改动</td>\n</tr>\n<tr>\n<td><code>git commit -m &quot;注释&quot;</code></td>\n<td>提交改动</td>\n</tr>\n<tr>\n<td><code>git push</code></td>\n<td>推送到远程</td>\n</tr>\n<tr>\n<td><code>git pull</code></td>\n<td>拉取最新改动</td>\n</tr>\n<tr>\n<td><code>git checkout 分支名</code></td>\n<td>切换分支</td>\n</tr>\n<tr>\n<td><code>git branch</code></td>\n<td>查看本地分支</td>\n</tr>\n<tr>\n<td><code>git merge 分支名</code></td>\n<td>合并分支</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧬-四、Git-工作流程图解\"><a href=\"#🧬-四、Git-工作流程图解\" class=\"headerlink\" title=\"🧬 四、Git 工作流程图解\"></a>🧬 四、Git 工作流程图解</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 本地工作区</span><br><span class=\"line\">    ↓</span><br><span class=\"line\"> 暂存区 (add)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">本地仓库 (commit)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">远程仓库 (push)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>📌 提交之前一定要 <code>git pull</code>，避免冲突！</p>\n</blockquote>\n<hr>\n<h2 id=\"👥-五、公司级-Git-协作流程（推荐）\"><a href=\"#👥-五、公司级-Git-协作流程（推荐）\" class=\"headerlink\" title=\"👥 五、公司级 Git 协作流程（推荐）\"></a>👥 五、公司级 Git 协作流程（推荐）</h2><p>在企业中，协作流程应当规范，常见模式如下：</p>\n<h3 id=\"🔁-Git-分支模型推荐（Git-Flow-简化版）\"><a href=\"#🔁-Git-分支模型推荐（Git-Flow-简化版）\" class=\"headerlink\" title=\"🔁 Git 分支模型推荐（Git Flow 简化版）\"></a>🔁 Git 分支模型推荐（Git Flow 简化版）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main（线上稳定分支）</span><br><span class=\"line\">│</span><br><span class=\"line\">├── dev（开发集成分支）</span><br><span class=\"line\">│   ├── feature/xxx（功能开发分支）</span><br><span class=\"line\">│   └── bugfix/xxx（缺陷修复分支）</span><br><span class=\"line\">└── release/xxx（预发布分支，可选）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🏢-公司协作流程典型步骤\"><a href=\"#🏢-公司协作流程典型步骤\" class=\"headerlink\" title=\"🏢 公司协作流程典型步骤\"></a>🏢 公司协作流程典型步骤</h3><ol>\n<li>✅ <strong>从远程克隆项目</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@company.gitlab.com:team/project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> project</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>✅ <strong>创建功能分支</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout dev         <span class=\"comment\"># 确保从 dev 分支切出</span></span><br><span class=\"line\">git pull                 <span class=\"comment\"># 拉取最新代码</span></span><br><span class=\"line\">git checkout -b feature/login-page</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>✅ <strong>开发并提交代码</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;feat: 完成登录页面功能&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>✅ <strong>推送分支到远程</strong></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin feature/login-page</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>✅ <strong>提交 Merge Request（MR&#x2F;PR）</strong></li>\n</ol>\n<ul>\n<li>到 GitLab&#x2F;GitHub 上发起合并请求</li>\n<li>选择合并到 <code>dev</code> 分支</li>\n<li>请求同事进行代码审核（Code Review）</li>\n</ul>\n<ol start=\"6\">\n<li>✅ <strong>审核通过后合并</strong></li>\n</ol>\n<ul>\n<li>审核人合并到 <code>dev</code></li>\n<li>如有冲突，开发者需解决后重新提交</li>\n</ul>\n<ol start=\"7\">\n<li>✅ <strong>测试通过后，发布到 <code>main</code></strong></li>\n</ol>\n<p>由项目负责人将 <code>dev</code> 合并到 <code>main</code>，进行线上发布。</p>\n<hr>\n<h2 id=\"🧪-六、常用高级命令与技巧\"><a href=\"#🧪-六、常用高级命令与技巧\" class=\"headerlink\" title=\"🧪 六、常用高级命令与技巧\"></a>🧪 六、常用高级命令与技巧</h2><h3 id=\"1-修改最近一次提交（不影响历史）\"><a href=\"#1-修改最近一次提交（不影响历史）\" class=\"headerlink\" title=\"1. 修改最近一次提交（不影响历史）\"></a>1. 修改最近一次提交（不影响历史）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-查看提交历史图\"><a href=\"#2-查看提交历史图\" class=\"headerlink\" title=\"2. 查看提交历史图\"></a>2. 查看提交历史图</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --oneline --graph --all</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-恢复误删文件\"><a href=\"#3-恢复误删文件\" class=\"headerlink\" title=\"3. 恢复误删文件\"></a>3. 恢复误删文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD -- 被删文件路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-取消-add-操作\"><a href=\"#4-取消-add-操作\" class=\"headerlink\" title=\"4. 取消 add 操作\"></a>4. 取消 add 操作</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset HEAD 文件名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-创建忽略文件-gitignore\"><a href=\"#5-创建忽略文件-gitignore\" class=\"headerlink\" title=\"5. 创建忽略文件 .gitignore\"></a>5. 创建忽略文件 <code>.gitignore</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/</span><br><span class=\"line\">dist/</span><br><span class=\"line\">.env</span><br><span class=\"line\">*.log</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-七、常见问题排查\"><a href=\"#🧯-七、常见问题排查\" class=\"headerlink\" title=\"🧯 七、常见问题排查\"></a>🧯 七、常见问题排查</h2><h3 id=\"❓-合并冲突怎么办？\"><a href=\"#❓-合并冲突怎么办？\" class=\"headerlink\" title=\"❓ 合并冲突怎么办？\"></a>❓ 合并冲突怎么办？</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编辑冲突文件，手动选择保留的部分</span></span><br><span class=\"line\"><span class=\"comment\"># 然后执行：</span></span><br><span class=\"line\">git add 冲突文件</span><br><span class=\"line\">git commit</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❓-提交被拒：需要先-pull？\"><a href=\"#❓-提交被拒：需要先-pull？\" class=\"headerlink\" title=\"❓ 提交被拒：需要先 pull？\"></a>❓ 提交被拒：需要先 pull？</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"❓-推送失败：权限被拒绝？\"><a href=\"#❓-推送失败：权限被拒绝？\" class=\"headerlink\" title=\"❓ 推送失败：权限被拒绝？\"></a>❓ 推送失败：权限被拒绝？</h3><ul>\n<li>确认你添加了 SSH Key</li>\n<li>查看 GitLab&#x2F;GitHub 是否绑定了你的 Key</li>\n</ul>\n<hr>\n<h2 id=\"📚-八、团队协作建议\"><a href=\"#📚-八、团队协作建议\" class=\"headerlink\" title=\"📚 八、团队协作建议\"></a>📚 八、团队协作建议</h2><ul>\n<li>✅ 每次开发新功能都新建分支，命名清晰（如 <code>feature/login-ui</code>）</li>\n<li>✅ 提交信息规范，如：<ul>\n<li><code>feat: 新增注册页面</code></li>\n<li><code>fix: 修复登录错误提示</code></li>\n<li><code>refactor: 重构表单逻辑</code></li>\n</ul>\n</li>\n<li>✅ 每次提交前都 <code>git pull</code>，避免代码冲突</li>\n<li>✅ 开启 MR 的代码审核流程，提高代码质量</li>\n</ul>\n<hr>\n<h2 id=\"📘-九、参考资料\"><a href=\"#📘-九、参考资料\" class=\"headerlink\" title=\"📘 九、参考资料\"></a>📘 九、参考资料</h2><ul>\n<li>官方文档：<a href=\"https://git-scm.com/doc\">https://git-scm.com/doc</a></li>\n<li>Git 图形化客户端：Sourcetree、Fork、GitHub Desktop</li>\n<li>推荐阅读：  <ul>\n<li>《Pro Git 中文版》 <a href=\"https://git-scm.com/book/zh/v2\">https://git-scm.com/book/zh/v2</a></li>\n<li>阮一峰的 Git 教程：<a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适用于中小型企业开发协作流程，欢迎转发分享，转载请注明出处 🙌</p>\n</blockquote>\n"},{"title":"Linux常用命令1 - 🐧 Linux 常用命令大全（小白入门 + 日常运维）","top_img":"/images/post/linux/linux.jpg","cover":"/images/post/linux/linux.jpg","abbrlink":56257,"date":"2025-06-05T16:00:00.000Z","_content":"\n\n# 🐧 Linux 常用命令大全（小白入门 + 日常运维）\n\n本文总结了日常使用 Linux 系统过程中最常用的命令，涵盖文件管理、用户权限、进程管理、网络、软件安装等常见场景。\n\n---\n\n## 📁 一、文件和目录操作\n\n| 命令 | 作用 |\n|------|------|\n| `ls` | 查看当前目录内容 |\n| `ls -l` | 详细列表 |\n| `cd 目录名` | 进入目录 |\n| `pwd` | 显示当前路径 |\n| `mkdir 目录名` | 新建目录 |\n| `rm 文件名` | 删除文件 |\n| `rm -r 目录名` | 递归删除目录 |\n| `cp 源 目标` | 复制文件/目录 |\n| `mv 源 目标` | 移动/重命名 |\n| `touch 文件名` | 创建空文件 |\n| `cat 文件名` | 查看文件内容 |\n| `more / less 文件名` | 分页查看大文件 |\n| `head -n 10 文件` | 查看前 10 行 |\n| `tail -n 10 文件` | 查看最后 10 行 |\n| `tree` | 树状结构查看目录（需安装） |\n\n---\n\n## 🔍 二、查找与搜索\n\n| 命令 | 说明 |\n|------|------|\n| `find /路径 -name 文件名` | 在目录下查找文件 |\n| `grep \"关键字\" 文件名` | 搜索文本内容 |\n| `grep -r \"关键字\" 路径` | 递归搜索 |\n| `which 命令名` | 查看命令路径 |\n| `locate 文件名` | 快速查找文件（需安装并更新数据库） |\n\n---\n\n## 🔐 三、权限与用户管理\n\n| 命令 | 说明 |\n|------|------|\n| `chmod +x 文件` | 增加执行权限 |\n| `chmod 755 文件` | 设置权限 |\n| `chown 用户 文件` | 更改文件拥有者 |\n| `adduser 用户名` | 添加用户 |\n| `passwd 用户名` | 修改用户密码 |\n| `su 用户名` | 切换用户 |\n| `sudo 命令` | 以管理员权限执行 |\n\n---\n\n## ⚙️ 四、系统与进程管理\n\n| 命令 | 说明 |\n|------|------|\n| `top` | 查看实时系统资源 |\n| `htop` | 更友好的进程管理（需安装） |\n| `ps aux` | 查看所有进程 |\n| `kill PID` | 终止指定进程 |\n| `kill -9 PID` | 强制终止 |\n| `df -h` | 查看磁盘空间 |\n| `du -sh *` | 查看目录大小 |\n| `free -h` | 查看内存使用 |\n| `uptime` | 系统运行时间 |\n| `uname -a` | 查看系统信息 |\n| `whoami` | 当前用户名 |\n\n---\n\n## 🌐 五、网络相关命令\n\n| 命令 | 说明 |\n|------|------|\n| `ping 地址` | 测试网络连接 |\n| `ifconfig` / `ip a` | 查看网络配置 |\n| `netstat -tuln` | 查看监听端口 |\n| `curl 地址` | 请求网页内容 |\n| `wget 地址` | 下载文件 |\n| `scp 文件 用户@IP:/路径` | 远程复制 |\n| `ssh 用户@IP` | 远程登录 |\n\n---\n\n## 📦 六、软件安装和管理（以 Debian/Ubuntu 为例）\n\n| 命令 | 说明 |\n|------|------|\n| `sudo apt update` | 更新软件源 |\n| `sudo apt upgrade` | 升级系统 |\n| `sudo apt install 包名` | 安装软件 |\n| `sudo apt remove 包名` | 卸载软件 |\n| `dpkg -i 包名.deb` | 安装本地包 |\n| `apt search 包名` | 搜索包 |\n| `apt list --installed` | 查看已安装 |\n\n---\n\n## 📄 七、压缩与解压\n\n| 命令 | 说明 |\n|------|------|\n| `tar -czvf a.tar.gz 目录/` | 打包并压缩 |\n| `tar -xzvf a.tar.gz` | 解压 |\n| `zip -r a.zip 文件夹/` | 压缩为 zip |\n| `unzip a.zip` | 解压 zip |\n\n---\n\n## 🐚 八、Shell 脚本基础（入门示例）\n\n### 示例：自动备份脚本 `backup.sh`\n\n```bash\n#!/bin/bash\n# 备份当前目录到 /backup\n\nDATE=$(date +%Y-%m-%d)\nBACKUP_DIR=\"/backup/backup_$DATE\"\n\nmkdir -p $BACKUP_DIR\ncp -r * $BACKUP_DIR\n\necho \"Backup completed to $BACKUP_DIR\"\n```\n\n运行方式：\n\n```bash\nchmod +x backup.sh\n./backup.sh\n```\n\n---\n\n## 🧯 九、常见问题解决\n\n### ❓ 文件/命令找不到？\n\n- 检查是否安装：`which 命令`\n- 检查路径拼写\n- 使用 `locate` 快速查找文件位置\n\n### ❓ 权限不够？\n\n- 加 `sudo` 试试\n- `chmod` 或 `chown` 修改权限或所有者\n\n### ❓ 命令执行卡住？\n\n- 用 `Ctrl + C` 中断\n- 或使用 `top` / `kill` 终止进程\n\n---\n\n## 📘 十、学习资源推荐\n\n- Linux 命令大全：https://wangdoc.com/linux/\n- 菜鸟教程：https://www.runoob.com/linux/linux-command-manual.html\n- man 手册：`man 命令名`（如 `man ls`）\n\n---\n\n> 作者：**[937bb]**  \n> 本文适合 Linux 新手与初级运维，欢迎转发收藏，转载请注明出处 🔁\n","source":"_posts/Linxu常用命令1.md","raw":"---\ntitle: \"Linux常用命令1 - \\U0001F427 Linux 常用命令大全（小白入门 + 日常运维）\"\ntop_img: /images/post/linux/linux.jpg\ncover: /images/post/linux/linux.jpg\ncategories:\n  - Linux\ntags:\n  - 教程\n  - Linux\nabbrlink: 56257\ndate: 2025-06-06 00:00:00\n---\n\n\n# 🐧 Linux 常用命令大全（小白入门 + 日常运维）\n\n本文总结了日常使用 Linux 系统过程中最常用的命令，涵盖文件管理、用户权限、进程管理、网络、软件安装等常见场景。\n\n---\n\n## 📁 一、文件和目录操作\n\n| 命令 | 作用 |\n|------|------|\n| `ls` | 查看当前目录内容 |\n| `ls -l` | 详细列表 |\n| `cd 目录名` | 进入目录 |\n| `pwd` | 显示当前路径 |\n| `mkdir 目录名` | 新建目录 |\n| `rm 文件名` | 删除文件 |\n| `rm -r 目录名` | 递归删除目录 |\n| `cp 源 目标` | 复制文件/目录 |\n| `mv 源 目标` | 移动/重命名 |\n| `touch 文件名` | 创建空文件 |\n| `cat 文件名` | 查看文件内容 |\n| `more / less 文件名` | 分页查看大文件 |\n| `head -n 10 文件` | 查看前 10 行 |\n| `tail -n 10 文件` | 查看最后 10 行 |\n| `tree` | 树状结构查看目录（需安装） |\n\n---\n\n## 🔍 二、查找与搜索\n\n| 命令 | 说明 |\n|------|------|\n| `find /路径 -name 文件名` | 在目录下查找文件 |\n| `grep \"关键字\" 文件名` | 搜索文本内容 |\n| `grep -r \"关键字\" 路径` | 递归搜索 |\n| `which 命令名` | 查看命令路径 |\n| `locate 文件名` | 快速查找文件（需安装并更新数据库） |\n\n---\n\n## 🔐 三、权限与用户管理\n\n| 命令 | 说明 |\n|------|------|\n| `chmod +x 文件` | 增加执行权限 |\n| `chmod 755 文件` | 设置权限 |\n| `chown 用户 文件` | 更改文件拥有者 |\n| `adduser 用户名` | 添加用户 |\n| `passwd 用户名` | 修改用户密码 |\n| `su 用户名` | 切换用户 |\n| `sudo 命令` | 以管理员权限执行 |\n\n---\n\n## ⚙️ 四、系统与进程管理\n\n| 命令 | 说明 |\n|------|------|\n| `top` | 查看实时系统资源 |\n| `htop` | 更友好的进程管理（需安装） |\n| `ps aux` | 查看所有进程 |\n| `kill PID` | 终止指定进程 |\n| `kill -9 PID` | 强制终止 |\n| `df -h` | 查看磁盘空间 |\n| `du -sh *` | 查看目录大小 |\n| `free -h` | 查看内存使用 |\n| `uptime` | 系统运行时间 |\n| `uname -a` | 查看系统信息 |\n| `whoami` | 当前用户名 |\n\n---\n\n## 🌐 五、网络相关命令\n\n| 命令 | 说明 |\n|------|------|\n| `ping 地址` | 测试网络连接 |\n| `ifconfig` / `ip a` | 查看网络配置 |\n| `netstat -tuln` | 查看监听端口 |\n| `curl 地址` | 请求网页内容 |\n| `wget 地址` | 下载文件 |\n| `scp 文件 用户@IP:/路径` | 远程复制 |\n| `ssh 用户@IP` | 远程登录 |\n\n---\n\n## 📦 六、软件安装和管理（以 Debian/Ubuntu 为例）\n\n| 命令 | 说明 |\n|------|------|\n| `sudo apt update` | 更新软件源 |\n| `sudo apt upgrade` | 升级系统 |\n| `sudo apt install 包名` | 安装软件 |\n| `sudo apt remove 包名` | 卸载软件 |\n| `dpkg -i 包名.deb` | 安装本地包 |\n| `apt search 包名` | 搜索包 |\n| `apt list --installed` | 查看已安装 |\n\n---\n\n## 📄 七、压缩与解压\n\n| 命令 | 说明 |\n|------|------|\n| `tar -czvf a.tar.gz 目录/` | 打包并压缩 |\n| `tar -xzvf a.tar.gz` | 解压 |\n| `zip -r a.zip 文件夹/` | 压缩为 zip |\n| `unzip a.zip` | 解压 zip |\n\n---\n\n## 🐚 八、Shell 脚本基础（入门示例）\n\n### 示例：自动备份脚本 `backup.sh`\n\n```bash\n#!/bin/bash\n# 备份当前目录到 /backup\n\nDATE=$(date +%Y-%m-%d)\nBACKUP_DIR=\"/backup/backup_$DATE\"\n\nmkdir -p $BACKUP_DIR\ncp -r * $BACKUP_DIR\n\necho \"Backup completed to $BACKUP_DIR\"\n```\n\n运行方式：\n\n```bash\nchmod +x backup.sh\n./backup.sh\n```\n\n---\n\n## 🧯 九、常见问题解决\n\n### ❓ 文件/命令找不到？\n\n- 检查是否安装：`which 命令`\n- 检查路径拼写\n- 使用 `locate` 快速查找文件位置\n\n### ❓ 权限不够？\n\n- 加 `sudo` 试试\n- `chmod` 或 `chown` 修改权限或所有者\n\n### ❓ 命令执行卡住？\n\n- 用 `Ctrl + C` 中断\n- 或使用 `top` / `kill` 终止进程\n\n---\n\n## 📘 十、学习资源推荐\n\n- Linux 命令大全：https://wangdoc.com/linux/\n- 菜鸟教程：https://www.runoob.com/linux/linux-command-manual.html\n- man 手册：`man 命令名`（如 `man ls`）\n\n---\n\n> 作者：**[937bb]**  \n> 本文适合 Linux 新手与初级运维，欢迎转发收藏，转载请注明出处 🔁\n","slug":"Linxu常用命令1","published":1,"updated":"2025-06-07T15:58:53.665Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww10003pkrcbga7b6pz","content":"<h1 id=\"🐧-Linux-常用命令大全（小白入门-日常运维）\"><a href=\"#🐧-Linux-常用命令大全（小白入门-日常运维）\" class=\"headerlink\" title=\"🐧 Linux 常用命令大全（小白入门 + 日常运维）\"></a>🐧 Linux 常用命令大全（小白入门 + 日常运维）</h1><p>本文总结了日常使用 Linux 系统过程中最常用的命令，涵盖文件管理、用户权限、进程管理、网络、软件安装等常见场景。</p>\n<hr>\n<h2 id=\"📁-一、文件和目录操作\"><a href=\"#📁-一、文件和目录操作\" class=\"headerlink\" title=\"📁 一、文件和目录操作\"></a>📁 一、文件和目录操作</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ls</code></td>\n<td>查看当前目录内容</td>\n</tr>\n<tr>\n<td><code>ls -l</code></td>\n<td>详细列表</td>\n</tr>\n<tr>\n<td><code>cd 目录名</code></td>\n<td>进入目录</td>\n</tr>\n<tr>\n<td><code>pwd</code></td>\n<td>显示当前路径</td>\n</tr>\n<tr>\n<td><code>mkdir 目录名</code></td>\n<td>新建目录</td>\n</tr>\n<tr>\n<td><code>rm 文件名</code></td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td><code>rm -r 目录名</code></td>\n<td>递归删除目录</td>\n</tr>\n<tr>\n<td><code>cp 源 目标</code></td>\n<td>复制文件&#x2F;目录</td>\n</tr>\n<tr>\n<td><code>mv 源 目标</code></td>\n<td>移动&#x2F;重命名</td>\n</tr>\n<tr>\n<td><code>touch 文件名</code></td>\n<td>创建空文件</td>\n</tr>\n<tr>\n<td><code>cat 文件名</code></td>\n<td>查看文件内容</td>\n</tr>\n<tr>\n<td><code>more / less 文件名</code></td>\n<td>分页查看大文件</td>\n</tr>\n<tr>\n<td><code>head -n 10 文件</code></td>\n<td>查看前 10 行</td>\n</tr>\n<tr>\n<td><code>tail -n 10 文件</code></td>\n<td>查看最后 10 行</td>\n</tr>\n<tr>\n<td><code>tree</code></td>\n<td>树状结构查看目录（需安装）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-二、查找与搜索\"><a href=\"#🔍-二、查找与搜索\" class=\"headerlink\" title=\"🔍 二、查找与搜索\"></a>🔍 二、查找与搜索</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>find /路径 -name 文件名</code></td>\n<td>在目录下查找文件</td>\n</tr>\n<tr>\n<td><code>grep &quot;关键字&quot; 文件名</code></td>\n<td>搜索文本内容</td>\n</tr>\n<tr>\n<td><code>grep -r &quot;关键字&quot; 路径</code></td>\n<td>递归搜索</td>\n</tr>\n<tr>\n<td><code>which 命令名</code></td>\n<td>查看命令路径</td>\n</tr>\n<tr>\n<td><code>locate 文件名</code></td>\n<td>快速查找文件（需安装并更新数据库）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔐-三、权限与用户管理\"><a href=\"#🔐-三、权限与用户管理\" class=\"headerlink\" title=\"🔐 三、权限与用户管理\"></a>🔐 三、权限与用户管理</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>chmod +x 文件</code></td>\n<td>增加执行权限</td>\n</tr>\n<tr>\n<td><code>chmod 755 文件</code></td>\n<td>设置权限</td>\n</tr>\n<tr>\n<td><code>chown 用户 文件</code></td>\n<td>更改文件拥有者</td>\n</tr>\n<tr>\n<td><code>adduser 用户名</code></td>\n<td>添加用户</td>\n</tr>\n<tr>\n<td><code>passwd 用户名</code></td>\n<td>修改用户密码</td>\n</tr>\n<tr>\n<td><code>su 用户名</code></td>\n<td>切换用户</td>\n</tr>\n<tr>\n<td><code>sudo 命令</code></td>\n<td>以管理员权限执行</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"⚙️-四、系统与进程管理\"><a href=\"#⚙️-四、系统与进程管理\" class=\"headerlink\" title=\"⚙️ 四、系统与进程管理\"></a>⚙️ 四、系统与进程管理</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>top</code></td>\n<td>查看实时系统资源</td>\n</tr>\n<tr>\n<td><code>htop</code></td>\n<td>更友好的进程管理（需安装）</td>\n</tr>\n<tr>\n<td><code>ps aux</code></td>\n<td>查看所有进程</td>\n</tr>\n<tr>\n<td><code>kill PID</code></td>\n<td>终止指定进程</td>\n</tr>\n<tr>\n<td><code>kill -9 PID</code></td>\n<td>强制终止</td>\n</tr>\n<tr>\n<td><code>df -h</code></td>\n<td>查看磁盘空间</td>\n</tr>\n<tr>\n<td><code>du -sh *</code></td>\n<td>查看目录大小</td>\n</tr>\n<tr>\n<td><code>free -h</code></td>\n<td>查看内存使用</td>\n</tr>\n<tr>\n<td><code>uptime</code></td>\n<td>系统运行时间</td>\n</tr>\n<tr>\n<td><code>uname -a</code></td>\n<td>查看系统信息</td>\n</tr>\n<tr>\n<td><code>whoami</code></td>\n<td>当前用户名</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🌐-五、网络相关命令\"><a href=\"#🌐-五、网络相关命令\" class=\"headerlink\" title=\"🌐 五、网络相关命令\"></a>🌐 五、网络相关命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ping 地址</code></td>\n<td>测试网络连接</td>\n</tr>\n<tr>\n<td><code>ifconfig</code> &#x2F; <code>ip a</code></td>\n<td>查看网络配置</td>\n</tr>\n<tr>\n<td><code>netstat -tuln</code></td>\n<td>查看监听端口</td>\n</tr>\n<tr>\n<td><code>curl 地址</code></td>\n<td>请求网页内容</td>\n</tr>\n<tr>\n<td><code>wget 地址</code></td>\n<td>下载文件</td>\n</tr>\n<tr>\n<td><code>scp 文件 用户@IP:/路径</code></td>\n<td>远程复制</td>\n</tr>\n<tr>\n<td><code>ssh 用户@IP</code></td>\n<td>远程登录</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📦-六、软件安装和管理（以-Debian-Ubuntu-为例）\"><a href=\"#📦-六、软件安装和管理（以-Debian-Ubuntu-为例）\" class=\"headerlink\" title=\"📦 六、软件安装和管理（以 Debian&#x2F;Ubuntu 为例）\"></a>📦 六、软件安装和管理（以 Debian&#x2F;Ubuntu 为例）</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sudo apt update</code></td>\n<td>更新软件源</td>\n</tr>\n<tr>\n<td><code>sudo apt upgrade</code></td>\n<td>升级系统</td>\n</tr>\n<tr>\n<td><code>sudo apt install 包名</code></td>\n<td>安装软件</td>\n</tr>\n<tr>\n<td><code>sudo apt remove 包名</code></td>\n<td>卸载软件</td>\n</tr>\n<tr>\n<td><code>dpkg -i 包名.deb</code></td>\n<td>安装本地包</td>\n</tr>\n<tr>\n<td><code>apt search 包名</code></td>\n<td>搜索包</td>\n</tr>\n<tr>\n<td><code>apt list --installed</code></td>\n<td>查看已安装</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📄-七、压缩与解压\"><a href=\"#📄-七、压缩与解压\" class=\"headerlink\" title=\"📄 七、压缩与解压\"></a>📄 七、压缩与解压</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tar -czvf a.tar.gz 目录/</code></td>\n<td>打包并压缩</td>\n</tr>\n<tr>\n<td><code>tar -xzvf a.tar.gz</code></td>\n<td>解压</td>\n</tr>\n<tr>\n<td><code>zip -r a.zip 文件夹/</code></td>\n<td>压缩为 zip</td>\n</tr>\n<tr>\n<td><code>unzip a.zip</code></td>\n<td>解压 zip</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🐚-八、Shell-脚本基础（入门示例）\"><a href=\"#🐚-八、Shell-脚本基础（入门示例）\" class=\"headerlink\" title=\"🐚 八、Shell 脚本基础（入门示例）\"></a>🐚 八、Shell 脚本基础（入门示例）</h2><h3 id=\"示例：自动备份脚本-backup-sh\"><a href=\"#示例：自动备份脚本-backup-sh\" class=\"headerlink\" title=\"示例：自动备份脚本 backup.sh\"></a>示例：自动备份脚本 <code>backup.sh</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># 备份当前目录到 /backup</span></span><br><span class=\"line\"></span><br><span class=\"line\">DATE=$(<span class=\"built_in\">date</span> +%Y-%m-%d)</span><br><span class=\"line\">BACKUP_DIR=<span class=\"string\">&quot;/backup/backup_<span class=\"variable\">$DATE</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p <span class=\"variable\">$BACKUP_DIR</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -r * <span class=\"variable\">$BACKUP_DIR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Backup completed to <span class=\"variable\">$BACKUP_DIR</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x backup.sh</span><br><span class=\"line\">./backup.sh</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-九、常见问题解决\"><a href=\"#🧯-九、常见问题解决\" class=\"headerlink\" title=\"🧯 九、常见问题解决\"></a>🧯 九、常见问题解决</h2><h3 id=\"❓-文件-命令找不到？\"><a href=\"#❓-文件-命令找不到？\" class=\"headerlink\" title=\"❓ 文件&#x2F;命令找不到？\"></a>❓ 文件&#x2F;命令找不到？</h3><ul>\n<li>检查是否安装：<code>which 命令</code></li>\n<li>检查路径拼写</li>\n<li>使用 <code>locate</code> 快速查找文件位置</li>\n</ul>\n<h3 id=\"❓-权限不够？\"><a href=\"#❓-权限不够？\" class=\"headerlink\" title=\"❓ 权限不够？\"></a>❓ 权限不够？</h3><ul>\n<li>加 <code>sudo</code> 试试</li>\n<li><code>chmod</code> 或 <code>chown</code> 修改权限或所有者</li>\n</ul>\n<h3 id=\"❓-命令执行卡住？\"><a href=\"#❓-命令执行卡住？\" class=\"headerlink\" title=\"❓ 命令执行卡住？\"></a>❓ 命令执行卡住？</h3><ul>\n<li>用 <code>Ctrl + C</code> 中断</li>\n<li>或使用 <code>top</code> &#x2F; <code>kill</code> 终止进程</li>\n</ul>\n<hr>\n<h2 id=\"📘-十、学习资源推荐\"><a href=\"#📘-十、学习资源推荐\" class=\"headerlink\" title=\"📘 十、学习资源推荐\"></a>📘 十、学习资源推荐</h2><ul>\n<li>Linux 命令大全：<a href=\"https://wangdoc.com/linux/\">https://wangdoc.com/linux/</a></li>\n<li>菜鸟教程：<a href=\"https://www.runoob.com/linux/linux-command-manual.html\">https://www.runoob.com/linux/linux-command-manual.html</a></li>\n<li>man 手册：<code>man 命令名</code>（如 <code>man ls</code>）</li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适合 Linux 新手与初级运维，欢迎转发收藏，转载请注明出处 🔁</p>\n</blockquote>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐧-Linux-常用命令大全（小白入门-日常运维）\"><a href=\"#🐧-Linux-常用命令大全（小白入门-日常运维）\" class=\"headerlink\" title=\"🐧 Linux 常用命令大全（小白入门 + 日常运维）\"></a>🐧 Linux 常用命令大全（小白入门 + 日常运维）</h1><p>本文总结了日常使用 Linux 系统过程中最常用的命令，涵盖文件管理、用户权限、进程管理、网络、软件安装等常见场景。</p>\n<hr>\n<h2 id=\"📁-一、文件和目录操作\"><a href=\"#📁-一、文件和目录操作\" class=\"headerlink\" title=\"📁 一、文件和目录操作\"></a>📁 一、文件和目录操作</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ls</code></td>\n<td>查看当前目录内容</td>\n</tr>\n<tr>\n<td><code>ls -l</code></td>\n<td>详细列表</td>\n</tr>\n<tr>\n<td><code>cd 目录名</code></td>\n<td>进入目录</td>\n</tr>\n<tr>\n<td><code>pwd</code></td>\n<td>显示当前路径</td>\n</tr>\n<tr>\n<td><code>mkdir 目录名</code></td>\n<td>新建目录</td>\n</tr>\n<tr>\n<td><code>rm 文件名</code></td>\n<td>删除文件</td>\n</tr>\n<tr>\n<td><code>rm -r 目录名</code></td>\n<td>递归删除目录</td>\n</tr>\n<tr>\n<td><code>cp 源 目标</code></td>\n<td>复制文件&#x2F;目录</td>\n</tr>\n<tr>\n<td><code>mv 源 目标</code></td>\n<td>移动&#x2F;重命名</td>\n</tr>\n<tr>\n<td><code>touch 文件名</code></td>\n<td>创建空文件</td>\n</tr>\n<tr>\n<td><code>cat 文件名</code></td>\n<td>查看文件内容</td>\n</tr>\n<tr>\n<td><code>more / less 文件名</code></td>\n<td>分页查看大文件</td>\n</tr>\n<tr>\n<td><code>head -n 10 文件</code></td>\n<td>查看前 10 行</td>\n</tr>\n<tr>\n<td><code>tail -n 10 文件</code></td>\n<td>查看最后 10 行</td>\n</tr>\n<tr>\n<td><code>tree</code></td>\n<td>树状结构查看目录（需安装）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔍-二、查找与搜索\"><a href=\"#🔍-二、查找与搜索\" class=\"headerlink\" title=\"🔍 二、查找与搜索\"></a>🔍 二、查找与搜索</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>find /路径 -name 文件名</code></td>\n<td>在目录下查找文件</td>\n</tr>\n<tr>\n<td><code>grep &quot;关键字&quot; 文件名</code></td>\n<td>搜索文本内容</td>\n</tr>\n<tr>\n<td><code>grep -r &quot;关键字&quot; 路径</code></td>\n<td>递归搜索</td>\n</tr>\n<tr>\n<td><code>which 命令名</code></td>\n<td>查看命令路径</td>\n</tr>\n<tr>\n<td><code>locate 文件名</code></td>\n<td>快速查找文件（需安装并更新数据库）</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔐-三、权限与用户管理\"><a href=\"#🔐-三、权限与用户管理\" class=\"headerlink\" title=\"🔐 三、权限与用户管理\"></a>🔐 三、权限与用户管理</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>chmod +x 文件</code></td>\n<td>增加执行权限</td>\n</tr>\n<tr>\n<td><code>chmod 755 文件</code></td>\n<td>设置权限</td>\n</tr>\n<tr>\n<td><code>chown 用户 文件</code></td>\n<td>更改文件拥有者</td>\n</tr>\n<tr>\n<td><code>adduser 用户名</code></td>\n<td>添加用户</td>\n</tr>\n<tr>\n<td><code>passwd 用户名</code></td>\n<td>修改用户密码</td>\n</tr>\n<tr>\n<td><code>su 用户名</code></td>\n<td>切换用户</td>\n</tr>\n<tr>\n<td><code>sudo 命令</code></td>\n<td>以管理员权限执行</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"⚙️-四、系统与进程管理\"><a href=\"#⚙️-四、系统与进程管理\" class=\"headerlink\" title=\"⚙️ 四、系统与进程管理\"></a>⚙️ 四、系统与进程管理</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>top</code></td>\n<td>查看实时系统资源</td>\n</tr>\n<tr>\n<td><code>htop</code></td>\n<td>更友好的进程管理（需安装）</td>\n</tr>\n<tr>\n<td><code>ps aux</code></td>\n<td>查看所有进程</td>\n</tr>\n<tr>\n<td><code>kill PID</code></td>\n<td>终止指定进程</td>\n</tr>\n<tr>\n<td><code>kill -9 PID</code></td>\n<td>强制终止</td>\n</tr>\n<tr>\n<td><code>df -h</code></td>\n<td>查看磁盘空间</td>\n</tr>\n<tr>\n<td><code>du -sh *</code></td>\n<td>查看目录大小</td>\n</tr>\n<tr>\n<td><code>free -h</code></td>\n<td>查看内存使用</td>\n</tr>\n<tr>\n<td><code>uptime</code></td>\n<td>系统运行时间</td>\n</tr>\n<tr>\n<td><code>uname -a</code></td>\n<td>查看系统信息</td>\n</tr>\n<tr>\n<td><code>whoami</code></td>\n<td>当前用户名</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🌐-五、网络相关命令\"><a href=\"#🌐-五、网络相关命令\" class=\"headerlink\" title=\"🌐 五、网络相关命令\"></a>🌐 五、网络相关命令</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ping 地址</code></td>\n<td>测试网络连接</td>\n</tr>\n<tr>\n<td><code>ifconfig</code> &#x2F; <code>ip a</code></td>\n<td>查看网络配置</td>\n</tr>\n<tr>\n<td><code>netstat -tuln</code></td>\n<td>查看监听端口</td>\n</tr>\n<tr>\n<td><code>curl 地址</code></td>\n<td>请求网页内容</td>\n</tr>\n<tr>\n<td><code>wget 地址</code></td>\n<td>下载文件</td>\n</tr>\n<tr>\n<td><code>scp 文件 用户@IP:/路径</code></td>\n<td>远程复制</td>\n</tr>\n<tr>\n<td><code>ssh 用户@IP</code></td>\n<td>远程登录</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📦-六、软件安装和管理（以-Debian-Ubuntu-为例）\"><a href=\"#📦-六、软件安装和管理（以-Debian-Ubuntu-为例）\" class=\"headerlink\" title=\"📦 六、软件安装和管理（以 Debian&#x2F;Ubuntu 为例）\"></a>📦 六、软件安装和管理（以 Debian&#x2F;Ubuntu 为例）</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>sudo apt update</code></td>\n<td>更新软件源</td>\n</tr>\n<tr>\n<td><code>sudo apt upgrade</code></td>\n<td>升级系统</td>\n</tr>\n<tr>\n<td><code>sudo apt install 包名</code></td>\n<td>安装软件</td>\n</tr>\n<tr>\n<td><code>sudo apt remove 包名</code></td>\n<td>卸载软件</td>\n</tr>\n<tr>\n<td><code>dpkg -i 包名.deb</code></td>\n<td>安装本地包</td>\n</tr>\n<tr>\n<td><code>apt search 包名</code></td>\n<td>搜索包</td>\n</tr>\n<tr>\n<td><code>apt list --installed</code></td>\n<td>查看已安装</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📄-七、压缩与解压\"><a href=\"#📄-七、压缩与解压\" class=\"headerlink\" title=\"📄 七、压缩与解压\"></a>📄 七、压缩与解压</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tar -czvf a.tar.gz 目录/</code></td>\n<td>打包并压缩</td>\n</tr>\n<tr>\n<td><code>tar -xzvf a.tar.gz</code></td>\n<td>解压</td>\n</tr>\n<tr>\n<td><code>zip -r a.zip 文件夹/</code></td>\n<td>压缩为 zip</td>\n</tr>\n<tr>\n<td><code>unzip a.zip</code></td>\n<td>解压 zip</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🐚-八、Shell-脚本基础（入门示例）\"><a href=\"#🐚-八、Shell-脚本基础（入门示例）\" class=\"headerlink\" title=\"🐚 八、Shell 脚本基础（入门示例）\"></a>🐚 八、Shell 脚本基础（入门示例）</h2><h3 id=\"示例：自动备份脚本-backup-sh\"><a href=\"#示例：自动备份脚本-backup-sh\" class=\"headerlink\" title=\"示例：自动备份脚本 backup.sh\"></a>示例：自动备份脚本 <code>backup.sh</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># 备份当前目录到 /backup</span></span><br><span class=\"line\"></span><br><span class=\"line\">DATE=$(<span class=\"built_in\">date</span> +%Y-%m-%d)</span><br><span class=\"line\">BACKUP_DIR=<span class=\"string\">&quot;/backup/backup_<span class=\"variable\">$DATE</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p <span class=\"variable\">$BACKUP_DIR</span></span><br><span class=\"line\"><span class=\"built_in\">cp</span> -r * <span class=\"variable\">$BACKUP_DIR</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Backup completed to <span class=\"variable\">$BACKUP_DIR</span>&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行方式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> +x backup.sh</span><br><span class=\"line\">./backup.sh</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-九、常见问题解决\"><a href=\"#🧯-九、常见问题解决\" class=\"headerlink\" title=\"🧯 九、常见问题解决\"></a>🧯 九、常见问题解决</h2><h3 id=\"❓-文件-命令找不到？\"><a href=\"#❓-文件-命令找不到？\" class=\"headerlink\" title=\"❓ 文件&#x2F;命令找不到？\"></a>❓ 文件&#x2F;命令找不到？</h3><ul>\n<li>检查是否安装：<code>which 命令</code></li>\n<li>检查路径拼写</li>\n<li>使用 <code>locate</code> 快速查找文件位置</li>\n</ul>\n<h3 id=\"❓-权限不够？\"><a href=\"#❓-权限不够？\" class=\"headerlink\" title=\"❓ 权限不够？\"></a>❓ 权限不够？</h3><ul>\n<li>加 <code>sudo</code> 试试</li>\n<li><code>chmod</code> 或 <code>chown</code> 修改权限或所有者</li>\n</ul>\n<h3 id=\"❓-命令执行卡住？\"><a href=\"#❓-命令执行卡住？\" class=\"headerlink\" title=\"❓ 命令执行卡住？\"></a>❓ 命令执行卡住？</h3><ul>\n<li>用 <code>Ctrl + C</code> 中断</li>\n<li>或使用 <code>top</code> &#x2F; <code>kill</code> 终止进程</li>\n</ul>\n<hr>\n<h2 id=\"📘-十、学习资源推荐\"><a href=\"#📘-十、学习资源推荐\" class=\"headerlink\" title=\"📘 十、学习资源推荐\"></a>📘 十、学习资源推荐</h2><ul>\n<li>Linux 命令大全：<a href=\"https://wangdoc.com/linux/\">https://wangdoc.com/linux/</a></li>\n<li>菜鸟教程：<a href=\"https://www.runoob.com/linux/linux-command-manual.html\">https://www.runoob.com/linux/linux-command-manual.html</a></li>\n<li>man 手册：<code>man 命令名</code>（如 <code>man ls</code>）</li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适合 Linux 新手与初级运维，欢迎转发收藏，转载请注明出处 🔁</p>\n</blockquote>\n"},{"title":"🐳 Docker Compose 字段详解篇（一）：服务配置（services）","date":"2025-06-07T02:24:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":7671,"_content":"\n# 🐳 服务配置（services）全面解读 - 写给小白的超详细指南！\n\n你好呀！欢迎来到 Docker Compose 的世界！如果你觉得 `docker-compose.yml` 文件看起来有点复杂，别担心，我们一步一步来拆解它。\n\n这个文件里最重要的部分就是 `services` 了，你可以简单理解它就像一个菜单，列出了你的项目里需要运行的所有“服务”（比如你的网站后端、数据库、缓存等等）。每个服务对应一个容器，而 `services` 下面的每一项，就是告诉你 Docker Compose 怎么去创建和运行这个容器。\n\n今天，我们就来把 `services` 里那些最常用、最能帮你解决问题的字段，用大白话给你讲清楚！\n\n---\n\n## 🧩 1. `image`：直接用现成的“积木”\n\n想象一下，Docker Hub 上有很多已经搭好的“积木”（镜像），比如 Nginx（用来跑网站）、MySQL（数据库）、Redis（缓存）。`image` 字段就是告诉你 Docker Compose，你想用哪块现成的积木来启动你的服务。\n\n```yaml\nservices:\n  # 我要定义一个服务，名字叫 web（名字你可以随便起）\n  web:\n    # 好了，web 这个服务，我要用哪个 Docker 镜像来启动呢？\n    image: nginx:latest  # 我要用 Docker Hub 上的 nginx 镜像，版本是 latest（最新版）\n                          # 比如 image: mysql:5.7 就是用 MySQL 5.7 版本镜像\n```\n\n*   **作用**：超级简单快速地启动一个标准服务，不用你自己从零开始搭。\n*   **适合场景**：\n    *   你想快速跑个数据库、缓存或者一个标准的 Web 服务器（比如 Nginx）。\n    *   你的团队已经帮你打包好了镜像，你只需要拿来用就行。\n\n🧪 **举个栗子：快速启动一个 Redis 缓存服务**\n\n```yaml\nservices:\n  # 定义一个服务叫 redis\n  redis:\n    # 直接用官方的 Redis 镜像，版本指定 7.2\n    image: redis:7.2\n```\n\n---\n\n## 🛠️ 2. `build`：自己动手，“捏”一个专属积木\n\n有时候，现成的积木不满足你的需求，比如你写了自己的网站代码或者应用。这时候，你就需要根据你的代码和配置，自己动手“捏”一个专属的镜像。`build` 字段就是干这个的。它会告诉 Docker Compose 去哪里找到你的“制作图纸”（Dockerfile），然后帮你把镜像做出来。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 myapp\n  myapp:\n    # 我不直接用现成镜像，我要从我的本地代码来“构建”一个专属镜像\n    build:\n      # context: 告诉 Docker 去哪个目录找你的代码和 Dockerfile\n      context: ./app           # 比如，我的应用代码和 Dockerfile 都在当前目录下的 app 文件夹里\n      # dockerfile: 如果你的制作图纸不叫 Dockerfile（默认名字），或者你想用特定的图纸\n      dockerfile: Dockerfile.dev  # 比如，我用了专门给开发环境准备的 Dockerfile.dev 文件\n      # args: 在构建镜像的时候，可以传一些参数进去，影响制作过程\n      args:\n        NODE_ENV: development     # 比如，告诉制作过程现在是开发环境\n```\n\n*   **作用**：根据你的代码和 `Dockerfile`，构建一个包含你应用的定制镜像。\n*   **适合场景**：\n    *   你需要运行你自己开发的应用（Web 应用、API 服务等）。\n    *   你需要为不同的环境（开发、测试、生产）构建不同的镜像。\n\n🚀 **构建流程（Docker Compose 帮你做的）**\n1.  Docker Compose 会找到你指定的 `context` 目录（比如上面的 `./app`）。\n2.  它会在那个目录里找到你指定的 `dockerfile` 文件（比如 `Dockerfile.dev`）。\n3.  如果定义了 `args`，它会把这些参数传给构建过程。\n4.  Docker 会按照 `Dockerfile` 里的步骤，把你的代码、依赖等都打包进一个新的镜像。\n5.  最后，Docker Compose 会用这个刚构建好的镜像来启动你的容器。\n\n---\n\n## 🚪 3. `ports`：给你的容器“开个门”\n\n容器就像一个独立的“小房子”，默认外面是访问不到里面的服务的（比如容器里跑的网站）。`ports` 字段就像在“小房子”和外面的“宿主机”（运行 Docker 的那台电脑或服务器）之间开一道门，让外面的人可以通过宿主机的地址和端口，访问到容器里的服务。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 web\n  web:\n    image: my-web-server\n    # ports: 设置端口映射，把宿主机的端口和容器里的端口连起来\n    ports:\n      # 格式是：\"宿主机端口:容器内部端口\"\n      - \"8080:80\"  # 意思是：访问我宿主机的 8080 端口，实际上就访问到了 web 容器里的 80 端口\n      # 你也可以这样写：\"127.0.0.1:8080:80\" 只让宿主机本地访问 8080\n      # 或者只写容器端口：\"80\" 这样 Docker 会随机给你分配一个宿主机端口\n```\n\n*   **作用**：让外部网络（比如你的浏览器、或者别的电脑）能够访问到 Docker 容器内部运行的服务。\n*   **格式说明**：`宿主机端口:容器端口` 或者 `宿主机IP:宿主机端口:容器端口`。\n*   **适合场景**：\n    *   你需要通过浏览器访问容器里的网站或 Web 应用。\n    *   你需要通过客户端工具连接容器里的数据库（比如 Navicat 连接 MySQL）。\n    *   其他任何需要从外部访问容器内部服务的场景。\n\n🌍 **例子：跑两个服务，分别用不同端口访问**\n\n```yaml\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-vue-app # 假设这是你打包好的 Vue 应用镜像\n    ports:\n      - \"3000:80\"    # 把宿主机的 3000 端口映射到容器前端应用的 80 端口\n\n  # 定义一个后端服务\n  backend:\n    image: my-node-api # 假设这是你打包好的 Node.js API 镜像\n    ports:\n      - \"4000:8080\"  # 把宿主机的 4000 端口映射到容器后端 API 的 8080 端口\n```\n\n这样，你就可以通过 `http://宿主机IP:3000` 访问前端，通过 `http://宿主机IP:4000` 访问后端了。\n\n---\n\n## 💾 4. `volumes`：让容器的数据“活”下来，或者和本地同步\n\n容器在停止或删除后，里面的数据通常就没了。而且开发时，我们希望改了本地代码，容器里的代码也能立刻更新，不用重新构建镜像。`volumes` 就是来解决这两个问题的利器！它可以把宿主机的目录或者一个特殊的“数据卷”挂载到容器里。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 app\n  app:\n    image: my-app-image\n    # volumes: 设置数据卷挂载\n    volumes:\n      # 格式是：\"宿主机路径或命名卷名:容器内部路径\"\n\n      # 第一种：本地路径挂载（也叫绑定挂载 Bind Mount）\n      # 作用：把宿主机当前目录（.）整个挂载到容器里的 /app 目录\n      # 效果：你改动宿主机当前目录的文件，容器 /app 里的文件也跟着变，反之亦然\n      # 适合：本地开发时同步代码，或者共享配置文件\n      - .:/app\n\n      # 第二种：命名卷挂载（Named Volume）\n      # 作用：创建一个由 Docker 专门管理的数据存储区域，名字叫 data-volume\n      #      然后把容器里 /var/lib/mysql 目录的数据都存到这个 data-volume 里\n      # 效果：即使你删除了这个容器，data-volume 里保存的数据还在，下次启动新容器还可以继续用\n      # 适合：保存数据库数据、日志文件等需要长期保留的数据\n      - data-volume:/var/lib/mysql\n\n  # 我要定义一个服务叫 db\n  db:\n    image: mysql:5.7\n    volumes:\n      # 把 db 容器的数据库文件目录挂载到前面定义的 data-volume 命名卷里\n      - data-volume:/var/lib/mysql\n\n# 重要！所有用到的“命名卷”需要在 docker-compose.yml 文件的最顶层单独声明\nvolumes:\n  # 声明一个名字叫 data-volume 的命名卷\n  data-volume:\n    # 你可以在这里加一些配置，但通常直接声明名字就行了\n```\n\n*   **作用**：实现宿主机和容器之间、或者容器和持久化存储区域之间的数据共享和同步。\n*   **类型**：\n    *   **本地路径挂载 (Bind Mount)**：`宿主机目录:/容器目录`。直接把宿主机的一个目录映射到容器里。适合开发时的代码同步、挂载配置文件。\n    *   **命名卷挂载 (Named Volume)**：`命名卷名:/容器目录`。Docker 自己管理的一块存储区域。适合需要持久化保存的数据（数据库、上传文件等）。\n*   **适合场景**：\n    *   开发时需要实时修改代码，容器立即看到效果（热更新）。\n    *   需要保证数据库、缓存等服务的数据在容器重启或删除后不丢失。\n    *   多个服务需要共享同一个配置文件。\n\n---\n\n## 🌱 5. `environment`：给容器“喂”配置信息\n\n很多应用在启动时需要一些配置信息，比如数据库地址、用户名密码、API密钥、运行模式（开发/生产）等等。`environment` 字段就是把这些信息作为“环境变量”传递给容器里的应用。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 api\n  api:\n    image: my-api-image\n    # environment: 设置环境变量列表\n    environment:\n      # 格式： 变量名=值\n      - NODE_ENV=production    # 告诉容器里的 Node.js 应用，当前是生产环境\n      - DB_HOST=db             # 告诉应用数据库的主机名是 'db'（后面会讲到如何在服务间通信）\n      - DB_USER=myuser         # 数据库用户名\n      # 也可以写成对象形式，效果一样：\n      # DB_PASS: mysecretpassword # 数据库密码\n```\n\n*   **作用**：把配置参数、密钥、运行模式等信息传递给容器里运行的应用。\n*   **适合场景**：\n    *   配置应用的数据库连接信息。\n    *   设置 API 密钥或 Token。\n    *   切换应用的运行模式（如 debug 开关）。\n    *   任何需要外部配置的应用。\n\n---\n\n## 📄 6. `env_file`：批量加载环境变量\n\n如果你的环境变量特别多，或者包含一些敏感信息（虽然不推荐直接写在 yml 里，但有时开发方便），把它们都写在 `environment` 字段里会显得很乱。`env_file` 字段可以让你把环境变量统一写在一个或多个文件里（通常命名为 `.env`），然后让 Docker Compose 一次性加载进来。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 web\n  web:\n    image: my-web-app\n    # env_file: 指定要加载的环境变量文件\n    env_file:\n      - .env  # 加载当前目录下的 .env 文件\n      # 也可以加载多个文件：\n      # - ./config/common.env\n      # - ./config/secret.env\n```\n\n*   **作用**：从指定的文件中读取环境变量，并设置到容器里。\n*   **适合场景**：\n    *   项目有很多环境变量，方便集中管理。\n    *   不想把敏感信息（如密码）直接暴露在 `docker-compose.yml` 文件中（虽然 `.env` 文件本身也需要保护）。\n\n📌 **`.env` 文件长啥样？**\n\n它就是个普通文本文件，每行一个 `变量名=值`，像这样：\n\n```env\n# 这是一个 .env 文件示例\n\n# 数据库配置\nDB_USER=root\nDB_PASS=supersecretpassword123\nDB_NAME=myapp\n\n# 应用配置\nAPI_KEY=abcdef123456\nDEBUG_MODE=true\n```\n\n---\n\n## 🎯 7. `command` 与 `entrypoint`：控制容器启动后执行什么\n\n一个镜像在制作时，通常会指定容器启动后默认执行什么命令（比如启动一个 Web 服务器或者运行一个脚本）。`command` 和 `entrypoint` 字段可以让你覆盖镜像里预设的启动命令。\n\n*   **`command`**：主要用来指定容器启动后要执行的“主要”命令，它会替换 Dockerfile 里的 `CMD`。如果镜像里设置了 `ENTRYPOINT`，那么 `command` 里的内容会作为参数传给 `ENTRYPOINT`。\n*   **`entrypoint`**：设置容器启动时第一个执行的程序或脚本。它会替换 Dockerfile 里的 `ENTRYPOINT` 指令。通常用于做一些初始化工作（比如权限设置、等待依赖服务等），然后再执行 `command` 或镜像默认的 `CMD`。\n\n```yaml\nservices:\n  # 定义一个服务叫 api\n  api:\n    image: my-api-image\n    # command: 覆盖镜像默认的 CMD\n    # 比如，镜像默认是只启动服务，但我想带一些参数启动\n    command: [\"npm\", \"run\", \"start:dev\"]  # 告诉容器执行 npm run start:dev 命令来启动服务\n\n  # 定义一个服务叫 worker\n  worker:\n    image: my-worker-image\n    # entrypoint: 覆盖镜像默认的 ENTRYPOINT\n    # 比如，镜像里有个 /init.sh 脚本用来做启动前的检查和设置\n    entrypoint: [\"/init.sh\"]              # 容器启动时先执行 /init.sh 脚本\n    # command: [\"--process\", \"queue1\"]    # 如果有 command，它会作为参数传给 entrypoint\n                                        # 相当于执行： /init.sh --process queue1\n```\n\n*   **适合场景**：\n    *   你的应用需要特定的启动参数。\n    *   容器启动前需要执行一些初始化脚本（比如数据库迁移、权限设置）。\n    *   你想改变镜像默认的启动行为。\n\n**简单理解**：`ENTRYPOINT` 就像是你程序的入口或者启动器，`CMD` (或 `command`) 是传给这个启动器的参数，或者如果没启动器，就是直接执行的命令。\n\n---\n\n## 🔁 8. `restart`：让你的服务“摔倒了自己爬起来”\n\n你的容器可能会因为各种原因意外停止，比如程序崩溃、内存不足等。`restart` 字段可以设置一个策略，让 Docker Compose 在容器停止后自动尝试重启它，提高服务的可用性。\n\n```yaml\nservices:\n  # 定义一个服务叫 frontend\n  frontend:\n    image: my-frontend-image\n    # restart: 设置容器的重启策略\n    restart: always # 意思是：无论容器是正常退出还是异常退出，Docker Compose 都会尝试重启它\n\n    # 还有其他选项：\n    # restart: no         # 默认值，容器停止后不会自动重启\n    # restart: on-failure # 容器以非零状态码退出时（表示出错）才重启\n    # restart: unless-stopped # 除非你手动用 docker stop 命令停掉它，否则一直重启\n```\n\n*   **作用**：配置容器在停止后是否自动重启，以及在什么情况下重启。\n*   **选项说明**：\n    *   `no`：不自动重启（默认）。\n    *   `on-failure`：只有容器因非零状态码退出时才重启（表示发生错误）。\n    *   `always`：无论容器如何退出，总是重启它（除非 Docker Daemon 重启，它也会跟着重启）。\n    *   `unless-stopped`：除非用户或系统手动停止容器，否则总是重启。这是生产环境常用选项。\n*   **适合场景**：\n    *   后台服务容易因为各种原因崩溃，需要自动恢复。\n    *   保障服务的持续运行和高可用性。\n\n---\n\n## 🧠 9. `depends_on`：告诉 Docker Compose 启动顺序\n\n你的应用服务可能依赖于其他服务，比如你的 Web 后端需要先连接上数据库才能正常工作。`depends_on` 字段可以告诉 Docker Compose 在启动一个服务之前，先启动它依赖的其他服务。\n\n```yaml\nservices:\n  # 定义一个服务叫 web （比如你的后端 API）\n  web:\n    image: my-backend-api\n    # depends_on: 这个服务依赖于其他服务\n    depends_on:\n      # 告诉 Docker Compose：在启动 web 服务之前，先启动名字叫 db 的服务\n      - db\n\n  # 定义一个服务叫 db （比如你的数据库）\n  db:\n    image: mysql:5.7\n    # db 没有 depends_on，它会先启动\n\n# 注意一个非常重要的地方！ depends_on 默认只保证依赖的服务“启动”了\n# 它不保证依赖的服务已经“就绪”（比如数据库服务启动了，但可能还没完全初始化好，还没开始监听连接）\n# 如果你的服务启动需要等待依赖的服务完全就绪，最好结合后面的 healthcheck 一起使用\n```\n\n*   **作用**：定义服务之间的启动依赖关系，确保被依赖的服务先启动。\n*   **注意**：**默认情况下，`depends_on` 只等待依赖的容器“启动”成功，不等待它里面的应用完全“就绪”并可以接收请求。**\n*   **推荐做法**：在需要等待依赖服务“就绪”时，结合 `healthcheck` 和更高级的 `depends_on.condition` (比如 `condition: service_healthy`) 来使用。\n\n---\n\n## ❤️ 10. `healthcheck`：检查你的服务是否“活”得健康\n\n容器启动了，不代表里面的服务就真的正常工作了。比如一个 Web 服务可能启动了，但内部出错了，并不能响应请求。`healthcheck` 字段就是用来定义如何检查服务是否“健康”的，Docker Compose 会周期性地执行这个检查。\n\n```yaml\nservices:\n  # 定义一个服务叫 api\n  api:\n    image: my-api-image\n    # healthcheck: 配置容器的健康检查\n    healthcheck:\n      # test: 定义健康检查命令。如果命令返回 0，表示健康；非 0 表示不健康\n      # 这里用 curl 命令访问容器内部的 /health 接口，-f 参数表示如果 HTTP 状态码不是 2xx/3xx 就认为失败\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      # 你也可以用 CMD-SHELL 形式： test: [\"CMD-SHELL\", \"pg_isready -U myuser -d mydatabase\"] # 检查 PostgreSQL 数据库是否准备好\n\n      # interval: 多久执行一次健康检查\n      interval: 30s      # 每 30 秒检查一次\n\n      # timeout: 每次健康检查的超时时间，如果命令执行超过这个时间还没结束，就认为失败\n      timeout: 10s       # 每次检查最多等 10 秒\n\n      # retries: 连续失败多少次后，把容器状态标记为 'unhealthy'\n      retries: 3         # 连续失败 3 次就认为不健康\n\n      # start_period: 给容器一个启动缓冲时间，在这段时间内的健康检查失败不会计入 retries\n      # start_period: 60s # 容器启动后 60 秒内，健康检查失败暂时忽略\n```\n\n*   **作用**：自动检测容器内运行的服务是否正常响应，而不仅仅是容器进程是否活着。\n*   **适合场景**：\n    *   确保服务在后台运行，并且确实在提供服务（没有假死）。\n    *   需要精确判断一个服务是否“就绪”来启动依赖它的服务（结合 `depends_on.condition: service_healthy`）。\n\n---\n\n## 🌐 11. `networks`：让你的服务们“说上话”\n\n默认情况下，Docker Compose 会为你的项目创建一个网络，并把所有服务都放到这个网络里，这样它们就可以通过服务名互相访问了（比如 `api` 服务可以通过主机名 `db` 访问到数据库服务）。`networks` 字段可以让你把服务加入到特定的网络，或者定义自己的网络。\n\n```yaml\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-frontend\n    # networks: 把这个服务加入到哪些网络中\n    networks:\n      - frontend_net # 加入到名字叫 frontend_net 的网络\n      - backend_net  # 也加入到名字叫 backend_net 的网络（如果需要直接访问后端）\n\n  # 定义一个后端服务\n  backend:\n    image: my-backend\n    networks:\n      - backend_net # 加入到名字叫 backend_net 的网络\n\n  # 定义一个数据库服务\n  db:\n    image: mysql:5.7\n    networks:\n      - backend_net # 加入到名字叫 backend_net 的网络\n\n# 重要！所有用到的“自定义网络”需要在 docker-compose.yml 文件的最顶层单独声明\nnetworks:\n  frontend_net: # 声明一个叫 frontend_net 的网络\n  backend_net:  # 声明一个叫 backend_net 的网络\n    # driver: bridge 是默认的网络类型，通常不用写\n```\n\n*   **作用**：管理服务之间的网络连接，让服务可以通过服务名互相通信。\n*   **适合场景**：\n    *   你的应用包含多个服务（如前端、后端、数据库、缓存），它们需要互相访问。\n    *   需要隔离不同的应用或服务组，让他们只能在各自的网络里通信。\n\n---\n\n## 📘 推荐组合模板：一个典型的 Node.js 应用架构\n\n把上面讲的常用字段组合起来，一个常见的 Web 应用（比如 Node.js 后端 + MySQL 数据库）的 `docker-compose.yml` 可能会长这样：\n\n```yaml\n# 指定 Docker Compose 文件格式的版本\nversion: '3.8' # 推荐使用较新的版本\n\n# services: 定义我们项目要运行的所有服务\nservices:\n  # 定义第一个服务：应用后端（比如一个 Node.js API）\n  app:\n    # build: 从本地代码构建镜像\n    build:\n      context: . # 构建上下文是当前目录\n      dockerfile: Dockerfile # 使用当前目录下的 Dockerfile 文件\n    # image: 你也可以在这里指定构建后的镜像名字，方便管理\n    image: my-nodejs-app:latest\n\n    # ports: 端口映射，让外部能访问到容器内的应用\n    ports:\n      # 把宿主机的 80 端口映射到容器里应用监听的 3000 端口\n      - \"80:3000\"\n\n    # volumes: 数据卷挂载，用于代码同步和数据持久化\n    volumes:\n      # 把宿主机当前目录的代码，同步到容器里的 /app 目录\n      # 方便开发时改代码容器里立即生效\n      - .:/app\n      # 也可以挂载其他需要的目录，比如日志目录\n      # - app-logs:/app/logs\n\n    # environment: 设置容器内部的环境变量\n    environment:\n      - NODE_ENV=production    # 设置运行环境为生产模式\n      - DB_HOST=db             # 告诉应用数据库的主机名是另一个服务 'db'\n      - DB_USER=${DB_USER}     # 从宿主机的环境变量或 .env 文件读取数据库用户名\n      - DB_PASS=${DB_PASSWORD} # 从宿主机的环境变量或 .env 文件读取数据库密码\n      # 如果使用 env_file 更方便管理大量变量\n      # env_file: .env\n\n    # depends_on: 设置服务启动依赖\n    depends_on:\n      # 告诉 Docker Compose，启动 app 服务之前，先启动 db 服务\n      # 注意：默认只等待 db 容器启动，不保证 db 服务完全就绪\n      - db\n      # 如果需要等待 db 健康，可以这样写（需要 db 服务配置 healthcheck）：\n      # db:\n      #   condition: service_healthy\n\n    # restart: 重启策略，保障服务稳定性\n    restart: unless-stopped # 除非手动停止，否则容器异常退出就自动重启\n\n    # networks: 把服务加入到同一个网络，让他们能互相通信\n    networks:\n      - backend_network # 加入到叫 backend_network 的网络\n\n    # healthcheck: 健康检查（推荐加上，确保服务真的在工作）\n    # healthcheck:\n    #   test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/healthz\"]\n    #   interval: 1m\n    #   timeout: 10s\n    #   retries: 3\n\n\n  # 定义第二个服务：数据库服务（比如 MySQL）\n  db:\n    image: mysql:5.7 # 使用 MySQL 5.7 镜像\n\n    # volumes: 数据卷挂载，持久化数据库数据\n    volumes:\n      # 把 db-data 命名卷挂载到容器里 MySQL 存储数据的目录\n      # 这样数据库数据就不会丢失\n      - db-data:/var/lib/mysql\n\n    # environment: 设置数据库的环境变量（比如 root 密码，很重要！）\n    environment:\n      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD} # 从环境变量或 .env 读取 root 密码\n      - MYSQL_DATABASE=${DB_NAME} # 自动创建的数据库名\n\n    # restart: 重启策略\n    restart: unless-stopped\n\n    # networks: 加入到同一个网络\n    networks:\n      - backend_network # 和 app 服务在同一个网络，app 就可以通过主机名 'db' 访问它\n\n    # healthcheck: 数据库的健康检查（也很重要！）\n    # healthcheck:\n    #   test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-p${MYSQL_ROOT_PASSWORD}\"]\n    #   interval: 10s\n    #   timeout: 5s\n    #   retries: 5\n\n\n# volumes: 在顶层声明命名卷，让 Docker 管理数据存储\nvolumes:\n  db-data: # 声明一个叫 db-data 的命名卷\n  # app-logs: # 如果上面 volumes 也用了 app-logs，这里也要声明\n\n# networks: 在顶层声明自定义网络\nnetworks:\n  backend_network: # 声明一个叫 backend_network 的网络\n    # driver: bridge 是默认类型，通常不用写\n```","source":"_posts/Docker/Docker Compose 字段详解篇（一）：服务配置（services）.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 字段详解篇（一）：服务配置（services）\"\ndate: '2025-06-07 10:24'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 7671\n---\n\n# 🐳 服务配置（services）全面解读 - 写给小白的超详细指南！\n\n你好呀！欢迎来到 Docker Compose 的世界！如果你觉得 `docker-compose.yml` 文件看起来有点复杂，别担心，我们一步一步来拆解它。\n\n这个文件里最重要的部分就是 `services` 了，你可以简单理解它就像一个菜单，列出了你的项目里需要运行的所有“服务”（比如你的网站后端、数据库、缓存等等）。每个服务对应一个容器，而 `services` 下面的每一项，就是告诉你 Docker Compose 怎么去创建和运行这个容器。\n\n今天，我们就来把 `services` 里那些最常用、最能帮你解决问题的字段，用大白话给你讲清楚！\n\n---\n\n## 🧩 1. `image`：直接用现成的“积木”\n\n想象一下，Docker Hub 上有很多已经搭好的“积木”（镜像），比如 Nginx（用来跑网站）、MySQL（数据库）、Redis（缓存）。`image` 字段就是告诉你 Docker Compose，你想用哪块现成的积木来启动你的服务。\n\n```yaml\nservices:\n  # 我要定义一个服务，名字叫 web（名字你可以随便起）\n  web:\n    # 好了，web 这个服务，我要用哪个 Docker 镜像来启动呢？\n    image: nginx:latest  # 我要用 Docker Hub 上的 nginx 镜像，版本是 latest（最新版）\n                          # 比如 image: mysql:5.7 就是用 MySQL 5.7 版本镜像\n```\n\n*   **作用**：超级简单快速地启动一个标准服务，不用你自己从零开始搭。\n*   **适合场景**：\n    *   你想快速跑个数据库、缓存或者一个标准的 Web 服务器（比如 Nginx）。\n    *   你的团队已经帮你打包好了镜像，你只需要拿来用就行。\n\n🧪 **举个栗子：快速启动一个 Redis 缓存服务**\n\n```yaml\nservices:\n  # 定义一个服务叫 redis\n  redis:\n    # 直接用官方的 Redis 镜像，版本指定 7.2\n    image: redis:7.2\n```\n\n---\n\n## 🛠️ 2. `build`：自己动手，“捏”一个专属积木\n\n有时候，现成的积木不满足你的需求，比如你写了自己的网站代码或者应用。这时候，你就需要根据你的代码和配置，自己动手“捏”一个专属的镜像。`build` 字段就是干这个的。它会告诉 Docker Compose 去哪里找到你的“制作图纸”（Dockerfile），然后帮你把镜像做出来。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 myapp\n  myapp:\n    # 我不直接用现成镜像，我要从我的本地代码来“构建”一个专属镜像\n    build:\n      # context: 告诉 Docker 去哪个目录找你的代码和 Dockerfile\n      context: ./app           # 比如，我的应用代码和 Dockerfile 都在当前目录下的 app 文件夹里\n      # dockerfile: 如果你的制作图纸不叫 Dockerfile（默认名字），或者你想用特定的图纸\n      dockerfile: Dockerfile.dev  # 比如，我用了专门给开发环境准备的 Dockerfile.dev 文件\n      # args: 在构建镜像的时候，可以传一些参数进去，影响制作过程\n      args:\n        NODE_ENV: development     # 比如，告诉制作过程现在是开发环境\n```\n\n*   **作用**：根据你的代码和 `Dockerfile`，构建一个包含你应用的定制镜像。\n*   **适合场景**：\n    *   你需要运行你自己开发的应用（Web 应用、API 服务等）。\n    *   你需要为不同的环境（开发、测试、生产）构建不同的镜像。\n\n🚀 **构建流程（Docker Compose 帮你做的）**\n1.  Docker Compose 会找到你指定的 `context` 目录（比如上面的 `./app`）。\n2.  它会在那个目录里找到你指定的 `dockerfile` 文件（比如 `Dockerfile.dev`）。\n3.  如果定义了 `args`，它会把这些参数传给构建过程。\n4.  Docker 会按照 `Dockerfile` 里的步骤，把你的代码、依赖等都打包进一个新的镜像。\n5.  最后，Docker Compose 会用这个刚构建好的镜像来启动你的容器。\n\n---\n\n## 🚪 3. `ports`：给你的容器“开个门”\n\n容器就像一个独立的“小房子”，默认外面是访问不到里面的服务的（比如容器里跑的网站）。`ports` 字段就像在“小房子”和外面的“宿主机”（运行 Docker 的那台电脑或服务器）之间开一道门，让外面的人可以通过宿主机的地址和端口，访问到容器里的服务。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 web\n  web:\n    image: my-web-server\n    # ports: 设置端口映射，把宿主机的端口和容器里的端口连起来\n    ports:\n      # 格式是：\"宿主机端口:容器内部端口\"\n      - \"8080:80\"  # 意思是：访问我宿主机的 8080 端口，实际上就访问到了 web 容器里的 80 端口\n      # 你也可以这样写：\"127.0.0.1:8080:80\" 只让宿主机本地访问 8080\n      # 或者只写容器端口：\"80\" 这样 Docker 会随机给你分配一个宿主机端口\n```\n\n*   **作用**：让外部网络（比如你的浏览器、或者别的电脑）能够访问到 Docker 容器内部运行的服务。\n*   **格式说明**：`宿主机端口:容器端口` 或者 `宿主机IP:宿主机端口:容器端口`。\n*   **适合场景**：\n    *   你需要通过浏览器访问容器里的网站或 Web 应用。\n    *   你需要通过客户端工具连接容器里的数据库（比如 Navicat 连接 MySQL）。\n    *   其他任何需要从外部访问容器内部服务的场景。\n\n🌍 **例子：跑两个服务，分别用不同端口访问**\n\n```yaml\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-vue-app # 假设这是你打包好的 Vue 应用镜像\n    ports:\n      - \"3000:80\"    # 把宿主机的 3000 端口映射到容器前端应用的 80 端口\n\n  # 定义一个后端服务\n  backend:\n    image: my-node-api # 假设这是你打包好的 Node.js API 镜像\n    ports:\n      - \"4000:8080\"  # 把宿主机的 4000 端口映射到容器后端 API 的 8080 端口\n```\n\n这样，你就可以通过 `http://宿主机IP:3000` 访问前端，通过 `http://宿主机IP:4000` 访问后端了。\n\n---\n\n## 💾 4. `volumes`：让容器的数据“活”下来，或者和本地同步\n\n容器在停止或删除后，里面的数据通常就没了。而且开发时，我们希望改了本地代码，容器里的代码也能立刻更新，不用重新构建镜像。`volumes` 就是来解决这两个问题的利器！它可以把宿主机的目录或者一个特殊的“数据卷”挂载到容器里。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 app\n  app:\n    image: my-app-image\n    # volumes: 设置数据卷挂载\n    volumes:\n      # 格式是：\"宿主机路径或命名卷名:容器内部路径\"\n\n      # 第一种：本地路径挂载（也叫绑定挂载 Bind Mount）\n      # 作用：把宿主机当前目录（.）整个挂载到容器里的 /app 目录\n      # 效果：你改动宿主机当前目录的文件，容器 /app 里的文件也跟着变，反之亦然\n      # 适合：本地开发时同步代码，或者共享配置文件\n      - .:/app\n\n      # 第二种：命名卷挂载（Named Volume）\n      # 作用：创建一个由 Docker 专门管理的数据存储区域，名字叫 data-volume\n      #      然后把容器里 /var/lib/mysql 目录的数据都存到这个 data-volume 里\n      # 效果：即使你删除了这个容器，data-volume 里保存的数据还在，下次启动新容器还可以继续用\n      # 适合：保存数据库数据、日志文件等需要长期保留的数据\n      - data-volume:/var/lib/mysql\n\n  # 我要定义一个服务叫 db\n  db:\n    image: mysql:5.7\n    volumes:\n      # 把 db 容器的数据库文件目录挂载到前面定义的 data-volume 命名卷里\n      - data-volume:/var/lib/mysql\n\n# 重要！所有用到的“命名卷”需要在 docker-compose.yml 文件的最顶层单独声明\nvolumes:\n  # 声明一个名字叫 data-volume 的命名卷\n  data-volume:\n    # 你可以在这里加一些配置，但通常直接声明名字就行了\n```\n\n*   **作用**：实现宿主机和容器之间、或者容器和持久化存储区域之间的数据共享和同步。\n*   **类型**：\n    *   **本地路径挂载 (Bind Mount)**：`宿主机目录:/容器目录`。直接把宿主机的一个目录映射到容器里。适合开发时的代码同步、挂载配置文件。\n    *   **命名卷挂载 (Named Volume)**：`命名卷名:/容器目录`。Docker 自己管理的一块存储区域。适合需要持久化保存的数据（数据库、上传文件等）。\n*   **适合场景**：\n    *   开发时需要实时修改代码，容器立即看到效果（热更新）。\n    *   需要保证数据库、缓存等服务的数据在容器重启或删除后不丢失。\n    *   多个服务需要共享同一个配置文件。\n\n---\n\n## 🌱 5. `environment`：给容器“喂”配置信息\n\n很多应用在启动时需要一些配置信息，比如数据库地址、用户名密码、API密钥、运行模式（开发/生产）等等。`environment` 字段就是把这些信息作为“环境变量”传递给容器里的应用。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 api\n  api:\n    image: my-api-image\n    # environment: 设置环境变量列表\n    environment:\n      # 格式： 变量名=值\n      - NODE_ENV=production    # 告诉容器里的 Node.js 应用，当前是生产环境\n      - DB_HOST=db             # 告诉应用数据库的主机名是 'db'（后面会讲到如何在服务间通信）\n      - DB_USER=myuser         # 数据库用户名\n      # 也可以写成对象形式，效果一样：\n      # DB_PASS: mysecretpassword # 数据库密码\n```\n\n*   **作用**：把配置参数、密钥、运行模式等信息传递给容器里运行的应用。\n*   **适合场景**：\n    *   配置应用的数据库连接信息。\n    *   设置 API 密钥或 Token。\n    *   切换应用的运行模式（如 debug 开关）。\n    *   任何需要外部配置的应用。\n\n---\n\n## 📄 6. `env_file`：批量加载环境变量\n\n如果你的环境变量特别多，或者包含一些敏感信息（虽然不推荐直接写在 yml 里，但有时开发方便），把它们都写在 `environment` 字段里会显得很乱。`env_file` 字段可以让你把环境变量统一写在一个或多个文件里（通常命名为 `.env`），然后让 Docker Compose 一次性加载进来。\n\n```yaml\nservices:\n  # 我要定义一个服务叫 web\n  web:\n    image: my-web-app\n    # env_file: 指定要加载的环境变量文件\n    env_file:\n      - .env  # 加载当前目录下的 .env 文件\n      # 也可以加载多个文件：\n      # - ./config/common.env\n      # - ./config/secret.env\n```\n\n*   **作用**：从指定的文件中读取环境变量，并设置到容器里。\n*   **适合场景**：\n    *   项目有很多环境变量，方便集中管理。\n    *   不想把敏感信息（如密码）直接暴露在 `docker-compose.yml` 文件中（虽然 `.env` 文件本身也需要保护）。\n\n📌 **`.env` 文件长啥样？**\n\n它就是个普通文本文件，每行一个 `变量名=值`，像这样：\n\n```env\n# 这是一个 .env 文件示例\n\n# 数据库配置\nDB_USER=root\nDB_PASS=supersecretpassword123\nDB_NAME=myapp\n\n# 应用配置\nAPI_KEY=abcdef123456\nDEBUG_MODE=true\n```\n\n---\n\n## 🎯 7. `command` 与 `entrypoint`：控制容器启动后执行什么\n\n一个镜像在制作时，通常会指定容器启动后默认执行什么命令（比如启动一个 Web 服务器或者运行一个脚本）。`command` 和 `entrypoint` 字段可以让你覆盖镜像里预设的启动命令。\n\n*   **`command`**：主要用来指定容器启动后要执行的“主要”命令，它会替换 Dockerfile 里的 `CMD`。如果镜像里设置了 `ENTRYPOINT`，那么 `command` 里的内容会作为参数传给 `ENTRYPOINT`。\n*   **`entrypoint`**：设置容器启动时第一个执行的程序或脚本。它会替换 Dockerfile 里的 `ENTRYPOINT` 指令。通常用于做一些初始化工作（比如权限设置、等待依赖服务等），然后再执行 `command` 或镜像默认的 `CMD`。\n\n```yaml\nservices:\n  # 定义一个服务叫 api\n  api:\n    image: my-api-image\n    # command: 覆盖镜像默认的 CMD\n    # 比如，镜像默认是只启动服务，但我想带一些参数启动\n    command: [\"npm\", \"run\", \"start:dev\"]  # 告诉容器执行 npm run start:dev 命令来启动服务\n\n  # 定义一个服务叫 worker\n  worker:\n    image: my-worker-image\n    # entrypoint: 覆盖镜像默认的 ENTRYPOINT\n    # 比如，镜像里有个 /init.sh 脚本用来做启动前的检查和设置\n    entrypoint: [\"/init.sh\"]              # 容器启动时先执行 /init.sh 脚本\n    # command: [\"--process\", \"queue1\"]    # 如果有 command，它会作为参数传给 entrypoint\n                                        # 相当于执行： /init.sh --process queue1\n```\n\n*   **适合场景**：\n    *   你的应用需要特定的启动参数。\n    *   容器启动前需要执行一些初始化脚本（比如数据库迁移、权限设置）。\n    *   你想改变镜像默认的启动行为。\n\n**简单理解**：`ENTRYPOINT` 就像是你程序的入口或者启动器，`CMD` (或 `command`) 是传给这个启动器的参数，或者如果没启动器，就是直接执行的命令。\n\n---\n\n## 🔁 8. `restart`：让你的服务“摔倒了自己爬起来”\n\n你的容器可能会因为各种原因意外停止，比如程序崩溃、内存不足等。`restart` 字段可以设置一个策略，让 Docker Compose 在容器停止后自动尝试重启它，提高服务的可用性。\n\n```yaml\nservices:\n  # 定义一个服务叫 frontend\n  frontend:\n    image: my-frontend-image\n    # restart: 设置容器的重启策略\n    restart: always # 意思是：无论容器是正常退出还是异常退出，Docker Compose 都会尝试重启它\n\n    # 还有其他选项：\n    # restart: no         # 默认值，容器停止后不会自动重启\n    # restart: on-failure # 容器以非零状态码退出时（表示出错）才重启\n    # restart: unless-stopped # 除非你手动用 docker stop 命令停掉它，否则一直重启\n```\n\n*   **作用**：配置容器在停止后是否自动重启，以及在什么情况下重启。\n*   **选项说明**：\n    *   `no`：不自动重启（默认）。\n    *   `on-failure`：只有容器因非零状态码退出时才重启（表示发生错误）。\n    *   `always`：无论容器如何退出，总是重启它（除非 Docker Daemon 重启，它也会跟着重启）。\n    *   `unless-stopped`：除非用户或系统手动停止容器，否则总是重启。这是生产环境常用选项。\n*   **适合场景**：\n    *   后台服务容易因为各种原因崩溃，需要自动恢复。\n    *   保障服务的持续运行和高可用性。\n\n---\n\n## 🧠 9. `depends_on`：告诉 Docker Compose 启动顺序\n\n你的应用服务可能依赖于其他服务，比如你的 Web 后端需要先连接上数据库才能正常工作。`depends_on` 字段可以告诉 Docker Compose 在启动一个服务之前，先启动它依赖的其他服务。\n\n```yaml\nservices:\n  # 定义一个服务叫 web （比如你的后端 API）\n  web:\n    image: my-backend-api\n    # depends_on: 这个服务依赖于其他服务\n    depends_on:\n      # 告诉 Docker Compose：在启动 web 服务之前，先启动名字叫 db 的服务\n      - db\n\n  # 定义一个服务叫 db （比如你的数据库）\n  db:\n    image: mysql:5.7\n    # db 没有 depends_on，它会先启动\n\n# 注意一个非常重要的地方！ depends_on 默认只保证依赖的服务“启动”了\n# 它不保证依赖的服务已经“就绪”（比如数据库服务启动了，但可能还没完全初始化好，还没开始监听连接）\n# 如果你的服务启动需要等待依赖的服务完全就绪，最好结合后面的 healthcheck 一起使用\n```\n\n*   **作用**：定义服务之间的启动依赖关系，确保被依赖的服务先启动。\n*   **注意**：**默认情况下，`depends_on` 只等待依赖的容器“启动”成功，不等待它里面的应用完全“就绪”并可以接收请求。**\n*   **推荐做法**：在需要等待依赖服务“就绪”时，结合 `healthcheck` 和更高级的 `depends_on.condition` (比如 `condition: service_healthy`) 来使用。\n\n---\n\n## ❤️ 10. `healthcheck`：检查你的服务是否“活”得健康\n\n容器启动了，不代表里面的服务就真的正常工作了。比如一个 Web 服务可能启动了，但内部出错了，并不能响应请求。`healthcheck` 字段就是用来定义如何检查服务是否“健康”的，Docker Compose 会周期性地执行这个检查。\n\n```yaml\nservices:\n  # 定义一个服务叫 api\n  api:\n    image: my-api-image\n    # healthcheck: 配置容器的健康检查\n    healthcheck:\n      # test: 定义健康检查命令。如果命令返回 0，表示健康；非 0 表示不健康\n      # 这里用 curl 命令访问容器内部的 /health 接口，-f 参数表示如果 HTTP 状态码不是 2xx/3xx 就认为失败\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      # 你也可以用 CMD-SHELL 形式： test: [\"CMD-SHELL\", \"pg_isready -U myuser -d mydatabase\"] # 检查 PostgreSQL 数据库是否准备好\n\n      # interval: 多久执行一次健康检查\n      interval: 30s      # 每 30 秒检查一次\n\n      # timeout: 每次健康检查的超时时间，如果命令执行超过这个时间还没结束，就认为失败\n      timeout: 10s       # 每次检查最多等 10 秒\n\n      # retries: 连续失败多少次后，把容器状态标记为 'unhealthy'\n      retries: 3         # 连续失败 3 次就认为不健康\n\n      # start_period: 给容器一个启动缓冲时间，在这段时间内的健康检查失败不会计入 retries\n      # start_period: 60s # 容器启动后 60 秒内，健康检查失败暂时忽略\n```\n\n*   **作用**：自动检测容器内运行的服务是否正常响应，而不仅仅是容器进程是否活着。\n*   **适合场景**：\n    *   确保服务在后台运行，并且确实在提供服务（没有假死）。\n    *   需要精确判断一个服务是否“就绪”来启动依赖它的服务（结合 `depends_on.condition: service_healthy`）。\n\n---\n\n## 🌐 11. `networks`：让你的服务们“说上话”\n\n默认情况下，Docker Compose 会为你的项目创建一个网络，并把所有服务都放到这个网络里，这样它们就可以通过服务名互相访问了（比如 `api` 服务可以通过主机名 `db` 访问到数据库服务）。`networks` 字段可以让你把服务加入到特定的网络，或者定义自己的网络。\n\n```yaml\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-frontend\n    # networks: 把这个服务加入到哪些网络中\n    networks:\n      - frontend_net # 加入到名字叫 frontend_net 的网络\n      - backend_net  # 也加入到名字叫 backend_net 的网络（如果需要直接访问后端）\n\n  # 定义一个后端服务\n  backend:\n    image: my-backend\n    networks:\n      - backend_net # 加入到名字叫 backend_net 的网络\n\n  # 定义一个数据库服务\n  db:\n    image: mysql:5.7\n    networks:\n      - backend_net # 加入到名字叫 backend_net 的网络\n\n# 重要！所有用到的“自定义网络”需要在 docker-compose.yml 文件的最顶层单独声明\nnetworks:\n  frontend_net: # 声明一个叫 frontend_net 的网络\n  backend_net:  # 声明一个叫 backend_net 的网络\n    # driver: bridge 是默认的网络类型，通常不用写\n```\n\n*   **作用**：管理服务之间的网络连接，让服务可以通过服务名互相通信。\n*   **适合场景**：\n    *   你的应用包含多个服务（如前端、后端、数据库、缓存），它们需要互相访问。\n    *   需要隔离不同的应用或服务组，让他们只能在各自的网络里通信。\n\n---\n\n## 📘 推荐组合模板：一个典型的 Node.js 应用架构\n\n把上面讲的常用字段组合起来，一个常见的 Web 应用（比如 Node.js 后端 + MySQL 数据库）的 `docker-compose.yml` 可能会长这样：\n\n```yaml\n# 指定 Docker Compose 文件格式的版本\nversion: '3.8' # 推荐使用较新的版本\n\n# services: 定义我们项目要运行的所有服务\nservices:\n  # 定义第一个服务：应用后端（比如一个 Node.js API）\n  app:\n    # build: 从本地代码构建镜像\n    build:\n      context: . # 构建上下文是当前目录\n      dockerfile: Dockerfile # 使用当前目录下的 Dockerfile 文件\n    # image: 你也可以在这里指定构建后的镜像名字，方便管理\n    image: my-nodejs-app:latest\n\n    # ports: 端口映射，让外部能访问到容器内的应用\n    ports:\n      # 把宿主机的 80 端口映射到容器里应用监听的 3000 端口\n      - \"80:3000\"\n\n    # volumes: 数据卷挂载，用于代码同步和数据持久化\n    volumes:\n      # 把宿主机当前目录的代码，同步到容器里的 /app 目录\n      # 方便开发时改代码容器里立即生效\n      - .:/app\n      # 也可以挂载其他需要的目录，比如日志目录\n      # - app-logs:/app/logs\n\n    # environment: 设置容器内部的环境变量\n    environment:\n      - NODE_ENV=production    # 设置运行环境为生产模式\n      - DB_HOST=db             # 告诉应用数据库的主机名是另一个服务 'db'\n      - DB_USER=${DB_USER}     # 从宿主机的环境变量或 .env 文件读取数据库用户名\n      - DB_PASS=${DB_PASSWORD} # 从宿主机的环境变量或 .env 文件读取数据库密码\n      # 如果使用 env_file 更方便管理大量变量\n      # env_file: .env\n\n    # depends_on: 设置服务启动依赖\n    depends_on:\n      # 告诉 Docker Compose，启动 app 服务之前，先启动 db 服务\n      # 注意：默认只等待 db 容器启动，不保证 db 服务完全就绪\n      - db\n      # 如果需要等待 db 健康，可以这样写（需要 db 服务配置 healthcheck）：\n      # db:\n      #   condition: service_healthy\n\n    # restart: 重启策略，保障服务稳定性\n    restart: unless-stopped # 除非手动停止，否则容器异常退出就自动重启\n\n    # networks: 把服务加入到同一个网络，让他们能互相通信\n    networks:\n      - backend_network # 加入到叫 backend_network 的网络\n\n    # healthcheck: 健康检查（推荐加上，确保服务真的在工作）\n    # healthcheck:\n    #   test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/healthz\"]\n    #   interval: 1m\n    #   timeout: 10s\n    #   retries: 3\n\n\n  # 定义第二个服务：数据库服务（比如 MySQL）\n  db:\n    image: mysql:5.7 # 使用 MySQL 5.7 镜像\n\n    # volumes: 数据卷挂载，持久化数据库数据\n    volumes:\n      # 把 db-data 命名卷挂载到容器里 MySQL 存储数据的目录\n      # 这样数据库数据就不会丢失\n      - db-data:/var/lib/mysql\n\n    # environment: 设置数据库的环境变量（比如 root 密码，很重要！）\n    environment:\n      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD} # 从环境变量或 .env 读取 root 密码\n      - MYSQL_DATABASE=${DB_NAME} # 自动创建的数据库名\n\n    # restart: 重启策略\n    restart: unless-stopped\n\n    # networks: 加入到同一个网络\n    networks:\n      - backend_network # 和 app 服务在同一个网络，app 就可以通过主机名 'db' 访问它\n\n    # healthcheck: 数据库的健康检查（也很重要！）\n    # healthcheck:\n    #   test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-p${MYSQL_ROOT_PASSWORD}\"]\n    #   interval: 10s\n    #   timeout: 5s\n    #   retries: 5\n\n\n# volumes: 在顶层声明命名卷，让 Docker 管理数据存储\nvolumes:\n  db-data: # 声明一个叫 db-data 的命名卷\n  # app-logs: # 如果上面 volumes 也用了 app-logs，这里也要声明\n\n# networks: 在顶层声明自定义网络\nnetworks:\n  backend_network: # 声明一个叫 backend_network 的网络\n    # driver: bridge 是默认类型，通常不用写\n```","slug":"Docker/Docker Compose 字段详解篇（一）：服务配置（services）","published":1,"updated":"2025-06-07T15:58:53.662Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww30007pkrc23y0glsb","content":"<h1 id=\"🐳-服务配置（services）全面解读-写给小白的超详细指南！\"><a href=\"#🐳-服务配置（services）全面解读-写给小白的超详细指南！\" class=\"headerlink\" title=\"🐳 服务配置（services）全面解读 - 写给小白的超详细指南！\"></a>🐳 服务配置（services）全面解读 - 写给小白的超详细指南！</h1><p>你好呀！欢迎来到 Docker Compose 的世界！如果你觉得 <code>docker-compose.yml</code> 文件看起来有点复杂，别担心，我们一步一步来拆解它。</p>\n<p>这个文件里最重要的部分就是 <code>services</code> 了，你可以简单理解它就像一个菜单，列出了你的项目里需要运行的所有“服务”（比如你的网站后端、数据库、缓存等等）。每个服务对应一个容器，而 <code>services</code> 下面的每一项，就是告诉你 Docker Compose 怎么去创建和运行这个容器。</p>\n<p>今天，我们就来把 <code>services</code> 里那些最常用、最能帮你解决问题的字段，用大白话给你讲清楚！</p>\n<hr>\n<h2 id=\"🧩-1-image：直接用现成的“积木”\"><a href=\"#🧩-1-image：直接用现成的“积木”\" class=\"headerlink\" title=\"🧩 1. image：直接用现成的“积木”\"></a>🧩 1. <code>image</code>：直接用现成的“积木”</h2><p>想象一下，Docker Hub 上有很多已经搭好的“积木”（镜像），比如 Nginx（用来跑网站）、MySQL（数据库）、Redis（缓存）。<code>image</code> 字段就是告诉你 Docker Compose，你想用哪块现成的积木来启动你的服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务，名字叫 web（名字你可以随便起）</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"comment\"># 好了，web 这个服务，我要用哪个 Docker 镜像来启动呢？</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span>  <span class=\"comment\"># 我要用 Docker Hub 上的 nginx 镜像，版本是 latest（最新版）</span></span><br><span class=\"line\">                          <span class=\"comment\"># 比如 image: mysql:5.7 就是用 MySQL 5.7 版本镜像</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：超级简单快速地启动一个标准服务，不用你自己从零开始搭。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你想快速跑个数据库、缓存或者一个标准的 Web 服务器（比如 Nginx）。</li>\n<li>你的团队已经帮你打包好了镜像，你只需要拿来用就行。</li>\n</ul>\n</li>\n</ul>\n<p>🧪 <strong>举个栗子：快速启动一个 Redis 缓存服务</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"comment\"># 直接用官方的 Redis 镜像，版本指定 7.2</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.2</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🛠️-2-build：自己动手，“捏”一个专属积木\"><a href=\"#🛠️-2-build：自己动手，“捏”一个专属积木\" class=\"headerlink\" title=\"🛠️ 2. build：自己动手，“捏”一个专属积木\"></a>🛠️ 2. <code>build</code>：自己动手，“捏”一个专属积木</h2><p>有时候，现成的积木不满足你的需求，比如你写了自己的网站代码或者应用。这时候，你就需要根据你的代码和配置，自己动手“捏”一个专属的镜像。<code>build</code> 字段就是干这个的。它会告诉 Docker Compose 去哪里找到你的“制作图纸”（Dockerfile），然后帮你把镜像做出来。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 myapp</span></span><br><span class=\"line\">  <span class=\"attr\">myapp:</span></span><br><span class=\"line\">    <span class=\"comment\"># 我不直接用现成镜像，我要从我的本地代码来“构建”一个专属镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"comment\"># context: 告诉 Docker 去哪个目录找你的代码和 Dockerfile</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./app</span>           <span class=\"comment\"># 比如，我的应用代码和 Dockerfile 都在当前目录下的 app 文件夹里</span></span><br><span class=\"line\">      <span class=\"comment\"># dockerfile: 如果你的制作图纸不叫 Dockerfile（默认名字），或者你想用特定的图纸</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span>  <span class=\"comment\"># 比如，我用了专门给开发环境准备的 Dockerfile.dev 文件</span></span><br><span class=\"line\">      <span class=\"comment\"># args: 在构建镜像的时候，可以传一些参数进去，影响制作过程</span></span><br><span class=\"line\">      <span class=\"attr\">args:</span></span><br><span class=\"line\">        <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span>     <span class=\"comment\"># 比如，告诉制作过程现在是开发环境</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：根据你的代码和 <code>Dockerfile</code>，构建一个包含你应用的定制镜像。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你需要运行你自己开发的应用（Web 应用、API 服务等）。</li>\n<li>你需要为不同的环境（开发、测试、生产）构建不同的镜像。</li>\n</ul>\n</li>\n</ul>\n<p>🚀 <strong>构建流程（Docker Compose 帮你做的）</strong></p>\n<ol>\n<li>Docker Compose 会找到你指定的 <code>context</code> 目录（比如上面的 <code>./app</code>）。</li>\n<li>它会在那个目录里找到你指定的 <code>dockerfile</code> 文件（比如 <code>Dockerfile.dev</code>）。</li>\n<li>如果定义了 <code>args</code>，它会把这些参数传给构建过程。</li>\n<li>Docker 会按照 <code>Dockerfile</code> 里的步骤，把你的代码、依赖等都打包进一个新的镜像。</li>\n<li>最后，Docker Compose 会用这个刚构建好的镜像来启动你的容器。</li>\n</ol>\n<hr>\n<h2 id=\"🚪-3-ports：给你的容器“开个门”\"><a href=\"#🚪-3-ports：给你的容器“开个门”\" class=\"headerlink\" title=\"🚪 3. ports：给你的容器“开个门”\"></a>🚪 3. <code>ports</code>：给你的容器“开个门”</h2><p>容器就像一个独立的“小房子”，默认外面是访问不到里面的服务的（比如容器里跑的网站）。<code>ports</code> 字段就像在“小房子”和外面的“宿主机”（运行 Docker 的那台电脑或服务器）之间开一道门，让外面的人可以通过宿主机的地址和端口，访问到容器里的服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 web</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-server</span></span><br><span class=\"line\">    <span class=\"comment\"># ports: 设置端口映射，把宿主机的端口和容器里的端口连起来</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式是：&quot;宿主机端口:容器内部端口&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:80&quot;</span>  <span class=\"comment\"># 意思是：访问我宿主机的 8080 端口，实际上就访问到了 web 容器里的 80 端口</span></span><br><span class=\"line\">      <span class=\"comment\"># 你也可以这样写：&quot;127.0.0.1:8080:80&quot; 只让宿主机本地访问 8080</span></span><br><span class=\"line\">      <span class=\"comment\"># 或者只写容器端口：&quot;80&quot; 这样 Docker 会随机给你分配一个宿主机端口</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：让外部网络（比如你的浏览器、或者别的电脑）能够访问到 Docker 容器内部运行的服务。</li>\n<li><strong>格式说明</strong>：<code>宿主机端口:容器端口</code> 或者 <code>宿主机IP:宿主机端口:容器端口</code>。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你需要通过浏览器访问容器里的网站或 Web 应用。</li>\n<li>你需要通过客户端工具连接容器里的数据库（比如 Navicat 连接 MySQL）。</li>\n<li>其他任何需要从外部访问容器内部服务的场景。</li>\n</ul>\n</li>\n</ul>\n<p>🌍 <strong>例子：跑两个服务，分别用不同端口访问</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-vue-app</span> <span class=\"comment\"># 假设这是你打包好的 Vue 应用镜像</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:80&quot;</span>    <span class=\"comment\"># 把宿主机的 3000 端口映射到容器前端应用的 80 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-node-api</span> <span class=\"comment\"># 假设这是你打包好的 Node.js API 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;4000:8080&quot;</span>  <span class=\"comment\"># 把宿主机的 4000 端口映射到容器后端 API 的 8080 端口</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，你就可以通过 <code>http://宿主机IP:3000</code> 访问前端，通过 <code>http://宿主机IP:4000</code> 访问后端了。</p>\n<hr>\n<h2 id=\"💾-4-volumes：让容器的数据“活”下来，或者和本地同步\"><a href=\"#💾-4-volumes：让容器的数据“活”下来，或者和本地同步\" class=\"headerlink\" title=\"💾 4. volumes：让容器的数据“活”下来，或者和本地同步\"></a>💾 4. <code>volumes</code>：让容器的数据“活”下来，或者和本地同步</h2><p>容器在停止或删除后，里面的数据通常就没了。而且开发时，我们希望改了本地代码，容器里的代码也能立刻更新，不用重新构建镜像。<code>volumes</code> 就是来解决这两个问题的利器！它可以把宿主机的目录或者一个特殊的“数据卷”挂载到容器里。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 app</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app-image</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 设置数据卷挂载</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式是：&quot;宿主机路径或命名卷名:容器内部路径&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># 第一种：本地路径挂载（也叫绑定挂载 Bind Mount）</span></span><br><span class=\"line\">      <span class=\"comment\"># 作用：把宿主机当前目录（.）整个挂载到容器里的 /app 目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 效果：你改动宿主机当前目录的文件，容器 /app 里的文件也跟着变，反之亦然</span></span><br><span class=\"line\">      <span class=\"comment\"># 适合：本地开发时同步代码，或者共享配置文件</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># 第二种：命名卷挂载（Named Volume）</span></span><br><span class=\"line\">      <span class=\"comment\"># 作用：创建一个由 Docker 专门管理的数据存储区域，名字叫 data-volume</span></span><br><span class=\"line\">      <span class=\"comment\">#      然后把容器里 /var/lib/mysql 目录的数据都存到这个 data-volume 里</span></span><br><span class=\"line\">      <span class=\"comment\"># 效果：即使你删除了这个容器，data-volume 里保存的数据还在，下次启动新容器还可以继续用</span></span><br><span class=\"line\">      <span class=\"comment\"># 适合：保存数据库数据、日志文件等需要长期保留的数据</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">data-volume:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 db</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把 db 容器的数据库文件目录挂载到前面定义的 data-volume 命名卷里</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">data-volume:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重要！所有用到的“命名卷”需要在 docker-compose.yml 文件的最顶层单独声明</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 data-volume 的命名卷</span></span><br><span class=\"line\">  <span class=\"attr\">data-volume:</span></span><br><span class=\"line\">    <span class=\"comment\"># 你可以在这里加一些配置，但通常直接声明名字就行了</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：实现宿主机和容器之间、或者容器和持久化存储区域之间的数据共享和同步。</li>\n<li><strong>类型</strong>：<ul>\n<li><strong>本地路径挂载 (Bind Mount)</strong>：<code>宿主机目录:/容器目录</code>。直接把宿主机的一个目录映射到容器里。适合开发时的代码同步、挂载配置文件。</li>\n<li><strong>命名卷挂载 (Named Volume)</strong>：<code>命名卷名:/容器目录</code>。Docker 自己管理的一块存储区域。适合需要持久化保存的数据（数据库、上传文件等）。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>开发时需要实时修改代码，容器立即看到效果（热更新）。</li>\n<li>需要保证数据库、缓存等服务的数据在容器重启或删除后不丢失。</li>\n<li>多个服务需要共享同一个配置文件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌱-5-environment：给容器“喂”配置信息\"><a href=\"#🌱-5-environment：给容器“喂”配置信息\" class=\"headerlink\" title=\"🌱 5. environment：给容器“喂”配置信息\"></a>🌱 5. <code>environment</code>：给容器“喂”配置信息</h2><p>很多应用在启动时需要一些配置信息，比如数据库地址、用户名密码、API密钥、运行模式（开发&#x2F;生产）等等。<code>environment</code> 字段就是把这些信息作为“环境变量”传递给容器里的应用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置环境变量列表</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式： 变量名=值</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span>    <span class=\"comment\"># 告诉容器里的 Node.js 应用，当前是生产环境</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span>             <span class=\"comment\"># 告诉应用数据库的主机名是 &#x27;db&#x27;（后面会讲到如何在服务间通信）</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=myuser</span>         <span class=\"comment\"># 数据库用户名</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以写成对象形式，效果一样：</span></span><br><span class=\"line\">      <span class=\"comment\"># DB_PASS: mysecretpassword # 数据库密码</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：把配置参数、密钥、运行模式等信息传递给容器里运行的应用。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>配置应用的数据库连接信息。</li>\n<li>设置 API 密钥或 Token。</li>\n<li>切换应用的运行模式（如 debug 开关）。</li>\n<li>任何需要外部配置的应用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📄-6-env-file：批量加载环境变量\"><a href=\"#📄-6-env-file：批量加载环境变量\" class=\"headerlink\" title=\"📄 6. env_file：批量加载环境变量\"></a>📄 6. <code>env_file</code>：批量加载环境变量</h2><p>如果你的环境变量特别多，或者包含一些敏感信息（虽然不推荐直接写在 yml 里，但有时开发方便），把它们都写在 <code>environment</code> 字段里会显得很乱。<code>env_file</code> 字段可以让你把环境变量统一写在一个或多个文件里（通常命名为 <code>.env</code>），然后让 Docker Compose 一次性加载进来。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 web</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file: 指定要加载的环境变量文件</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env</span>  <span class=\"comment\"># 加载当前目录下的 .env 文件</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以加载多个文件：</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./config/common.env</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./config/secret.env</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：从指定的文件中读取环境变量，并设置到容器里。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>项目有很多环境变量，方便集中管理。</li>\n<li>不想把敏感信息（如密码）直接暴露在 <code>docker-compose.yml</code> 文件中（虽然 <code>.env</code> 文件本身也需要保护）。</li>\n</ul>\n</li>\n</ul>\n<p>📌 <strong><code>.env</code> 文件长啥样？</strong></p>\n<p>它就是个普通文本文件，每行一个 <code>变量名=值</code>，像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一个 .env 文件示例</span><br><span class=\"line\"></span><br><span class=\"line\"># 数据库配置</span><br><span class=\"line\">DB_USER=root</span><br><span class=\"line\">DB_PASS=supersecretpassword123</span><br><span class=\"line\">DB_NAME=myapp</span><br><span class=\"line\"></span><br><span class=\"line\"># 应用配置</span><br><span class=\"line\">API_KEY=abcdef123456</span><br><span class=\"line\">DEBUG_MODE=true</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🎯-7-command-与-entrypoint：控制容器启动后执行什么\"><a href=\"#🎯-7-command-与-entrypoint：控制容器启动后执行什么\" class=\"headerlink\" title=\"🎯 7. command 与 entrypoint：控制容器启动后执行什么\"></a>🎯 7. <code>command</code> 与 <code>entrypoint</code>：控制容器启动后执行什么</h2><p>一个镜像在制作时，通常会指定容器启动后默认执行什么命令（比如启动一个 Web 服务器或者运行一个脚本）。<code>command</code> 和 <code>entrypoint</code> 字段可以让你覆盖镜像里预设的启动命令。</p>\n<ul>\n<li><strong><code>command</code></strong>：主要用来指定容器启动后要执行的“主要”命令，它会替换 Dockerfile 里的 <code>CMD</code>。如果镜像里设置了 <code>ENTRYPOINT</code>，那么 <code>command</code> 里的内容会作为参数传给 <code>ENTRYPOINT</code>。</li>\n<li><strong><code>entrypoint</code></strong>：设置容器启动时第一个执行的程序或脚本。它会替换 Dockerfile 里的 <code>ENTRYPOINT</code> 指令。通常用于做一些初始化工作（比如权限设置、等待依赖服务等），然后再执行 <code>command</code> 或镜像默认的 <code>CMD</code>。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># command: 覆盖镜像默认的 CMD</span></span><br><span class=\"line\">    <span class=\"comment\"># 比如，镜像默认是只启动服务，但我想带一些参数启动</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;start:dev&quot;</span>]  <span class=\"comment\"># 告诉容器执行 npm run start:dev 命令来启动服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 worker</span></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-worker-image</span></span><br><span class=\"line\">    <span class=\"comment\"># entrypoint: 覆盖镜像默认的 ENTRYPOINT</span></span><br><span class=\"line\">    <span class=\"comment\"># 比如，镜像里有个 /init.sh 脚本用来做启动前的检查和设置</span></span><br><span class=\"line\">    <span class=\"attr\">entrypoint:</span> [<span class=\"string\">&quot;/init.sh&quot;</span>]              <span class=\"comment\"># 容器启动时先执行 /init.sh 脚本</span></span><br><span class=\"line\">    <span class=\"comment\"># command: [&quot;--process&quot;, &quot;queue1&quot;]    # 如果有 command，它会作为参数传给 entrypoint</span></span><br><span class=\"line\">                                        <span class=\"comment\"># 相当于执行： /init.sh --process queue1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>适合场景</strong>：<ul>\n<li>你的应用需要特定的启动参数。</li>\n<li>容器启动前需要执行一些初始化脚本（比如数据库迁移、权限设置）。</li>\n<li>你想改变镜像默认的启动行为。</li>\n</ul>\n</li>\n</ul>\n<p><strong>简单理解</strong>：<code>ENTRYPOINT</code> 就像是你程序的入口或者启动器，<code>CMD</code> (或 <code>command</code>) 是传给这个启动器的参数，或者如果没启动器，就是直接执行的命令。</p>\n<hr>\n<h2 id=\"🔁-8-restart：让你的服务“摔倒了自己爬起来”\"><a href=\"#🔁-8-restart：让你的服务“摔倒了自己爬起来”\" class=\"headerlink\" title=\"🔁 8. restart：让你的服务“摔倒了自己爬起来”\"></a>🔁 8. <code>restart</code>：让你的服务“摔倒了自己爬起来”</h2><p>你的容器可能会因为各种原因意外停止，比如程序崩溃、内存不足等。<code>restart</code> 字段可以设置一个策略，让 Docker Compose 在容器停止后自动尝试重启它，提高服务的可用性。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 frontend</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend-image</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: 设置容器的重启策略</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 意思是：无论容器是正常退出还是异常退出，Docker Compose 都会尝试重启它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 还有其他选项：</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: no         # 默认值，容器停止后不会自动重启</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure # 容器以非零状态码退出时（表示出错）才重启</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: unless-stopped # 除非你手动用 docker stop 命令停掉它，否则一直重启</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：配置容器在停止后是否自动重启，以及在什么情况下重启。</li>\n<li><strong>选项说明</strong>：<ul>\n<li><code>no</code>：不自动重启（默认）。</li>\n<li><code>on-failure</code>：只有容器因非零状态码退出时才重启（表示发生错误）。</li>\n<li><code>always</code>：无论容器如何退出，总是重启它（除非 Docker Daemon 重启，它也会跟着重启）。</li>\n<li><code>unless-stopped</code>：除非用户或系统手动停止容器，否则总是重启。这是生产环境常用选项。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>后台服务容易因为各种原因崩溃，需要自动恢复。</li>\n<li>保障服务的持续运行和高可用性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧠-9-depends-on：告诉-Docker-Compose-启动顺序\"><a href=\"#🧠-9-depends-on：告诉-Docker-Compose-启动顺序\" class=\"headerlink\" title=\"🧠 9. depends_on：告诉 Docker Compose 启动顺序\"></a>🧠 9. <code>depends_on</code>：告诉 Docker Compose 启动顺序</h2><p>你的应用服务可能依赖于其他服务，比如你的 Web 后端需要先连接上数据库才能正常工作。<code>depends_on</code> 字段可以告诉 Docker Compose 在启动一个服务之前，先启动它依赖的其他服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 web （比如你的后端 API）</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 这个服务依赖于其他服务</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 告诉 Docker Compose：在启动 web 服务之前，先启动名字叫 db 的服务</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 db （比如你的数据库）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># db 没有 depends_on，它会先启动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意一个非常重要的地方！ depends_on 默认只保证依赖的服务“启动”了</span></span><br><span class=\"line\"><span class=\"comment\"># 它不保证依赖的服务已经“就绪”（比如数据库服务启动了，但可能还没完全初始化好，还没开始监听连接）</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你的服务启动需要等待依赖的服务完全就绪，最好结合后面的 healthcheck 一起使用</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：定义服务之间的启动依赖关系，确保被依赖的服务先启动。</li>\n<li><strong>注意</strong>：<strong>默认情况下，<code>depends_on</code> 只等待依赖的容器“启动”成功，不等待它里面的应用完全“就绪”并可以接收请求。</strong></li>\n<li><strong>推荐做法</strong>：在需要等待依赖服务“就绪”时，结合 <code>healthcheck</code> 和更高级的 <code>depends_on.condition</code> (比如 <code>condition: service_healthy</code>) 来使用。</li>\n</ul>\n<hr>\n<h2 id=\"❤️-10-healthcheck：检查你的服务是否“活”得健康\"><a href=\"#❤️-10-healthcheck：检查你的服务是否“活”得健康\" class=\"headerlink\" title=\"❤️ 10. healthcheck：检查你的服务是否“活”得健康\"></a>❤️ 10. <code>healthcheck</code>：检查你的服务是否“活”得健康</h2><p>容器启动了，不代表里面的服务就真的正常工作了。比如一个 Web 服务可能启动了，但内部出错了，并不能响应请求。<code>healthcheck</code> 字段就是用来定义如何检查服务是否“健康”的，Docker Compose 会周期性地执行这个检查。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 配置容器的健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># test: 定义健康检查命令。如果命令返回 0，表示健康；非 0 表示不健康</span></span><br><span class=\"line\">      <span class=\"comment\"># 这里用 curl 命令访问容器内部的 /health 接口，-f 参数表示如果 HTTP 状态码不是 2xx/3xx 就认为失败</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"comment\"># 你也可以用 CMD-SHELL 形式： test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U myuser -d mydatabase&quot;] # 检查 PostgreSQL 数据库是否准备好</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># interval: 多久执行一次健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span>      <span class=\"comment\"># 每 30 秒检查一次</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># timeout: 每次健康检查的超时时间，如果命令执行超过这个时间还没结束，就认为失败</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span>       <span class=\"comment\"># 每次检查最多等 10 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># retries: 连续失败多少次后，把容器状态标记为 &#x27;unhealthy&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>         <span class=\"comment\"># 连续失败 3 次就认为不健康</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># start_period: 给容器一个启动缓冲时间，在这段时间内的健康检查失败不会计入 retries</span></span><br><span class=\"line\">      <span class=\"comment\"># start_period: 60s # 容器启动后 60 秒内，健康检查失败暂时忽略</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：自动检测容器内运行的服务是否正常响应，而不仅仅是容器进程是否活着。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>确保服务在后台运行，并且确实在提供服务（没有假死）。</li>\n<li>需要精确判断一个服务是否“就绪”来启动依赖它的服务（结合 <code>depends_on.condition: service_healthy</code>）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌐-11-networks：让你的服务们“说上话”\"><a href=\"#🌐-11-networks：让你的服务们“说上话”\" class=\"headerlink\" title=\"🌐 11. networks：让你的服务们“说上话”\"></a>🌐 11. <code>networks</code>：让你的服务们“说上话”</h2><p>默认情况下，Docker Compose 会为你的项目创建一个网络，并把所有服务都放到这个网络里，这样它们就可以通过服务名互相访问了（比如 <code>api</code> 服务可以通过主机名 <code>db</code> 访问到数据库服务）。<code>networks</code> 字段可以让你把服务加入到特定的网络，或者定义自己的网络。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend</span></span><br><span class=\"line\">    <span class=\"comment\"># networks: 把这个服务加入到哪些网络中</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">frontend_net</span> <span class=\"comment\"># 加入到名字叫 frontend_net 的网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span>  <span class=\"comment\"># 也加入到名字叫 backend_net 的网络（如果需要直接访问后端）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span> <span class=\"comment\"># 加入到名字叫 backend_net 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个数据库服务</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span> <span class=\"comment\"># 加入到名字叫 backend_net 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重要！所有用到的“自定义网络”需要在 docker-compose.yml 文件的最顶层单独声明</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend_net:</span> <span class=\"comment\"># 声明一个叫 frontend_net 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">backend_net:</span>  <span class=\"comment\"># 声明一个叫 backend_net 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认的网络类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：管理服务之间的网络连接，让服务可以通过服务名互相通信。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你的应用包含多个服务（如前端、后端、数据库、缓存），它们需要互相访问。</li>\n<li>需要隔离不同的应用或服务组，让他们只能在各自的网络里通信。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📘-推荐组合模板：一个典型的-Node-js-应用架构\"><a href=\"#📘-推荐组合模板：一个典型的-Node-js-应用架构\" class=\"headerlink\" title=\"📘 推荐组合模板：一个典型的 Node.js 应用架构\"></a>📘 推荐组合模板：一个典型的 Node.js 应用架构</h2><p>把上面讲的常用字段组合起来，一个常见的 Web 应用（比如 Node.js 后端 + MySQL 数据库）的 <code>docker-compose.yml</code> 可能会长这样：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 Docker Compose 文件格式的版本</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 推荐使用较新的版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># services: 定义我们项目要运行的所有服务</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义第一个服务：应用后端（比如一个 Node.js API）</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地代码构建镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span> <span class=\"comment\"># 构建上下文是当前目录</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 使用当前目录下的 Dockerfile 文件</span></span><br><span class=\"line\">    <span class=\"comment\"># image: 你也可以在这里指定构建后的镜像名字，方便管理</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-nodejs-app:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射，让外部能访问到容器内的应用</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把宿主机的 80 端口映射到容器里应用监听的 3000 端口</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 数据卷挂载，用于代码同步和数据持久化</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把宿主机当前目录的代码，同步到容器里的 /app 目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 方便开发时改代码容器里立即生效</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以挂载其他需要的目录，比如日志目录</span></span><br><span class=\"line\">      <span class=\"comment\"># - app-logs:/app/logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置容器内部的环境变量</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span>    <span class=\"comment\"># 设置运行环境为生产模式</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span>             <span class=\"comment\"># 告诉应用数据库的主机名是另一个服务 &#x27;db&#x27;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=$&#123;DB_USER&#125;</span>     <span class=\"comment\"># 从宿主机的环境变量或 .env 文件读取数据库用户名</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PASS=$&#123;DB_PASSWORD&#125;</span> <span class=\"comment\"># 从宿主机的环境变量或 .env 文件读取数据库密码</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果使用 env_file 更方便管理大量变量</span></span><br><span class=\"line\">      <span class=\"comment\"># env_file: .env</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 设置服务启动依赖</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 告诉 Docker Compose，启动 app 服务之前，先启动 db 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># 注意：默认只等待 db 容器启动，不保证 db 服务完全就绪</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果需要等待 db 健康，可以这样写（需要 db 服务配置 healthcheck）：</span></span><br><span class=\"line\">      <span class=\"comment\"># db:</span></span><br><span class=\"line\">      <span class=\"comment\">#   condition: service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># restart: 重启策略，保障服务稳定性</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 除非手动停止，否则容器异常退出就自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># networks: 把服务加入到同一个网络，让他们能互相通信</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到叫 backend_network 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 健康检查（推荐加上，确保服务真的在工作）</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck:</span></span><br><span class=\"line\">    <span class=\"comment\">#   test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:3000/healthz&quot;]</span></span><br><span class=\"line\">    <span class=\"comment\">#   interval: 1m</span></span><br><span class=\"line\">    <span class=\"comment\">#   timeout: 10s</span></span><br><span class=\"line\">    <span class=\"comment\">#   retries: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义第二个服务：数据库服务（比如 MySQL）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用 MySQL 5.7 镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 数据卷挂载，持久化数据库数据</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把 db-data 命名卷挂载到容器里 MySQL 存储数据的目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 这样数据库数据就不会丢失</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置数据库的环境变量（比如 root 密码，很重要！）</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_ROOT_PASSWORD&#125;</span> <span class=\"comment\"># 从环境变量或 .env 读取 root 密码</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=$&#123;DB_NAME&#125;</span> <span class=\"comment\"># 自动创建的数据库名</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># restart: 重启策略</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># networks: 加入到同一个网络</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 和 app 服务在同一个网络，app 就可以通过主机名 &#x27;db&#x27; 访问它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 数据库的健康检查（也很重要！）</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck:</span></span><br><span class=\"line\">    <span class=\"comment\">#   test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;localhost&quot;, &quot;-p$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;]</span></span><br><span class=\"line\">    <span class=\"comment\">#   interval: 10s</span></span><br><span class=\"line\">    <span class=\"comment\">#   timeout: 5s</span></span><br><span class=\"line\">    <span class=\"comment\">#   retries: 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在顶层声明命名卷，让 Docker 管理数据存储</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span> <span class=\"comment\"># 声明一个叫 db-data 的命名卷</span></span><br><span class=\"line\">  <span class=\"comment\"># app-logs: # 如果上面 volumes 也用了 app-logs，这里也要声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在顶层声明自定义网络</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend_network:</span> <span class=\"comment\"># 声明一个叫 backend_network 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-服务配置（services）全面解读-写给小白的超详细指南！\"><a href=\"#🐳-服务配置（services）全面解读-写给小白的超详细指南！\" class=\"headerlink\" title=\"🐳 服务配置（services）全面解读 - 写给小白的超详细指南！\"></a>🐳 服务配置（services）全面解读 - 写给小白的超详细指南！</h1><p>你好呀！欢迎来到 Docker Compose 的世界！如果你觉得 <code>docker-compose.yml</code> 文件看起来有点复杂，别担心，我们一步一步来拆解它。</p>\n<p>这个文件里最重要的部分就是 <code>services</code> 了，你可以简单理解它就像一个菜单，列出了你的项目里需要运行的所有“服务”（比如你的网站后端、数据库、缓存等等）。每个服务对应一个容器，而 <code>services</code> 下面的每一项，就是告诉你 Docker Compose 怎么去创建和运行这个容器。</p>\n<p>今天，我们就来把 <code>services</code> 里那些最常用、最能帮你解决问题的字段，用大白话给你讲清楚！</p>\n<hr>\n<h2 id=\"🧩-1-image：直接用现成的“积木”\"><a href=\"#🧩-1-image：直接用现成的“积木”\" class=\"headerlink\" title=\"🧩 1. image：直接用现成的“积木”\"></a>🧩 1. <code>image</code>：直接用现成的“积木”</h2><p>想象一下，Docker Hub 上有很多已经搭好的“积木”（镜像），比如 Nginx（用来跑网站）、MySQL（数据库）、Redis（缓存）。<code>image</code> 字段就是告诉你 Docker Compose，你想用哪块现成的积木来启动你的服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务，名字叫 web（名字你可以随便起）</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"comment\"># 好了，web 这个服务，我要用哪个 Docker 镜像来启动呢？</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span>  <span class=\"comment\"># 我要用 Docker Hub 上的 nginx 镜像，版本是 latest（最新版）</span></span><br><span class=\"line\">                          <span class=\"comment\"># 比如 image: mysql:5.7 就是用 MySQL 5.7 版本镜像</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：超级简单快速地启动一个标准服务，不用你自己从零开始搭。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你想快速跑个数据库、缓存或者一个标准的 Web 服务器（比如 Nginx）。</li>\n<li>你的团队已经帮你打包好了镜像，你只需要拿来用就行。</li>\n</ul>\n</li>\n</ul>\n<p>🧪 <strong>举个栗子：快速启动一个 Redis 缓存服务</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"comment\"># 直接用官方的 Redis 镜像，版本指定 7.2</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.2</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🛠️-2-build：自己动手，“捏”一个专属积木\"><a href=\"#🛠️-2-build：自己动手，“捏”一个专属积木\" class=\"headerlink\" title=\"🛠️ 2. build：自己动手，“捏”一个专属积木\"></a>🛠️ 2. <code>build</code>：自己动手，“捏”一个专属积木</h2><p>有时候，现成的积木不满足你的需求，比如你写了自己的网站代码或者应用。这时候，你就需要根据你的代码和配置，自己动手“捏”一个专属的镜像。<code>build</code> 字段就是干这个的。它会告诉 Docker Compose 去哪里找到你的“制作图纸”（Dockerfile），然后帮你把镜像做出来。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 myapp</span></span><br><span class=\"line\">  <span class=\"attr\">myapp:</span></span><br><span class=\"line\">    <span class=\"comment\"># 我不直接用现成镜像，我要从我的本地代码来“构建”一个专属镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"comment\"># context: 告诉 Docker 去哪个目录找你的代码和 Dockerfile</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./app</span>           <span class=\"comment\"># 比如，我的应用代码和 Dockerfile 都在当前目录下的 app 文件夹里</span></span><br><span class=\"line\">      <span class=\"comment\"># dockerfile: 如果你的制作图纸不叫 Dockerfile（默认名字），或者你想用特定的图纸</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span>  <span class=\"comment\"># 比如，我用了专门给开发环境准备的 Dockerfile.dev 文件</span></span><br><span class=\"line\">      <span class=\"comment\"># args: 在构建镜像的时候，可以传一些参数进去，影响制作过程</span></span><br><span class=\"line\">      <span class=\"attr\">args:</span></span><br><span class=\"line\">        <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span>     <span class=\"comment\"># 比如，告诉制作过程现在是开发环境</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：根据你的代码和 <code>Dockerfile</code>，构建一个包含你应用的定制镜像。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你需要运行你自己开发的应用（Web 应用、API 服务等）。</li>\n<li>你需要为不同的环境（开发、测试、生产）构建不同的镜像。</li>\n</ul>\n</li>\n</ul>\n<p>🚀 <strong>构建流程（Docker Compose 帮你做的）</strong></p>\n<ol>\n<li>Docker Compose 会找到你指定的 <code>context</code> 目录（比如上面的 <code>./app</code>）。</li>\n<li>它会在那个目录里找到你指定的 <code>dockerfile</code> 文件（比如 <code>Dockerfile.dev</code>）。</li>\n<li>如果定义了 <code>args</code>，它会把这些参数传给构建过程。</li>\n<li>Docker 会按照 <code>Dockerfile</code> 里的步骤，把你的代码、依赖等都打包进一个新的镜像。</li>\n<li>最后，Docker Compose 会用这个刚构建好的镜像来启动你的容器。</li>\n</ol>\n<hr>\n<h2 id=\"🚪-3-ports：给你的容器“开个门”\"><a href=\"#🚪-3-ports：给你的容器“开个门”\" class=\"headerlink\" title=\"🚪 3. ports：给你的容器“开个门”\"></a>🚪 3. <code>ports</code>：给你的容器“开个门”</h2><p>容器就像一个独立的“小房子”，默认外面是访问不到里面的服务的（比如容器里跑的网站）。<code>ports</code> 字段就像在“小房子”和外面的“宿主机”（运行 Docker 的那台电脑或服务器）之间开一道门，让外面的人可以通过宿主机的地址和端口，访问到容器里的服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 web</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-server</span></span><br><span class=\"line\">    <span class=\"comment\"># ports: 设置端口映射，把宿主机的端口和容器里的端口连起来</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式是：&quot;宿主机端口:容器内部端口&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:80&quot;</span>  <span class=\"comment\"># 意思是：访问我宿主机的 8080 端口，实际上就访问到了 web 容器里的 80 端口</span></span><br><span class=\"line\">      <span class=\"comment\"># 你也可以这样写：&quot;127.0.0.1:8080:80&quot; 只让宿主机本地访问 8080</span></span><br><span class=\"line\">      <span class=\"comment\"># 或者只写容器端口：&quot;80&quot; 这样 Docker 会随机给你分配一个宿主机端口</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：让外部网络（比如你的浏览器、或者别的电脑）能够访问到 Docker 容器内部运行的服务。</li>\n<li><strong>格式说明</strong>：<code>宿主机端口:容器端口</code> 或者 <code>宿主机IP:宿主机端口:容器端口</code>。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你需要通过浏览器访问容器里的网站或 Web 应用。</li>\n<li>你需要通过客户端工具连接容器里的数据库（比如 Navicat 连接 MySQL）。</li>\n<li>其他任何需要从外部访问容器内部服务的场景。</li>\n</ul>\n</li>\n</ul>\n<p>🌍 <strong>例子：跑两个服务，分别用不同端口访问</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-vue-app</span> <span class=\"comment\"># 假设这是你打包好的 Vue 应用镜像</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:80&quot;</span>    <span class=\"comment\"># 把宿主机的 3000 端口映射到容器前端应用的 80 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-node-api</span> <span class=\"comment\"># 假设这是你打包好的 Node.js API 镜像</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;4000:8080&quot;</span>  <span class=\"comment\"># 把宿主机的 4000 端口映射到容器后端 API 的 8080 端口</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，你就可以通过 <code>http://宿主机IP:3000</code> 访问前端，通过 <code>http://宿主机IP:4000</code> 访问后端了。</p>\n<hr>\n<h2 id=\"💾-4-volumes：让容器的数据“活”下来，或者和本地同步\"><a href=\"#💾-4-volumes：让容器的数据“活”下来，或者和本地同步\" class=\"headerlink\" title=\"💾 4. volumes：让容器的数据“活”下来，或者和本地同步\"></a>💾 4. <code>volumes</code>：让容器的数据“活”下来，或者和本地同步</h2><p>容器在停止或删除后，里面的数据通常就没了。而且开发时，我们希望改了本地代码，容器里的代码也能立刻更新，不用重新构建镜像。<code>volumes</code> 就是来解决这两个问题的利器！它可以把宿主机的目录或者一个特殊的“数据卷”挂载到容器里。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 app</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app-image</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 设置数据卷挂载</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式是：&quot;宿主机路径或命名卷名:容器内部路径&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># 第一种：本地路径挂载（也叫绑定挂载 Bind Mount）</span></span><br><span class=\"line\">      <span class=\"comment\"># 作用：把宿主机当前目录（.）整个挂载到容器里的 /app 目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 效果：你改动宿主机当前目录的文件，容器 /app 里的文件也跟着变，反之亦然</span></span><br><span class=\"line\">      <span class=\"comment\"># 适合：本地开发时同步代码，或者共享配置文件</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># 第二种：命名卷挂载（Named Volume）</span></span><br><span class=\"line\">      <span class=\"comment\"># 作用：创建一个由 Docker 专门管理的数据存储区域，名字叫 data-volume</span></span><br><span class=\"line\">      <span class=\"comment\">#      然后把容器里 /var/lib/mysql 目录的数据都存到这个 data-volume 里</span></span><br><span class=\"line\">      <span class=\"comment\"># 效果：即使你删除了这个容器，data-volume 里保存的数据还在，下次启动新容器还可以继续用</span></span><br><span class=\"line\">      <span class=\"comment\"># 适合：保存数据库数据、日志文件等需要长期保留的数据</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">data-volume:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 db</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把 db 容器的数据库文件目录挂载到前面定义的 data-volume 命名卷里</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">data-volume:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重要！所有用到的“命名卷”需要在 docker-compose.yml 文件的最顶层单独声明</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 data-volume 的命名卷</span></span><br><span class=\"line\">  <span class=\"attr\">data-volume:</span></span><br><span class=\"line\">    <span class=\"comment\"># 你可以在这里加一些配置，但通常直接声明名字就行了</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：实现宿主机和容器之间、或者容器和持久化存储区域之间的数据共享和同步。</li>\n<li><strong>类型</strong>：<ul>\n<li><strong>本地路径挂载 (Bind Mount)</strong>：<code>宿主机目录:/容器目录</code>。直接把宿主机的一个目录映射到容器里。适合开发时的代码同步、挂载配置文件。</li>\n<li><strong>命名卷挂载 (Named Volume)</strong>：<code>命名卷名:/容器目录</code>。Docker 自己管理的一块存储区域。适合需要持久化保存的数据（数据库、上传文件等）。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>开发时需要实时修改代码，容器立即看到效果（热更新）。</li>\n<li>需要保证数据库、缓存等服务的数据在容器重启或删除后不丢失。</li>\n<li>多个服务需要共享同一个配置文件。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌱-5-environment：给容器“喂”配置信息\"><a href=\"#🌱-5-environment：给容器“喂”配置信息\" class=\"headerlink\" title=\"🌱 5. environment：给容器“喂”配置信息\"></a>🌱 5. <code>environment</code>：给容器“喂”配置信息</h2><p>很多应用在启动时需要一些配置信息，比如数据库地址、用户名密码、API密钥、运行模式（开发&#x2F;生产）等等。<code>environment</code> 字段就是把这些信息作为“环境变量”传递给容器里的应用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置环境变量列表</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式： 变量名=值</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span>    <span class=\"comment\"># 告诉容器里的 Node.js 应用，当前是生产环境</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span>             <span class=\"comment\"># 告诉应用数据库的主机名是 &#x27;db&#x27;（后面会讲到如何在服务间通信）</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=myuser</span>         <span class=\"comment\"># 数据库用户名</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以写成对象形式，效果一样：</span></span><br><span class=\"line\">      <span class=\"comment\"># DB_PASS: mysecretpassword # 数据库密码</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：把配置参数、密钥、运行模式等信息传递给容器里运行的应用。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>配置应用的数据库连接信息。</li>\n<li>设置 API 密钥或 Token。</li>\n<li>切换应用的运行模式（如 debug 开关）。</li>\n<li>任何需要外部配置的应用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📄-6-env-file：批量加载环境变量\"><a href=\"#📄-6-env-file：批量加载环境变量\" class=\"headerlink\" title=\"📄 6. env_file：批量加载环境变量\"></a>📄 6. <code>env_file</code>：批量加载环境变量</h2><p>如果你的环境变量特别多，或者包含一些敏感信息（虽然不推荐直接写在 yml 里，但有时开发方便），把它们都写在 <code>environment</code> 字段里会显得很乱。<code>env_file</code> 字段可以让你把环境变量统一写在一个或多个文件里（通常命名为 <code>.env</code>），然后让 Docker Compose 一次性加载进来。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 我要定义一个服务叫 web</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file: 指定要加载的环境变量文件</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env</span>  <span class=\"comment\"># 加载当前目录下的 .env 文件</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以加载多个文件：</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./config/common.env</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./config/secret.env</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：从指定的文件中读取环境变量，并设置到容器里。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>项目有很多环境变量，方便集中管理。</li>\n<li>不想把敏感信息（如密码）直接暴露在 <code>docker-compose.yml</code> 文件中（虽然 <code>.env</code> 文件本身也需要保护）。</li>\n</ul>\n</li>\n</ul>\n<p>📌 <strong><code>.env</code> 文件长啥样？</strong></p>\n<p>它就是个普通文本文件，每行一个 <code>变量名=值</code>，像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是一个 .env 文件示例</span><br><span class=\"line\"></span><br><span class=\"line\"># 数据库配置</span><br><span class=\"line\">DB_USER=root</span><br><span class=\"line\">DB_PASS=supersecretpassword123</span><br><span class=\"line\">DB_NAME=myapp</span><br><span class=\"line\"></span><br><span class=\"line\"># 应用配置</span><br><span class=\"line\">API_KEY=abcdef123456</span><br><span class=\"line\">DEBUG_MODE=true</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🎯-7-command-与-entrypoint：控制容器启动后执行什么\"><a href=\"#🎯-7-command-与-entrypoint：控制容器启动后执行什么\" class=\"headerlink\" title=\"🎯 7. command 与 entrypoint：控制容器启动后执行什么\"></a>🎯 7. <code>command</code> 与 <code>entrypoint</code>：控制容器启动后执行什么</h2><p>一个镜像在制作时，通常会指定容器启动后默认执行什么命令（比如启动一个 Web 服务器或者运行一个脚本）。<code>command</code> 和 <code>entrypoint</code> 字段可以让你覆盖镜像里预设的启动命令。</p>\n<ul>\n<li><strong><code>command</code></strong>：主要用来指定容器启动后要执行的“主要”命令，它会替换 Dockerfile 里的 <code>CMD</code>。如果镜像里设置了 <code>ENTRYPOINT</code>，那么 <code>command</code> 里的内容会作为参数传给 <code>ENTRYPOINT</code>。</li>\n<li><strong><code>entrypoint</code></strong>：设置容器启动时第一个执行的程序或脚本。它会替换 Dockerfile 里的 <code>ENTRYPOINT</code> 指令。通常用于做一些初始化工作（比如权限设置、等待依赖服务等），然后再执行 <code>command</code> 或镜像默认的 <code>CMD</code>。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># command: 覆盖镜像默认的 CMD</span></span><br><span class=\"line\">    <span class=\"comment\"># 比如，镜像默认是只启动服务，但我想带一些参数启动</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;start:dev&quot;</span>]  <span class=\"comment\"># 告诉容器执行 npm run start:dev 命令来启动服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 worker</span></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-worker-image</span></span><br><span class=\"line\">    <span class=\"comment\"># entrypoint: 覆盖镜像默认的 ENTRYPOINT</span></span><br><span class=\"line\">    <span class=\"comment\"># 比如，镜像里有个 /init.sh 脚本用来做启动前的检查和设置</span></span><br><span class=\"line\">    <span class=\"attr\">entrypoint:</span> [<span class=\"string\">&quot;/init.sh&quot;</span>]              <span class=\"comment\"># 容器启动时先执行 /init.sh 脚本</span></span><br><span class=\"line\">    <span class=\"comment\"># command: [&quot;--process&quot;, &quot;queue1&quot;]    # 如果有 command，它会作为参数传给 entrypoint</span></span><br><span class=\"line\">                                        <span class=\"comment\"># 相当于执行： /init.sh --process queue1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>适合场景</strong>：<ul>\n<li>你的应用需要特定的启动参数。</li>\n<li>容器启动前需要执行一些初始化脚本（比如数据库迁移、权限设置）。</li>\n<li>你想改变镜像默认的启动行为。</li>\n</ul>\n</li>\n</ul>\n<p><strong>简单理解</strong>：<code>ENTRYPOINT</code> 就像是你程序的入口或者启动器，<code>CMD</code> (或 <code>command</code>) 是传给这个启动器的参数，或者如果没启动器，就是直接执行的命令。</p>\n<hr>\n<h2 id=\"🔁-8-restart：让你的服务“摔倒了自己爬起来”\"><a href=\"#🔁-8-restart：让你的服务“摔倒了自己爬起来”\" class=\"headerlink\" title=\"🔁 8. restart：让你的服务“摔倒了自己爬起来”\"></a>🔁 8. <code>restart</code>：让你的服务“摔倒了自己爬起来”</h2><p>你的容器可能会因为各种原因意外停止，比如程序崩溃、内存不足等。<code>restart</code> 字段可以设置一个策略，让 Docker Compose 在容器停止后自动尝试重启它，提高服务的可用性。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 frontend</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend-image</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: 设置容器的重启策略</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span> <span class=\"comment\"># 意思是：无论容器是正常退出还是异常退出，Docker Compose 都会尝试重启它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 还有其他选项：</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: no         # 默认值，容器停止后不会自动重启</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: on-failure # 容器以非零状态码退出时（表示出错）才重启</span></span><br><span class=\"line\">    <span class=\"comment\"># restart: unless-stopped # 除非你手动用 docker stop 命令停掉它，否则一直重启</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：配置容器在停止后是否自动重启，以及在什么情况下重启。</li>\n<li><strong>选项说明</strong>：<ul>\n<li><code>no</code>：不自动重启（默认）。</li>\n<li><code>on-failure</code>：只有容器因非零状态码退出时才重启（表示发生错误）。</li>\n<li><code>always</code>：无论容器如何退出，总是重启它（除非 Docker Daemon 重启，它也会跟着重启）。</li>\n<li><code>unless-stopped</code>：除非用户或系统手动停止容器，否则总是重启。这是生产环境常用选项。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>后台服务容易因为各种原因崩溃，需要自动恢复。</li>\n<li>保障服务的持续运行和高可用性。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧠-9-depends-on：告诉-Docker-Compose-启动顺序\"><a href=\"#🧠-9-depends-on：告诉-Docker-Compose-启动顺序\" class=\"headerlink\" title=\"🧠 9. depends_on：告诉 Docker Compose 启动顺序\"></a>🧠 9. <code>depends_on</code>：告诉 Docker Compose 启动顺序</h2><p>你的应用服务可能依赖于其他服务，比如你的 Web 后端需要先连接上数据库才能正常工作。<code>depends_on</code> 字段可以告诉 Docker Compose 在启动一个服务之前，先启动它依赖的其他服务。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 web （比如你的后端 API）</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 这个服务依赖于其他服务</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 告诉 Docker Compose：在启动 web 服务之前，先启动名字叫 db 的服务</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 db （比如你的数据库）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># db 没有 depends_on，它会先启动</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意一个非常重要的地方！ depends_on 默认只保证依赖的服务“启动”了</span></span><br><span class=\"line\"><span class=\"comment\"># 它不保证依赖的服务已经“就绪”（比如数据库服务启动了，但可能还没完全初始化好，还没开始监听连接）</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你的服务启动需要等待依赖的服务完全就绪，最好结合后面的 healthcheck 一起使用</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：定义服务之间的启动依赖关系，确保被依赖的服务先启动。</li>\n<li><strong>注意</strong>：<strong>默认情况下，<code>depends_on</code> 只等待依赖的容器“启动”成功，不等待它里面的应用完全“就绪”并可以接收请求。</strong></li>\n<li><strong>推荐做法</strong>：在需要等待依赖服务“就绪”时，结合 <code>healthcheck</code> 和更高级的 <code>depends_on.condition</code> (比如 <code>condition: service_healthy</code>) 来使用。</li>\n</ul>\n<hr>\n<h2 id=\"❤️-10-healthcheck：检查你的服务是否“活”得健康\"><a href=\"#❤️-10-healthcheck：检查你的服务是否“活”得健康\" class=\"headerlink\" title=\"❤️ 10. healthcheck：检查你的服务是否“活”得健康\"></a>❤️ 10. <code>healthcheck</code>：检查你的服务是否“活”得健康</h2><p>容器启动了，不代表里面的服务就真的正常工作了。比如一个 Web 服务可能启动了，但内部出错了，并不能响应请求。<code>healthcheck</code> 字段就是用来定义如何检查服务是否“健康”的，Docker Compose 会周期性地执行这个检查。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个服务叫 api</span></span><br><span class=\"line\">  <span class=\"attr\">api:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-api-image</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 配置容器的健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># test: 定义健康检查命令。如果命令返回 0，表示健康；非 0 表示不健康</span></span><br><span class=\"line\">      <span class=\"comment\"># 这里用 curl 命令访问容器内部的 /health 接口，-f 参数表示如果 HTTP 状态码不是 2xx/3xx 就认为失败</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"comment\"># 你也可以用 CMD-SHELL 形式： test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U myuser -d mydatabase&quot;] # 检查 PostgreSQL 数据库是否准备好</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># interval: 多久执行一次健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span>      <span class=\"comment\"># 每 30 秒检查一次</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># timeout: 每次健康检查的超时时间，如果命令执行超过这个时间还没结束，就认为失败</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span>       <span class=\"comment\"># 每次检查最多等 10 秒</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># retries: 连续失败多少次后，把容器状态标记为 &#x27;unhealthy&#x27;</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>         <span class=\"comment\"># 连续失败 3 次就认为不健康</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># start_period: 给容器一个启动缓冲时间，在这段时间内的健康检查失败不会计入 retries</span></span><br><span class=\"line\">      <span class=\"comment\"># start_period: 60s # 容器启动后 60 秒内，健康检查失败暂时忽略</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：自动检测容器内运行的服务是否正常响应，而不仅仅是容器进程是否活着。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>确保服务在后台运行，并且确实在提供服务（没有假死）。</li>\n<li>需要精确判断一个服务是否“就绪”来启动依赖它的服务（结合 <code>depends_on.condition: service_healthy</code>）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌐-11-networks：让你的服务们“说上话”\"><a href=\"#🌐-11-networks：让你的服务们“说上话”\" class=\"headerlink\" title=\"🌐 11. networks：让你的服务们“说上话”\"></a>🌐 11. <code>networks</code>：让你的服务们“说上话”</h2><p>默认情况下，Docker Compose 会为你的项目创建一个网络，并把所有服务都放到这个网络里，这样它们就可以通过服务名互相访问了（比如 <code>api</code> 服务可以通过主机名 <code>db</code> 访问到数据库服务）。<code>networks</code> 字段可以让你把服务加入到特定的网络，或者定义自己的网络。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend</span></span><br><span class=\"line\">    <span class=\"comment\"># networks: 把这个服务加入到哪些网络中</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">frontend_net</span> <span class=\"comment\"># 加入到名字叫 frontend_net 的网络</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span>  <span class=\"comment\"># 也加入到名字叫 backend_net 的网络（如果需要直接访问后端）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span> <span class=\"comment\"># 加入到名字叫 backend_net 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个数据库服务</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_net</span> <span class=\"comment\"># 加入到名字叫 backend_net 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重要！所有用到的“自定义网络”需要在 docker-compose.yml 文件的最顶层单独声明</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">frontend_net:</span> <span class=\"comment\"># 声明一个叫 frontend_net 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">backend_net:</span>  <span class=\"comment\"># 声明一个叫 backend_net 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认的网络类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：管理服务之间的网络连接，让服务可以通过服务名互相通信。</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你的应用包含多个服务（如前端、后端、数据库、缓存），它们需要互相访问。</li>\n<li>需要隔离不同的应用或服务组，让他们只能在各自的网络里通信。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📘-推荐组合模板：一个典型的-Node-js-应用架构\"><a href=\"#📘-推荐组合模板：一个典型的-Node-js-应用架构\" class=\"headerlink\" title=\"📘 推荐组合模板：一个典型的 Node.js 应用架构\"></a>📘 推荐组合模板：一个典型的 Node.js 应用架构</h2><p>把上面讲的常用字段组合起来，一个常见的 Web 应用（比如 Node.js 后端 + MySQL 数据库）的 <code>docker-compose.yml</code> 可能会长这样：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定 Docker Compose 文件格式的版本</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 推荐使用较新的版本</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># services: 定义我们项目要运行的所有服务</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义第一个服务：应用后端（比如一个 Node.js API）</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地代码构建镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span> <span class=\"comment\"># 构建上下文是当前目录</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 使用当前目录下的 Dockerfile 文件</span></span><br><span class=\"line\">    <span class=\"comment\"># image: 你也可以在这里指定构建后的镜像名字，方便管理</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-nodejs-app:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射，让外部能访问到容器内的应用</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把宿主机的 80 端口映射到容器里应用监听的 3000 端口</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 数据卷挂载，用于代码同步和数据持久化</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把宿主机当前目录的代码，同步到容器里的 /app 目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 方便开发时改代码容器里立即生效</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"comment\"># 也可以挂载其他需要的目录，比如日志目录</span></span><br><span class=\"line\">      <span class=\"comment\"># - app-logs:/app/logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置容器内部的环境变量</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span>    <span class=\"comment\"># 设置运行环境为生产模式</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span>             <span class=\"comment\"># 告诉应用数据库的主机名是另一个服务 &#x27;db&#x27;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_USER=$&#123;DB_USER&#125;</span>     <span class=\"comment\"># 从宿主机的环境变量或 .env 文件读取数据库用户名</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PASS=$&#123;DB_PASSWORD&#125;</span> <span class=\"comment\"># 从宿主机的环境变量或 .env 文件读取数据库密码</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果使用 env_file 更方便管理大量变量</span></span><br><span class=\"line\">      <span class=\"comment\"># env_file: .env</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 设置服务启动依赖</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 告诉 Docker Compose，启动 app 服务之前，先启动 db 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># 注意：默认只等待 db 容器启动，不保证 db 服务完全就绪</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果需要等待 db 健康，可以这样写（需要 db 服务配置 healthcheck）：</span></span><br><span class=\"line\">      <span class=\"comment\"># db:</span></span><br><span class=\"line\">      <span class=\"comment\">#   condition: service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># restart: 重启策略，保障服务稳定性</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 除非手动停止，否则容器异常退出就自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># networks: 把服务加入到同一个网络，让他们能互相通信</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到叫 backend_network 的网络</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 健康检查（推荐加上，确保服务真的在工作）</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck:</span></span><br><span class=\"line\">    <span class=\"comment\">#   test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:3000/healthz&quot;]</span></span><br><span class=\"line\">    <span class=\"comment\">#   interval: 1m</span></span><br><span class=\"line\">    <span class=\"comment\">#   timeout: 10s</span></span><br><span class=\"line\">    <span class=\"comment\">#   retries: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义第二个服务：数据库服务（比如 MySQL）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用 MySQL 5.7 镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 数据卷挂载，持久化数据库数据</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 把 db-data 命名卷挂载到容器里 MySQL 存储数据的目录</span></span><br><span class=\"line\">      <span class=\"comment\"># 这样数据库数据就不会丢失</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置数据库的环境变量（比如 root 密码，很重要！）</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_ROOT_PASSWORD&#125;</span> <span class=\"comment\"># 从环境变量或 .env 读取 root 密码</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=$&#123;DB_NAME&#125;</span> <span class=\"comment\"># 自动创建的数据库名</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># restart: 重启策略</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># networks: 加入到同一个网络</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 和 app 服务在同一个网络，app 就可以通过主机名 &#x27;db&#x27; 访问它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 数据库的健康检查（也很重要！）</span></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck:</span></span><br><span class=\"line\">    <span class=\"comment\">#   test: [&quot;CMD&quot;, &quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-h&quot;, &quot;localhost&quot;, &quot;-p$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;]</span></span><br><span class=\"line\">    <span class=\"comment\">#   interval: 10s</span></span><br><span class=\"line\">    <span class=\"comment\">#   timeout: 5s</span></span><br><span class=\"line\">    <span class=\"comment\">#   retries: 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在顶层声明命名卷，让 Docker 管理数据存储</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span> <span class=\"comment\"># 声明一个叫 db-data 的命名卷</span></span><br><span class=\"line\">  <span class=\"comment\"># app-logs: # 如果上面 volumes 也用了 app-logs，这里也要声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在顶层声明自定义网络</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend_network:</span> <span class=\"comment\"># 声明一个叫 backend_network 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>"},{"title":"🐳 Docker Compose 结构详解篇（二）：顶层配置（version, volumes, networks）","date":"2025-06-07T02:25:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":59411,"_content":"\n# 🐳 Docker Compose 顶层配置全面解读 - 搞懂 `yml` 文件的“骨架”！\n\n你好呀！欢迎来到 Docker Compose 教程的第二站！上一章我们详细拆解了 `services` 里那些用于配置单个服务的字段。`services` 就像是一份菜单，列出了你的所有菜品（服务），并描述了每道菜怎么做。\n\n但这道菜单本身需要放在一个特定的格式里，并且有时候你需要为这些菜品准备一些“公共资源”，比如一个专门存放食材的冰箱（数据卷）或者一个服务员们内部沟通的网络。\n\n`docker-compose.yml` 文件除了 `services` 之外，顶部通常还有一些其他重要的字段，它们是整个文件的“骨架”，用来定义 Docker Compose 项目的整体结构和一些共享的配置。今天，我们就来学习这些顶层字段：`version`, `volumes`, 和 `networks`。\n\n---\n\n## 🏗️ `version`：告诉 Docker Compose 你用的是哪个“规范”\n\n`version` 字段通常是 `docker-compose.yml` 文件的第一行，它告诉 Docker Compose 解析器，你正在使用哪个版本的 Docker Compose 文件格式规范。不同的版本支持不同的字段和特性。\n\n```yaml\n# version: 指定 Docker Compose 文件格式的版本\nversion: '3.8' # 这是一个常用的版本，支持很多现代特性，比如命名卷和自定义网络\n\n# 你可能会看到其他版本，比如 '2.0', '2.1', '3', '3.1', '3.9' 等等\n# 建议使用较新的稳定版本，比如 '3.8' 或更高\n```\n\n*   **作用**：指定 Docker Compose 文件语法的版本，确保你的配置能被正确解析。\n*   **重要性**：不同的 `version` 支持的字段和语法可能有差异。比如，`volumes` 和 `networks` 在早期版本中写法不同，或者某些高级特性（如 `healthcheck` 的 `start_period`）只在较新的版本中支持。\n*   **选择建议**：通常推荐使用最新的稳定版本，以便使用最新的功能和语法。`3.8` 或 `3.9` 是不错的选择。\n\n---\n\n## 💾 `volumes` (顶层)：声明和管理你的“共享冰箱”或“持久化存储”\n\n在上一章我们讲到 `volumes` 可以在服务内部用于本地路径挂载（Bind Mount）或命名卷挂载。但如果你使用了命名卷，你需要在 `docker-compose.yml` 文件的最**顶层**声明这些命名卷。\n\n顶层声明 `volumes` 的作用是告诉 Docker Compose 你需要创建并管理一个或多个“命名卷”（Named Volumes）。这些命名卷就像是 Docker 管理的一块专门用于存储数据的区域，它的生命周期独立于任何一个容器。\n\n```yaml\n# version 和 services 中间（或者在 services 下面），可以定义顶层 volumes\nversion: '3.8'\n\nservices:\n  # ... 你的服务定义，比如数据库服务 ...\n  db:\n    image: mysql:5.7\n    volumes:\n      # 在服务内部使用顶层声明的命名卷\n      # 把容器里的 /var/lib/mysql 目录（MySQL 存放数据的地方）\n      # 挂载到顶层声明的 'db-data' 这个命名卷上\n      - db-data:/var/lib/mysql\n    # ... 其他 db 配置 ...\n\n# volumes: 在文件的最顶层声明你使用的命名卷\nvolumes:\n  # 声明一个名字叫 'db-data' 的命名卷\n  # Docker Compose 在执行 docker-compose up 时如果发现没有这个命名卷，就会自动创建一个\n  db-data:\n    # 你可以在这里添加一些配置，比如指定驱动或标签\n    # driver: local # 默认就是 local 驱动，通常不用写\n    # labels:\n    #   app: myapp\n    #   type: database-data\n    # 你也可以配置外部卷，但对于初学者，简单声明名字就行了\n    # external: true # 如果这个卷是预先通过 docker volume create 创建好的，用 external: true\n\n  # 你可以声明多个命名卷\n  app-logs:\n    # 这个命名卷可以用来保存应用日志\n    pass\n    # 或者 driver_opts 用于一些高级配置，比如 NFS 挂载等，这里不展开\n\n```\n\n*   **作用**：在 Docker Compose 项目中创建和管理命名卷，用于实现数据的持久化存储。\n*   **与服务内 `volumes` 的区别**：\n    *   **顶层 `volumes`**：用于**声明命名卷**。这些卷由 Docker 自己管理，即使所有使用它们的容器都被删除了，卷本身默认也不会被删除，从而保留数据。\n    *   **服务内 `volumes`**：用于**挂载**（attach）一个卷（无论是命名卷还是本地路径）到容器内部的某个路径。\n*   **流程**：\n    1.  在 `docker-compose.yml` 顶层声明你需要的命名卷（比如 `db-data:`）。\n    2.  在需要使用这个卷的服务内部，通过 `volumes: - 命名卷名:/容器内部路径` 的格式来挂载它（比如 `volumes: - db-data:/var/lib/mysql`）。\n    3.  当你运行 `docker-compose up` 时，如果 `db-data` 这个命名卷不存在，Docker 会自动创建它；如果存在，就直接使用。然后将它挂载到 `db` 服务的 `/var/lib/mysql` 目录。\n*   **适合场景**：\n    *   需要保存数据库数据、文件上传、日志文件等，确保容器删除或更新后数据不丢失。\n    *   需要在同一个 Docker Compose 项目中的不同服务之间共享少量数据（虽然不常见，主要还是用于持久化）。\n\n---\n\n## 🌐 `networks` (顶层)：定义你的“内部通信频道”\n\n就像 `volumes` 一样，`networks` 也可以在服务内部指定（让服务加入到某个网络），但更常见、更推荐的方式是在 `docker-compose.yml` 的**顶层**定义你自己的自定义网络。\n\n顶层定义 `networks` 的作用是创建一个或多个自定义的网络。Docker Compose 会把这些网络创建出来，然后你可以在 `services` 部分指定哪些服务要加入到哪个网络。\n\n**为什么需要自定义网络？**\n\n默认情况下，Docker Compose 会为你的项目创建一个默认的网络（通常名字是 `项目目录名_default`）。这个默认网络已经可以让你项目中的服务通过服务名互相访问了。\n\n但是，自定义网络提供了更好的隔离性和灵活性：\n\n1.  **隔离性**：你可以创建不同的网络，把不同组的服务放在各自的网络里。这样，只有连接到同一个网络的服才能直接通信，提高了安全性。\n2.  **清晰性**：通过自定义网络名，你可以更清晰地表达服务之间的通信关系。\n3.  **控制**：可以配置网络的驱动、IP 地址范围等高级设置（尽管基础使用时通常不需要）。\n\n```yaml\n# version 和 services 中间（或者在 services 下面），可以定义顶层 networks\nversion: '3.8'\n\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-frontend\n    # networks: 指定这个服务要连接到哪些网络\n    networks:\n      - frontend_network # 加入到 frontend_network\n      # 如果前端也需要直接访问后端，可以也加入 backend_network\n      # - backend_network\n\n  # 定义一个后端服务\n  backend:\n    image: my-backend\n    networks:\n      - backend_network # 加入到 backend_network\n      # 如果后端需要访问数据库，且数据库也在 backend_network，这里就这样写\n\n  # 定义一个数据库服务\n  db:\n    image: mysql:5.7\n    networks:\n      - backend_network # 加入到 backend_network\n\n# networks: 在文件的最顶层声明你使用的自定义网络\nnetworks:\n  # 声明一个名字叫 'frontend_network' 的网络\n  frontend_network:\n    # driver: bridge 是默认的网络类型，通常不用写，表示使用桥接网络\n    # driver: bridge\n\n  # 声明一个名字叫 'backend_network' 的网络\n  backend_network:\n    # driver: bridge # 同样是默认驱动，通常不用写\n\n```\n\n*   **作用**：创建自定义网络，让指定的容器能够互相发现和通信。\n*   **服务发现**：连接到**同一个**自定义网络的容器，可以通过**服务名**作为主机名互相访问。\n    *   比如，上面的 `backend` 服务可以通过 `db` 作为主机名连接到数据库服务，因为它俩都在 `backend_network` 里。\n    *   如果 `frontend` 也在 `backend_network` 里，它就可以通过 `backend` 作为主机名访问后端服务。\n*   **与服务内 `networks` 的区别**：\n    *   **顶层 `networks`**：用于**声明自定义网络**。Docker Compose 会负责创建这些网络。\n    *   **服务内 `networks`**：用于让服务**加入**（connect）到顶层声明的（或默认的）网络中。\n*   **流程**：\n    1.  在 `docker-compose.yml` 顶层声明你需要的自定义网络（比如 `backend_network:`）。\n    2.  在需要加入这个网络的服务内部，通过 `networks: - 网络名` 的格式来连接它（比如 `networks: - backend_network`）。\n    3.  当你运行 `docker-compose up` 时，Docker Compose 会创建 `backend_network`（如果不存在），然后将 `backend` 和 `db` 这两个服务的容器都连接到这个网络。\n*   **适合场景**：\n    *   你的项目包含多个服务，需要互相通信（这是最常见场景）。\n    *   需要将不同的服务组进行网络隔离。\n    *   需要更精细地控制服务间的通信路径。\n\n---\n\n## ✨ 组合使用：一个更完整的 `docker-compose.yml` 结构\n\n现在我们知道了顶层 `version`, `volumes`, `networks` 以及服务内部的各种配置，一个常见的 `docker-compose.yml` 文件结构就会像这样：\n\n```yaml\n# 1. version: 文件格式版本，必须在第一行\nversion: '3.8'\n\n# 2. services: 定义项目包含的所有服务（这是核心部分，通常最长）\nservices:\n  # app 服务（比如你的后端应用）\n  app:\n    build: # 从本地代码构建\n      context: .\n      dockerfile: Dockerfile\n    image: myapp:latest # 构建后的镜像名\n    ports:\n      - \"80:3000\" # 外部 80 端口映射到容器内部 3000 端口\n    volumes:\n      - .:/app # 本地代码挂载到容器，方便开发热更新\n      # - app-logs:/app/logs # 使用顶层声明的命名卷挂载日志目录\n    environment:\n      - NODE_ENV=development\n      - DB_HOST=db # 依赖 db 服务，通过服务名访问\n      # 其他环境变量...\n    depends_on:\n      # 依赖 db 服务，确保 db 先启动\n      # 更好的做法是使用 condition: service_healthy，但需要 db 配置 healthcheck\n      - db\n    restart: unless-stopped # 异常退出时自动重启\n    networks:\n      - app_network # 加入 app_network，用于和 db 通信\n\n  # db 服务（比如数据库）\n  db:\n    image: mysql:5.7 # 使用官方 MySQL 5.7 镜像\n    # 指定容器名称，可选，方便区分\n    # container_name: my_mysql_db\n    volumes:\n      # 使用顶层声明的命名卷，持久化数据库数据\n      - db_data:/var/lib/mysql\n    environment:\n      - MYSQL_ROOT_PASSWORD=mysecretpassword\n      - MYSQL_DATABASE=mydatabase\n      # 其他环境变量...\n    restart: unless-stopped\n    networks:\n      - app_network # 加入 app_network，和 app 服务在同一个网络\n\n# 3. volumes: 在顶层声明命名卷，用于数据持久化\nvolumes:\n  db_data: # 声明一个叫 db_data 的命名卷\n\n  # app_logs: # 如果上面 app 服务使用了 app-logs 命名卷，这里也要声明\n\n# 4. networks: 在顶层声明自定义网络，用于服务间通信\nnetworks:\n  app_network: # 声明一个叫 app_network 的自定义网络\n    # driver: bridge 是默认类型，通常不用写\n```\n\n这个例子展示了 `version`, `services`, `volumes`, `networks` 在一个文件中的组织方式。`services` 是核心，但 `version`, `volumes` 和 `networks` 提供了重要的全局配置和资源管理能力。\n\n---\n\n**本章小结**\n\n现在你已经了解了 `docker-compose.yml` 文件的顶层结构：\n*   `version` 定义了文件的规范版本。\n*   顶层 `volumes` 声明了 Docker 管理的持久化数据存储区域（命名卷）。\n*   顶层 `networks` 声明了自定义网络，用于服务间的隔离和通信。\n\n搞清楚这些顶层配置，你就对 `docker-compose.yml` 的整体结构有了清晰的认识。接下来，最激动人心的部分来了：**如何真正运行起这个文件里定义的服务？** 在下一章，我们将学习 `docker-compose up`, `down`, `logs` 等最常用的命令，把你写好的配置变成眼前运行的容器！敬请期待！\n","source":"_posts/Docker/Docker Compose 字段详解篇（二）：volumes、networks、configs、secrets.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 结构详解篇（二）：顶层配置（version, volumes, networks）\"\ndate: '2025-06-07 10:25'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 59411\n---\n\n# 🐳 Docker Compose 顶层配置全面解读 - 搞懂 `yml` 文件的“骨架”！\n\n你好呀！欢迎来到 Docker Compose 教程的第二站！上一章我们详细拆解了 `services` 里那些用于配置单个服务的字段。`services` 就像是一份菜单，列出了你的所有菜品（服务），并描述了每道菜怎么做。\n\n但这道菜单本身需要放在一个特定的格式里，并且有时候你需要为这些菜品准备一些“公共资源”，比如一个专门存放食材的冰箱（数据卷）或者一个服务员们内部沟通的网络。\n\n`docker-compose.yml` 文件除了 `services` 之外，顶部通常还有一些其他重要的字段，它们是整个文件的“骨架”，用来定义 Docker Compose 项目的整体结构和一些共享的配置。今天，我们就来学习这些顶层字段：`version`, `volumes`, 和 `networks`。\n\n---\n\n## 🏗️ `version`：告诉 Docker Compose 你用的是哪个“规范”\n\n`version` 字段通常是 `docker-compose.yml` 文件的第一行，它告诉 Docker Compose 解析器，你正在使用哪个版本的 Docker Compose 文件格式规范。不同的版本支持不同的字段和特性。\n\n```yaml\n# version: 指定 Docker Compose 文件格式的版本\nversion: '3.8' # 这是一个常用的版本，支持很多现代特性，比如命名卷和自定义网络\n\n# 你可能会看到其他版本，比如 '2.0', '2.1', '3', '3.1', '3.9' 等等\n# 建议使用较新的稳定版本，比如 '3.8' 或更高\n```\n\n*   **作用**：指定 Docker Compose 文件语法的版本，确保你的配置能被正确解析。\n*   **重要性**：不同的 `version` 支持的字段和语法可能有差异。比如，`volumes` 和 `networks` 在早期版本中写法不同，或者某些高级特性（如 `healthcheck` 的 `start_period`）只在较新的版本中支持。\n*   **选择建议**：通常推荐使用最新的稳定版本，以便使用最新的功能和语法。`3.8` 或 `3.9` 是不错的选择。\n\n---\n\n## 💾 `volumes` (顶层)：声明和管理你的“共享冰箱”或“持久化存储”\n\n在上一章我们讲到 `volumes` 可以在服务内部用于本地路径挂载（Bind Mount）或命名卷挂载。但如果你使用了命名卷，你需要在 `docker-compose.yml` 文件的最**顶层**声明这些命名卷。\n\n顶层声明 `volumes` 的作用是告诉 Docker Compose 你需要创建并管理一个或多个“命名卷”（Named Volumes）。这些命名卷就像是 Docker 管理的一块专门用于存储数据的区域，它的生命周期独立于任何一个容器。\n\n```yaml\n# version 和 services 中间（或者在 services 下面），可以定义顶层 volumes\nversion: '3.8'\n\nservices:\n  # ... 你的服务定义，比如数据库服务 ...\n  db:\n    image: mysql:5.7\n    volumes:\n      # 在服务内部使用顶层声明的命名卷\n      # 把容器里的 /var/lib/mysql 目录（MySQL 存放数据的地方）\n      # 挂载到顶层声明的 'db-data' 这个命名卷上\n      - db-data:/var/lib/mysql\n    # ... 其他 db 配置 ...\n\n# volumes: 在文件的最顶层声明你使用的命名卷\nvolumes:\n  # 声明一个名字叫 'db-data' 的命名卷\n  # Docker Compose 在执行 docker-compose up 时如果发现没有这个命名卷，就会自动创建一个\n  db-data:\n    # 你可以在这里添加一些配置，比如指定驱动或标签\n    # driver: local # 默认就是 local 驱动，通常不用写\n    # labels:\n    #   app: myapp\n    #   type: database-data\n    # 你也可以配置外部卷，但对于初学者，简单声明名字就行了\n    # external: true # 如果这个卷是预先通过 docker volume create 创建好的，用 external: true\n\n  # 你可以声明多个命名卷\n  app-logs:\n    # 这个命名卷可以用来保存应用日志\n    pass\n    # 或者 driver_opts 用于一些高级配置，比如 NFS 挂载等，这里不展开\n\n```\n\n*   **作用**：在 Docker Compose 项目中创建和管理命名卷，用于实现数据的持久化存储。\n*   **与服务内 `volumes` 的区别**：\n    *   **顶层 `volumes`**：用于**声明命名卷**。这些卷由 Docker 自己管理，即使所有使用它们的容器都被删除了，卷本身默认也不会被删除，从而保留数据。\n    *   **服务内 `volumes`**：用于**挂载**（attach）一个卷（无论是命名卷还是本地路径）到容器内部的某个路径。\n*   **流程**：\n    1.  在 `docker-compose.yml` 顶层声明你需要的命名卷（比如 `db-data:`）。\n    2.  在需要使用这个卷的服务内部，通过 `volumes: - 命名卷名:/容器内部路径` 的格式来挂载它（比如 `volumes: - db-data:/var/lib/mysql`）。\n    3.  当你运行 `docker-compose up` 时，如果 `db-data` 这个命名卷不存在，Docker 会自动创建它；如果存在，就直接使用。然后将它挂载到 `db` 服务的 `/var/lib/mysql` 目录。\n*   **适合场景**：\n    *   需要保存数据库数据、文件上传、日志文件等，确保容器删除或更新后数据不丢失。\n    *   需要在同一个 Docker Compose 项目中的不同服务之间共享少量数据（虽然不常见，主要还是用于持久化）。\n\n---\n\n## 🌐 `networks` (顶层)：定义你的“内部通信频道”\n\n就像 `volumes` 一样，`networks` 也可以在服务内部指定（让服务加入到某个网络），但更常见、更推荐的方式是在 `docker-compose.yml` 的**顶层**定义你自己的自定义网络。\n\n顶层定义 `networks` 的作用是创建一个或多个自定义的网络。Docker Compose 会把这些网络创建出来，然后你可以在 `services` 部分指定哪些服务要加入到哪个网络。\n\n**为什么需要自定义网络？**\n\n默认情况下，Docker Compose 会为你的项目创建一个默认的网络（通常名字是 `项目目录名_default`）。这个默认网络已经可以让你项目中的服务通过服务名互相访问了。\n\n但是，自定义网络提供了更好的隔离性和灵活性：\n\n1.  **隔离性**：你可以创建不同的网络，把不同组的服务放在各自的网络里。这样，只有连接到同一个网络的服才能直接通信，提高了安全性。\n2.  **清晰性**：通过自定义网络名，你可以更清晰地表达服务之间的通信关系。\n3.  **控制**：可以配置网络的驱动、IP 地址范围等高级设置（尽管基础使用时通常不需要）。\n\n```yaml\n# version 和 services 中间（或者在 services 下面），可以定义顶层 networks\nversion: '3.8'\n\nservices:\n  # 定义一个前端服务\n  frontend:\n    image: my-frontend\n    # networks: 指定这个服务要连接到哪些网络\n    networks:\n      - frontend_network # 加入到 frontend_network\n      # 如果前端也需要直接访问后端，可以也加入 backend_network\n      # - backend_network\n\n  # 定义一个后端服务\n  backend:\n    image: my-backend\n    networks:\n      - backend_network # 加入到 backend_network\n      # 如果后端需要访问数据库，且数据库也在 backend_network，这里就这样写\n\n  # 定义一个数据库服务\n  db:\n    image: mysql:5.7\n    networks:\n      - backend_network # 加入到 backend_network\n\n# networks: 在文件的最顶层声明你使用的自定义网络\nnetworks:\n  # 声明一个名字叫 'frontend_network' 的网络\n  frontend_network:\n    # driver: bridge 是默认的网络类型，通常不用写，表示使用桥接网络\n    # driver: bridge\n\n  # 声明一个名字叫 'backend_network' 的网络\n  backend_network:\n    # driver: bridge # 同样是默认驱动，通常不用写\n\n```\n\n*   **作用**：创建自定义网络，让指定的容器能够互相发现和通信。\n*   **服务发现**：连接到**同一个**自定义网络的容器，可以通过**服务名**作为主机名互相访问。\n    *   比如，上面的 `backend` 服务可以通过 `db` 作为主机名连接到数据库服务，因为它俩都在 `backend_network` 里。\n    *   如果 `frontend` 也在 `backend_network` 里，它就可以通过 `backend` 作为主机名访问后端服务。\n*   **与服务内 `networks` 的区别**：\n    *   **顶层 `networks`**：用于**声明自定义网络**。Docker Compose 会负责创建这些网络。\n    *   **服务内 `networks`**：用于让服务**加入**（connect）到顶层声明的（或默认的）网络中。\n*   **流程**：\n    1.  在 `docker-compose.yml` 顶层声明你需要的自定义网络（比如 `backend_network:`）。\n    2.  在需要加入这个网络的服务内部，通过 `networks: - 网络名` 的格式来连接它（比如 `networks: - backend_network`）。\n    3.  当你运行 `docker-compose up` 时，Docker Compose 会创建 `backend_network`（如果不存在），然后将 `backend` 和 `db` 这两个服务的容器都连接到这个网络。\n*   **适合场景**：\n    *   你的项目包含多个服务，需要互相通信（这是最常见场景）。\n    *   需要将不同的服务组进行网络隔离。\n    *   需要更精细地控制服务间的通信路径。\n\n---\n\n## ✨ 组合使用：一个更完整的 `docker-compose.yml` 结构\n\n现在我们知道了顶层 `version`, `volumes`, `networks` 以及服务内部的各种配置，一个常见的 `docker-compose.yml` 文件结构就会像这样：\n\n```yaml\n# 1. version: 文件格式版本，必须在第一行\nversion: '3.8'\n\n# 2. services: 定义项目包含的所有服务（这是核心部分，通常最长）\nservices:\n  # app 服务（比如你的后端应用）\n  app:\n    build: # 从本地代码构建\n      context: .\n      dockerfile: Dockerfile\n    image: myapp:latest # 构建后的镜像名\n    ports:\n      - \"80:3000\" # 外部 80 端口映射到容器内部 3000 端口\n    volumes:\n      - .:/app # 本地代码挂载到容器，方便开发热更新\n      # - app-logs:/app/logs # 使用顶层声明的命名卷挂载日志目录\n    environment:\n      - NODE_ENV=development\n      - DB_HOST=db # 依赖 db 服务，通过服务名访问\n      # 其他环境变量...\n    depends_on:\n      # 依赖 db 服务，确保 db 先启动\n      # 更好的做法是使用 condition: service_healthy，但需要 db 配置 healthcheck\n      - db\n    restart: unless-stopped # 异常退出时自动重启\n    networks:\n      - app_network # 加入 app_network，用于和 db 通信\n\n  # db 服务（比如数据库）\n  db:\n    image: mysql:5.7 # 使用官方 MySQL 5.7 镜像\n    # 指定容器名称，可选，方便区分\n    # container_name: my_mysql_db\n    volumes:\n      # 使用顶层声明的命名卷，持久化数据库数据\n      - db_data:/var/lib/mysql\n    environment:\n      - MYSQL_ROOT_PASSWORD=mysecretpassword\n      - MYSQL_DATABASE=mydatabase\n      # 其他环境变量...\n    restart: unless-stopped\n    networks:\n      - app_network # 加入 app_network，和 app 服务在同一个网络\n\n# 3. volumes: 在顶层声明命名卷，用于数据持久化\nvolumes:\n  db_data: # 声明一个叫 db_data 的命名卷\n\n  # app_logs: # 如果上面 app 服务使用了 app-logs 命名卷，这里也要声明\n\n# 4. networks: 在顶层声明自定义网络，用于服务间通信\nnetworks:\n  app_network: # 声明一个叫 app_network 的自定义网络\n    # driver: bridge 是默认类型，通常不用写\n```\n\n这个例子展示了 `version`, `services`, `volumes`, `networks` 在一个文件中的组织方式。`services` 是核心，但 `version`, `volumes` 和 `networks` 提供了重要的全局配置和资源管理能力。\n\n---\n\n**本章小结**\n\n现在你已经了解了 `docker-compose.yml` 文件的顶层结构：\n*   `version` 定义了文件的规范版本。\n*   顶层 `volumes` 声明了 Docker 管理的持久化数据存储区域（命名卷）。\n*   顶层 `networks` 声明了自定义网络，用于服务间的隔离和通信。\n\n搞清楚这些顶层配置，你就对 `docker-compose.yml` 的整体结构有了清晰的认识。接下来，最激动人心的部分来了：**如何真正运行起这个文件里定义的服务？** 在下一章，我们将学习 `docker-compose up`, `down`, `logs` 等最常用的命令，把你写好的配置变成眼前运行的容器！敬请期待！\n","slug":"Docker/Docker Compose 字段详解篇（二）：volumes、networks、configs、secrets","published":1,"updated":"2025-06-07T15:58:53.662Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww40009pkrc0kmm4d49","content":"<h1 id=\"🐳-Docker-Compose-顶层配置全面解读-搞懂-yml-文件的“骨架”！\"><a href=\"#🐳-Docker-Compose-顶层配置全面解读-搞懂-yml-文件的“骨架”！\" class=\"headerlink\" title=\"🐳 Docker Compose 顶层配置全面解读 - 搞懂 yml 文件的“骨架”！\"></a>🐳 Docker Compose 顶层配置全面解读 - 搞懂 <code>yml</code> 文件的“骨架”！</h1><p>你好呀！欢迎来到 Docker Compose 教程的第二站！上一章我们详细拆解了 <code>services</code> 里那些用于配置单个服务的字段。<code>services</code> 就像是一份菜单，列出了你的所有菜品（服务），并描述了每道菜怎么做。</p>\n<p>但这道菜单本身需要放在一个特定的格式里，并且有时候你需要为这些菜品准备一些“公共资源”，比如一个专门存放食材的冰箱（数据卷）或者一个服务员们内部沟通的网络。</p>\n<p><code>docker-compose.yml</code> 文件除了 <code>services</code> 之外，顶部通常还有一些其他重要的字段，它们是整个文件的“骨架”，用来定义 Docker Compose 项目的整体结构和一些共享的配置。今天，我们就来学习这些顶层字段：<code>version</code>, <code>volumes</code>, 和 <code>networks</code>。</p>\n<hr>\n<h2 id=\"🏗️-version：告诉-Docker-Compose-你用的是哪个“规范”\"><a href=\"#🏗️-version：告诉-Docker-Compose-你用的是哪个“规范”\" class=\"headerlink\" title=\"🏗️ version：告诉 Docker Compose 你用的是哪个“规范”\"></a>🏗️ <code>version</code>：告诉 Docker Compose 你用的是哪个“规范”</h2><p><code>version</code> 字段通常是 <code>docker-compose.yml</code> 文件的第一行，它告诉 Docker Compose 解析器，你正在使用哪个版本的 Docker Compose 文件格式规范。不同的版本支持不同的字段和特性。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version: 指定 Docker Compose 文件格式的版本</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 这是一个常用的版本，支持很多现代特性，比如命名卷和自定义网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你可能会看到其他版本，比如 &#x27;2.0&#x27;, &#x27;2.1&#x27;, &#x27;3&#x27;, &#x27;3.1&#x27;, &#x27;3.9&#x27; 等等</span></span><br><span class=\"line\"><span class=\"comment\"># 建议使用较新的稳定版本，比如 &#x27;3.8&#x27; 或更高</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：指定 Docker Compose 文件语法的版本，确保你的配置能被正确解析。</li>\n<li><strong>重要性</strong>：不同的 <code>version</code> 支持的字段和语法可能有差异。比如，<code>volumes</code> 和 <code>networks</code> 在早期版本中写法不同，或者某些高级特性（如 <code>healthcheck</code> 的 <code>start_period</code>）只在较新的版本中支持。</li>\n<li><strong>选择建议</strong>：通常推荐使用最新的稳定版本，以便使用最新的功能和语法。<code>3.8</code> 或 <code>3.9</code> 是不错的选择。</li>\n</ul>\n<hr>\n<h2 id=\"💾-volumes-顶层-：声明和管理你的“共享冰箱”或“持久化存储”\"><a href=\"#💾-volumes-顶层-：声明和管理你的“共享冰箱”或“持久化存储”\" class=\"headerlink\" title=\"💾 volumes (顶层)：声明和管理你的“共享冰箱”或“持久化存储”\"></a>💾 <code>volumes</code> (顶层)：声明和管理你的“共享冰箱”或“持久化存储”</h2><p>在上一章我们讲到 <code>volumes</code> 可以在服务内部用于本地路径挂载（Bind Mount）或命名卷挂载。但如果你使用了命名卷，你需要在 <code>docker-compose.yml</code> 文件的最<strong>顶层</strong>声明这些命名卷。</p>\n<p>顶层声明 <code>volumes</code> 的作用是告诉 Docker Compose 你需要创建并管理一个或多个“命名卷”（Named Volumes）。这些命名卷就像是 Docker 管理的一块专门用于存储数据的区域，它的生命周期独立于任何一个容器。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version 和 services 中间（或者在 services 下面），可以定义顶层 volumes</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># ... 你的服务定义，比如数据库服务 ...</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 在服务内部使用顶层声明的命名卷</span></span><br><span class=\"line\">      <span class=\"comment\"># 把容器里的 /var/lib/mysql 目录（MySQL 存放数据的地方）</span></span><br><span class=\"line\">      <span class=\"comment\"># 挂载到顶层声明的 &#x27;db-data&#x27; 这个命名卷上</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在文件的最顶层声明你使用的命名卷</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;db-data&#x27; 的命名卷</span></span><br><span class=\"line\">  <span class=\"comment\"># Docker Compose 在执行 docker-compose up 时如果发现没有这个命名卷，就会自动创建一个</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"comment\"># 你可以在这里添加一些配置，比如指定驱动或标签</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: local # 默认就是 local 驱动，通常不用写</span></span><br><span class=\"line\">    <span class=\"comment\"># labels:</span></span><br><span class=\"line\">    <span class=\"comment\">#   app: myapp</span></span><br><span class=\"line\">    <span class=\"comment\">#   type: database-data</span></span><br><span class=\"line\">    <span class=\"comment\"># 你也可以配置外部卷，但对于初学者，简单声明名字就行了</span></span><br><span class=\"line\">    <span class=\"comment\"># external: true # 如果这个卷是预先通过 docker volume create 创建好的，用 external: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 你可以声明多个命名卷</span></span><br><span class=\"line\">  <span class=\"attr\">app-logs:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个命名卷可以用来保存应用日志</span></span><br><span class=\"line\">    <span class=\"string\">pass</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者 driver_opts 用于一些高级配置，比如 NFS 挂载等，这里不展开</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：在 Docker Compose 项目中创建和管理命名卷，用于实现数据的持久化存储。</li>\n<li><strong>与服务内 <code>volumes</code> 的区别</strong>：<ul>\n<li><strong>顶层 <code>volumes</code></strong>：用于<strong>声明命名卷</strong>。这些卷由 Docker 自己管理，即使所有使用它们的容器都被删除了，卷本身默认也不会被删除，从而保留数据。</li>\n<li><strong>服务内 <code>volumes</code></strong>：用于<strong>挂载</strong>（attach）一个卷（无论是命名卷还是本地路径）到容器内部的某个路径。</li>\n</ul>\n</li>\n<li><strong>流程</strong>：<ol>\n<li>在 <code>docker-compose.yml</code> 顶层声明你需要的命名卷（比如 <code>db-data:</code>）。</li>\n<li>在需要使用这个卷的服务内部，通过 <code>volumes: - 命名卷名:/容器内部路径</code> 的格式来挂载它（比如 <code>volumes: - db-data:/var/lib/mysql</code>）。</li>\n<li>当你运行 <code>docker-compose up</code> 时，如果 <code>db-data</code> 这个命名卷不存在，Docker 会自动创建它；如果存在，就直接使用。然后将它挂载到 <code>db</code> 服务的 <code>/var/lib/mysql</code> 目录。</li>\n</ol>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>需要保存数据库数据、文件上传、日志文件等，确保容器删除或更新后数据不丢失。</li>\n<li>需要在同一个 Docker Compose 项目中的不同服务之间共享少量数据（虽然不常见，主要还是用于持久化）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌐-networks-顶层-：定义你的“内部通信频道”\"><a href=\"#🌐-networks-顶层-：定义你的“内部通信频道”\" class=\"headerlink\" title=\"🌐 networks (顶层)：定义你的“内部通信频道”\"></a>🌐 <code>networks</code> (顶层)：定义你的“内部通信频道”</h2><p>就像 <code>volumes</code> 一样，<code>networks</code> 也可以在服务内部指定（让服务加入到某个网络），但更常见、更推荐的方式是在 <code>docker-compose.yml</code> 的<strong>顶层</strong>定义你自己的自定义网络。</p>\n<p>顶层定义 <code>networks</code> 的作用是创建一个或多个自定义的网络。Docker Compose 会把这些网络创建出来，然后你可以在 <code>services</code> 部分指定哪些服务要加入到哪个网络。</p>\n<p><strong>为什么需要自定义网络？</strong></p>\n<p>默认情况下，Docker Compose 会为你的项目创建一个默认的网络（通常名字是 <code>项目目录名_default</code>）。这个默认网络已经可以让你项目中的服务通过服务名互相访问了。</p>\n<p>但是，自定义网络提供了更好的隔离性和灵活性：</p>\n<ol>\n<li><strong>隔离性</strong>：你可以创建不同的网络，把不同组的服务放在各自的网络里。这样，只有连接到同一个网络的服才能直接通信，提高了安全性。</li>\n<li><strong>清晰性</strong>：通过自定义网络名，你可以更清晰地表达服务之间的通信关系。</li>\n<li><strong>控制</strong>：可以配置网络的驱动、IP 地址范围等高级设置（尽管基础使用时通常不需要）。</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version 和 services 中间（或者在 services 下面），可以定义顶层 networks</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend</span></span><br><span class=\"line\">    <span class=\"comment\"># networks: 指定这个服务要连接到哪些网络</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">frontend_network</span> <span class=\"comment\"># 加入到 frontend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果前端也需要直接访问后端，可以也加入 backend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># - backend_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到 backend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果后端需要访问数据库，且数据库也在 backend_network，这里就这样写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个数据库服务</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到 backend_network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在文件的最顶层声明你使用的自定义网络</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;frontend_network&#x27; 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">frontend_network:</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认的网络类型，通常不用写，表示使用桥接网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;backend_network&#x27; 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">backend_network:</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge # 同样是默认驱动，通常不用写</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：创建自定义网络，让指定的容器能够互相发现和通信。</li>\n<li><strong>服务发现</strong>：连接到<strong>同一个</strong>自定义网络的容器，可以通过<strong>服务名</strong>作为主机名互相访问。<ul>\n<li>比如，上面的 <code>backend</code> 服务可以通过 <code>db</code> 作为主机名连接到数据库服务，因为它俩都在 <code>backend_network</code> 里。</li>\n<li>如果 <code>frontend</code> 也在 <code>backend_network</code> 里，它就可以通过 <code>backend</code> 作为主机名访问后端服务。</li>\n</ul>\n</li>\n<li><strong>与服务内 <code>networks</code> 的区别</strong>：<ul>\n<li><strong>顶层 <code>networks</code></strong>：用于<strong>声明自定义网络</strong>。Docker Compose 会负责创建这些网络。</li>\n<li><strong>服务内 <code>networks</code></strong>：用于让服务<strong>加入</strong>（connect）到顶层声明的（或默认的）网络中。</li>\n</ul>\n</li>\n<li><strong>流程</strong>：<ol>\n<li>在 <code>docker-compose.yml</code> 顶层声明你需要的自定义网络（比如 <code>backend_network:</code>）。</li>\n<li>在需要加入这个网络的服务内部，通过 <code>networks: - 网络名</code> 的格式来连接它（比如 <code>networks: - backend_network</code>）。</li>\n<li>当你运行 <code>docker-compose up</code> 时，Docker Compose 会创建 <code>backend_network</code>（如果不存在），然后将 <code>backend</code> 和 <code>db</code> 这两个服务的容器都连接到这个网络。</li>\n</ol>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你的项目包含多个服务，需要互相通信（这是最常见场景）。</li>\n<li>需要将不同的服务组进行网络隔离。</li>\n<li>需要更精细地控制服务间的通信路径。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"✨-组合使用：一个更完整的-docker-compose-yml-结构\"><a href=\"#✨-组合使用：一个更完整的-docker-compose-yml-结构\" class=\"headerlink\" title=\"✨ 组合使用：一个更完整的 docker-compose.yml 结构\"></a>✨ 组合使用：一个更完整的 <code>docker-compose.yml</code> 结构</h2><p>现在我们知道了顶层 <code>version</code>, <code>volumes</code>, <code>networks</code> 以及服务内部的各种配置，一个常见的 <code>docker-compose.yml</code> 文件结构就会像这样：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. version: 文件格式版本，必须在第一行</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. services: 定义项目包含的所有服务（这是核心部分，通常最长）</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># app 服务（比如你的后端应用）</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"comment\"># 从本地代码构建</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span> <span class=\"comment\"># 构建后的镜像名</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span> <span class=\"comment\"># 外部 80 端口映射到容器内部 3000 端口</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span> <span class=\"comment\"># 本地代码挂载到容器，方便开发热更新</span></span><br><span class=\"line\">      <span class=\"comment\"># - app-logs:/app/logs # 使用顶层声明的命名卷挂载日志目录</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span> <span class=\"comment\"># 依赖 db 服务，通过服务名访问</span></span><br><span class=\"line\">      <span class=\"comment\"># 其他环境变量...</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 依赖 db 服务，确保 db 先启动</span></span><br><span class=\"line\">      <span class=\"comment\"># 更好的做法是使用 condition: service_healthy，但需要 db 配置 healthcheck</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入 app_network，用于和 db 通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># db 服务（比如数据库）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用官方 MySQL 5.7 镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># 指定容器名称，可选，方便区分</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: my_mysql_db</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 使用顶层声明的命名卷，持久化数据库数据</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=mysecretpassword</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\">      <span class=\"comment\"># 其他环境变量...</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入 app_network，和 app 服务在同一个网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. volumes: 在顶层声明命名卷，用于数据持久化</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># 声明一个叫 db_data 的命名卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># app_logs: # 如果上面 app 服务使用了 app-logs 命名卷，这里也要声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. networks: 在顶层声明自定义网络，用于服务间通信</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 声明一个叫 app_network 的自定义网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子展示了 <code>version</code>, <code>services</code>, <code>volumes</code>, <code>networks</code> 在一个文件中的组织方式。<code>services</code> 是核心，但 <code>version</code>, <code>volumes</code> 和 <code>networks</code> 提供了重要的全局配置和资源管理能力。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>现在你已经了解了 <code>docker-compose.yml</code> 文件的顶层结构：</p>\n<ul>\n<li><code>version</code> 定义了文件的规范版本。</li>\n<li>顶层 <code>volumes</code> 声明了 Docker 管理的持久化数据存储区域（命名卷）。</li>\n<li>顶层 <code>networks</code> 声明了自定义网络，用于服务间的隔离和通信。</li>\n</ul>\n<p>搞清楚这些顶层配置，你就对 <code>docker-compose.yml</code> 的整体结构有了清晰的认识。接下来，最激动人心的部分来了：<strong>如何真正运行起这个文件里定义的服务？</strong> 在下一章，我们将学习 <code>docker-compose up</code>, <code>down</code>, <code>logs</code> 等最常用的命令，把你写好的配置变成眼前运行的容器！敬请期待！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-Docker-Compose-顶层配置全面解读-搞懂-yml-文件的“骨架”！\"><a href=\"#🐳-Docker-Compose-顶层配置全面解读-搞懂-yml-文件的“骨架”！\" class=\"headerlink\" title=\"🐳 Docker Compose 顶层配置全面解读 - 搞懂 yml 文件的“骨架”！\"></a>🐳 Docker Compose 顶层配置全面解读 - 搞懂 <code>yml</code> 文件的“骨架”！</h1><p>你好呀！欢迎来到 Docker Compose 教程的第二站！上一章我们详细拆解了 <code>services</code> 里那些用于配置单个服务的字段。<code>services</code> 就像是一份菜单，列出了你的所有菜品（服务），并描述了每道菜怎么做。</p>\n<p>但这道菜单本身需要放在一个特定的格式里，并且有时候你需要为这些菜品准备一些“公共资源”，比如一个专门存放食材的冰箱（数据卷）或者一个服务员们内部沟通的网络。</p>\n<p><code>docker-compose.yml</code> 文件除了 <code>services</code> 之外，顶部通常还有一些其他重要的字段，它们是整个文件的“骨架”，用来定义 Docker Compose 项目的整体结构和一些共享的配置。今天，我们就来学习这些顶层字段：<code>version</code>, <code>volumes</code>, 和 <code>networks</code>。</p>\n<hr>\n<h2 id=\"🏗️-version：告诉-Docker-Compose-你用的是哪个“规范”\"><a href=\"#🏗️-version：告诉-Docker-Compose-你用的是哪个“规范”\" class=\"headerlink\" title=\"🏗️ version：告诉 Docker Compose 你用的是哪个“规范”\"></a>🏗️ <code>version</code>：告诉 Docker Compose 你用的是哪个“规范”</h2><p><code>version</code> 字段通常是 <code>docker-compose.yml</code> 文件的第一行，它告诉 Docker Compose 解析器，你正在使用哪个版本的 Docker Compose 文件格式规范。不同的版本支持不同的字段和特性。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version: 指定 Docker Compose 文件格式的版本</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 这是一个常用的版本，支持很多现代特性，比如命名卷和自定义网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你可能会看到其他版本，比如 &#x27;2.0&#x27;, &#x27;2.1&#x27;, &#x27;3&#x27;, &#x27;3.1&#x27;, &#x27;3.9&#x27; 等等</span></span><br><span class=\"line\"><span class=\"comment\"># 建议使用较新的稳定版本，比如 &#x27;3.8&#x27; 或更高</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：指定 Docker Compose 文件语法的版本，确保你的配置能被正确解析。</li>\n<li><strong>重要性</strong>：不同的 <code>version</code> 支持的字段和语法可能有差异。比如，<code>volumes</code> 和 <code>networks</code> 在早期版本中写法不同，或者某些高级特性（如 <code>healthcheck</code> 的 <code>start_period</code>）只在较新的版本中支持。</li>\n<li><strong>选择建议</strong>：通常推荐使用最新的稳定版本，以便使用最新的功能和语法。<code>3.8</code> 或 <code>3.9</code> 是不错的选择。</li>\n</ul>\n<hr>\n<h2 id=\"💾-volumes-顶层-：声明和管理你的“共享冰箱”或“持久化存储”\"><a href=\"#💾-volumes-顶层-：声明和管理你的“共享冰箱”或“持久化存储”\" class=\"headerlink\" title=\"💾 volumes (顶层)：声明和管理你的“共享冰箱”或“持久化存储”\"></a>💾 <code>volumes</code> (顶层)：声明和管理你的“共享冰箱”或“持久化存储”</h2><p>在上一章我们讲到 <code>volumes</code> 可以在服务内部用于本地路径挂载（Bind Mount）或命名卷挂载。但如果你使用了命名卷，你需要在 <code>docker-compose.yml</code> 文件的最<strong>顶层</strong>声明这些命名卷。</p>\n<p>顶层声明 <code>volumes</code> 的作用是告诉 Docker Compose 你需要创建并管理一个或多个“命名卷”（Named Volumes）。这些命名卷就像是 Docker 管理的一块专门用于存储数据的区域，它的生命周期独立于任何一个容器。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version 和 services 中间（或者在 services 下面），可以定义顶层 volumes</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># ... 你的服务定义，比如数据库服务 ...</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 在服务内部使用顶层声明的命名卷</span></span><br><span class=\"line\">      <span class=\"comment\"># 把容器里的 /var/lib/mysql 目录（MySQL 存放数据的地方）</span></span><br><span class=\"line\">      <span class=\"comment\"># 挂载到顶层声明的 &#x27;db-data&#x27; 这个命名卷上</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db-data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在文件的最顶层声明你使用的命名卷</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;db-data&#x27; 的命名卷</span></span><br><span class=\"line\">  <span class=\"comment\"># Docker Compose 在执行 docker-compose up 时如果发现没有这个命名卷，就会自动创建一个</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"comment\"># 你可以在这里添加一些配置，比如指定驱动或标签</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: local # 默认就是 local 驱动，通常不用写</span></span><br><span class=\"line\">    <span class=\"comment\"># labels:</span></span><br><span class=\"line\">    <span class=\"comment\">#   app: myapp</span></span><br><span class=\"line\">    <span class=\"comment\">#   type: database-data</span></span><br><span class=\"line\">    <span class=\"comment\"># 你也可以配置外部卷，但对于初学者，简单声明名字就行了</span></span><br><span class=\"line\">    <span class=\"comment\"># external: true # 如果这个卷是预先通过 docker volume create 创建好的，用 external: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 你可以声明多个命名卷</span></span><br><span class=\"line\">  <span class=\"attr\">app-logs:</span></span><br><span class=\"line\">    <span class=\"comment\"># 这个命名卷可以用来保存应用日志</span></span><br><span class=\"line\">    <span class=\"string\">pass</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者 driver_opts 用于一些高级配置，比如 NFS 挂载等，这里不展开</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：在 Docker Compose 项目中创建和管理命名卷，用于实现数据的持久化存储。</li>\n<li><strong>与服务内 <code>volumes</code> 的区别</strong>：<ul>\n<li><strong>顶层 <code>volumes</code></strong>：用于<strong>声明命名卷</strong>。这些卷由 Docker 自己管理，即使所有使用它们的容器都被删除了，卷本身默认也不会被删除，从而保留数据。</li>\n<li><strong>服务内 <code>volumes</code></strong>：用于<strong>挂载</strong>（attach）一个卷（无论是命名卷还是本地路径）到容器内部的某个路径。</li>\n</ul>\n</li>\n<li><strong>流程</strong>：<ol>\n<li>在 <code>docker-compose.yml</code> 顶层声明你需要的命名卷（比如 <code>db-data:</code>）。</li>\n<li>在需要使用这个卷的服务内部，通过 <code>volumes: - 命名卷名:/容器内部路径</code> 的格式来挂载它（比如 <code>volumes: - db-data:/var/lib/mysql</code>）。</li>\n<li>当你运行 <code>docker-compose up</code> 时，如果 <code>db-data</code> 这个命名卷不存在，Docker 会自动创建它；如果存在，就直接使用。然后将它挂载到 <code>db</code> 服务的 <code>/var/lib/mysql</code> 目录。</li>\n</ol>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>需要保存数据库数据、文件上传、日志文件等，确保容器删除或更新后数据不丢失。</li>\n<li>需要在同一个 Docker Compose 项目中的不同服务之间共享少量数据（虽然不常见，主要还是用于持久化）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🌐-networks-顶层-：定义你的“内部通信频道”\"><a href=\"#🌐-networks-顶层-：定义你的“内部通信频道”\" class=\"headerlink\" title=\"🌐 networks (顶层)：定义你的“内部通信频道”\"></a>🌐 <code>networks</code> (顶层)：定义你的“内部通信频道”</h2><p>就像 <code>volumes</code> 一样，<code>networks</code> 也可以在服务内部指定（让服务加入到某个网络），但更常见、更推荐的方式是在 <code>docker-compose.yml</code> 的<strong>顶层</strong>定义你自己的自定义网络。</p>\n<p>顶层定义 <code>networks</code> 的作用是创建一个或多个自定义的网络。Docker Compose 会把这些网络创建出来，然后你可以在 <code>services</code> 部分指定哪些服务要加入到哪个网络。</p>\n<p><strong>为什么需要自定义网络？</strong></p>\n<p>默认情况下，Docker Compose 会为你的项目创建一个默认的网络（通常名字是 <code>项目目录名_default</code>）。这个默认网络已经可以让你项目中的服务通过服务名互相访问了。</p>\n<p>但是，自定义网络提供了更好的隔离性和灵活性：</p>\n<ol>\n<li><strong>隔离性</strong>：你可以创建不同的网络，把不同组的服务放在各自的网络里。这样，只有连接到同一个网络的服才能直接通信，提高了安全性。</li>\n<li><strong>清晰性</strong>：通过自定义网络名，你可以更清晰地表达服务之间的通信关系。</li>\n<li><strong>控制</strong>：可以配置网络的驱动、IP 地址范围等高级设置（尽管基础使用时通常不需要）。</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># version 和 services 中间（或者在 services 下面），可以定义顶层 networks</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个前端服务</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-frontend</span></span><br><span class=\"line\">    <span class=\"comment\"># networks: 指定这个服务要连接到哪些网络</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">frontend_network</span> <span class=\"comment\"># 加入到 frontend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果前端也需要直接访问后端，可以也加入 backend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># - backend_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个后端服务</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到 backend_network</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果后端需要访问数据库，且数据库也在 backend_network，这里就这样写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 定义一个数据库服务</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend_network</span> <span class=\"comment\"># 加入到 backend_network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在文件的最顶层声明你使用的自定义网络</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;frontend_network&#x27; 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">frontend_network:</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认的网络类型，通常不用写，表示使用桥接网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 声明一个名字叫 &#x27;backend_network&#x27; 的网络</span></span><br><span class=\"line\">  <span class=\"attr\">backend_network:</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge # 同样是默认驱动，通常不用写</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：创建自定义网络，让指定的容器能够互相发现和通信。</li>\n<li><strong>服务发现</strong>：连接到<strong>同一个</strong>自定义网络的容器，可以通过<strong>服务名</strong>作为主机名互相访问。<ul>\n<li>比如，上面的 <code>backend</code> 服务可以通过 <code>db</code> 作为主机名连接到数据库服务，因为它俩都在 <code>backend_network</code> 里。</li>\n<li>如果 <code>frontend</code> 也在 <code>backend_network</code> 里，它就可以通过 <code>backend</code> 作为主机名访问后端服务。</li>\n</ul>\n</li>\n<li><strong>与服务内 <code>networks</code> 的区别</strong>：<ul>\n<li><strong>顶层 <code>networks</code></strong>：用于<strong>声明自定义网络</strong>。Docker Compose 会负责创建这些网络。</li>\n<li><strong>服务内 <code>networks</code></strong>：用于让服务<strong>加入</strong>（connect）到顶层声明的（或默认的）网络中。</li>\n</ul>\n</li>\n<li><strong>流程</strong>：<ol>\n<li>在 <code>docker-compose.yml</code> 顶层声明你需要的自定义网络（比如 <code>backend_network:</code>）。</li>\n<li>在需要加入这个网络的服务内部，通过 <code>networks: - 网络名</code> 的格式来连接它（比如 <code>networks: - backend_network</code>）。</li>\n<li>当你运行 <code>docker-compose up</code> 时，Docker Compose 会创建 <code>backend_network</code>（如果不存在），然后将 <code>backend</code> 和 <code>db</code> 这两个服务的容器都连接到这个网络。</li>\n</ol>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>你的项目包含多个服务，需要互相通信（这是最常见场景）。</li>\n<li>需要将不同的服务组进行网络隔离。</li>\n<li>需要更精细地控制服务间的通信路径。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"✨-组合使用：一个更完整的-docker-compose-yml-结构\"><a href=\"#✨-组合使用：一个更完整的-docker-compose-yml-结构\" class=\"headerlink\" title=\"✨ 组合使用：一个更完整的 docker-compose.yml 结构\"></a>✨ 组合使用：一个更完整的 <code>docker-compose.yml</code> 结构</h2><p>现在我们知道了顶层 <code>version</code>, <code>volumes</code>, <code>networks</code> 以及服务内部的各种配置，一个常见的 <code>docker-compose.yml</code> 文件结构就会像这样：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. version: 文件格式版本，必须在第一行</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. services: 定义项目包含的所有服务（这是核心部分，通常最长）</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># app 服务（比如你的后端应用）</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"comment\"># 从本地代码构建</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span> <span class=\"comment\"># 构建后的镜像名</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span> <span class=\"comment\"># 外部 80 端口映射到容器内部 3000 端口</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span> <span class=\"comment\"># 本地代码挂载到容器，方便开发热更新</span></span><br><span class=\"line\">      <span class=\"comment\"># - app-logs:/app/logs # 使用顶层声明的命名卷挂载日志目录</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span> <span class=\"comment\"># 依赖 db 服务，通过服务名访问</span></span><br><span class=\"line\">      <span class=\"comment\"># 其他环境变量...</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 依赖 db 服务，确保 db 先启动</span></span><br><span class=\"line\">      <span class=\"comment\"># 更好的做法是使用 condition: service_healthy，但需要 db 配置 healthcheck</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入 app_network，用于和 db 通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># db 服务（比如数据库）</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用官方 MySQL 5.7 镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># 指定容器名称，可选，方便区分</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: my_mysql_db</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 使用顶层声明的命名卷，持久化数据库数据</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=mysecretpassword</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\">      <span class=\"comment\"># 其他环境变量...</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入 app_network，和 app 服务在同一个网络</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. volumes: 在顶层声明命名卷，用于数据持久化</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># 声明一个叫 db_data 的命名卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># app_logs: # 如果上面 app 服务使用了 app-logs 命名卷，这里也要声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. networks: 在顶层声明自定义网络，用于服务间通信</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 声明一个叫 app_network 的自定义网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<p>这个例子展示了 <code>version</code>, <code>services</code>, <code>volumes</code>, <code>networks</code> 在一个文件中的组织方式。<code>services</code> 是核心，但 <code>version</code>, <code>volumes</code> 和 <code>networks</code> 提供了重要的全局配置和资源管理能力。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>现在你已经了解了 <code>docker-compose.yml</code> 文件的顶层结构：</p>\n<ul>\n<li><code>version</code> 定义了文件的规范版本。</li>\n<li>顶层 <code>volumes</code> 声明了 Docker 管理的持久化数据存储区域（命名卷）。</li>\n<li>顶层 <code>networks</code> 声明了自定义网络，用于服务间的隔离和通信。</li>\n</ul>\n<p>搞清楚这些顶层配置，你就对 <code>docker-compose.yml</code> 的整体结构有了清晰的认识。接下来，最激动人心的部分来了：<strong>如何真正运行起这个文件里定义的服务？</strong> 在下一章，我们将学习 <code>docker-compose up</code>, <code>down</code>, <code>logs</code> 等最常用的命令，把你写好的配置变成眼前运行的容器！敬请期待！</p>\n"},{"title":"🐳 Docker Compose 常用命令篇（三）：运行、管理和停止你的应用","date":"2025-06-07T04:55:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":34934,"_content":"\n# 🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！\n\n嘿！你已经学会了如何用 `docker-compose.yml` 文件来描述你的应用栈（服务、卷、网络）。这就像有了一张详细的建筑图纸，告诉你你的应用需要哪些“房间”（服务）、“仓库”（卷）、“走廊”（网络），以及它们各自的配置。\n\n但是，光有图纸还不够啊！我们得把它变成现实，把这些“房间”盖起来，让它们“住人”（运行容器），让它们“通电通水”（网络连接），让“仓库”能存东西！\n\n这就轮到 **Docker Compose 的命令行工具**登场了！它们是把你的 `yml` 图纸变成眼前跑着的容器的魔法棒。掌握这些命令，你就能轻松地启动、停止、管理和调试你的整个应用了。\n\n今天，我们就来学习 Docker Compose 最最常用、也最重要的几个命令！\n\n---\n\n## 🚀 1. `docker-compose up`：启动你的整个应用！\n\n这是你使用 Docker Compose 时最频繁的命令，它的作用就是**根据你的 `docker-compose.yml` 文件，创建并启动所有定义的服务**。\n\n想象一下，你有一堆乐高积木的说明书（`docker-compose.yml`），`docker-compose up` 就是那个“开始拼装并启动”的按钮！\n\n```bash\n# 基本用法：启动你的项目里的所有服务\ndocker-compose up\n\n# 常用选项 -d：以后台（分离）模式运行\n# 这是最常用的方式，启动后终端不会被容器日志霸占\ndocker-compose up -d\n\n# 常用选项 --build：在启动前强制重新构建有 build 配置的服务镜像\n# 当你改动了本地代码或者 Dockerfile 时，就需要加上这个\ndocker-compose up -d --build\n\n# 常用选项 --force-recreate：强制重新创建容器，即使配置没有变化\n# 有时候用来解决一些奇怪的问题，或者确保应用了某些非配置类的改动（比如资源限制）\ndocker-compose up -d --force-recreate\n\n# 只启动特定的服务（以及它们的依赖）\n# 比如只启动 app 服务，如果 app 依赖 db，db 也会被启动\ndocker-compose up -d app db\n\n# 如果你的 docker-compose.yml 文件不在当前目录，或者名字不是 docker-compose.yml\n# 可以用 -f 参数指定文件\ndocker-compose -f /path/to/your/compose.yml up -d\n```\n\n*   **作用**：读取 `docker-compose.yml` 文件，执行构建（如果需要）、创建网络、创建卷、创建容器，并启动所有服务。\n*   **流程**：\n    1.  Docker Compose 读取当前目录（或 `-f` 指定）的 `docker-compose.yml` 文件。\n    2.  根据顶层 `networks` 定义，创建自定义网络（如果不存在）。\n    3.  根据顶层 `volumes` 定义，创建命名卷（如果不存在）。\n    4.  遍历 `services` 里的每个服务。\n    5.  如果服务有 `build` 配置，Docker Compose 会根据 `Dockerfile` 构建镜像（如果本地没有或者加了 `--build`）。\n    6.  如果服务有 `image` 配置，Docker Compose 会尝试拉取镜像（如果本地没有）。\n    7.  根据 `depends_on` 配置的服务依赖关系，按顺序创建和启动容器。\n    8.  将容器连接到指定的网络，进行端口映射，挂载数据卷，设置环境变量等等。\n    9.  启动容器里定义的应用进程。\n*   **使用场景**：\n    *   第一次运行你的 Docker Compose 项目。\n    *   在开发环境中启动整个应用栈。\n    *   更新了代码或配置文件后，重新部署服务。\n    *   从停止状态恢复运行。\n\n---\n\n## 🛑 2. `docker-compose down`：优雅地停止并移除你的应用！\n\n当你不需要运行你的应用栈时，直接关闭终端或者强制停止 Docker 可能导致资源残留。`docker-compose down` 是最推荐的方式来停止并清理你的 Docker Compose 项目。\n\n它就像是那个“关闭并拆除”的按钮，会停止所有运行中的容器，并移除与该项目相关的容器、网络和（可选）卷。\n\n```bash\n# 基本用法：停止并移除当前项目的所有容器和网络\ndocker-compose down\n\n# 常用选项 -v (或 --volumes)：同时移除声明在 yml 文件顶层的命名卷\n# **注意！** 这个操作会删除命名卷里存储的数据，慎用！\ndocker-compose down -v\n\n# 常用选项 --rmi type：移除服务使用的镜像\n# type 可以是 'local' (只移除 build 的镜像) 或 'all' (移除所有)\n# 不常用，一般不删除镜像，除非是彻底清理\ndocker-compose down --rmi local\n\n# 常用选项 --remove-orphans：移除那些不再被当前 docker-compose.yml 文件定义的容器\n# 有时候yml改动了，旧容器还在，可以用这个清理\ndocker-compose down --remove-orphans\n```\n\n*   **作用**：停止并删除由 `docker-compose up` 创建的容器、默认网络以及顶层定义的网络。可以选泽是否删除命名卷和镜像。\n*   **流程**：\n    1.  Docker Compose 识别出当前项目相关的容器和网络。\n    2.  按依赖关系的逆序（先停止依赖别人的服务），优雅地发送停止信号给容器。\n    3.  移除容器。\n    4.  移除项目默认创建的网络和顶层定义的网络。\n    5.  如果指定了 `-v`，则移除顶层声明的命名卷。\n    6.  如果指定了 `--rmi`，则移除相应的镜像。\n*   **使用场景**：\n    *   关闭开发环境。\n    *   进行大的项目配置或代码改动前，先完全停止清理。\n    *   彻底移除一个不再需要的应用栈。\n\n---\n\n## 👀 3. `docker-compose ps`：看看你的服务“活”得怎么样？\n\n`docker-compose up` 之后，你怎么知道你的服务是不是都正常运行了？`docker-compose ps` 命令就是用来**查看你的 Docker Compose 项目中所有服务的状态**。\n\n```bash\n# 查看当前项目里所有服务的状态\ndocker-compose ps\n```\n\n*   **作用**：列出当前 Docker Compose 项目所管理的所有容器，显示它们的名字、命令、状态、端口映射等信息。\n*   **输出解读**：\n    *   `Name`：容器的完整名称。\n    *   `Command`：容器启动时执行的命令。\n    *   `State`：容器的状态，比如 `Up` (运行中)、`Exited` (已退出)、`Up (health: starting)` (正在启动健康检查)、`Up (healthy)` (健康)、`Up (unhealthy)` (不健康)。\n    *   `Ports`：端口映射信息（比如 `0.0.0.0:8080->80/tcp` 表示宿主机的 8080 端口映射到容器的 80 端口）。\n*   **使用场景**：\n    *   确认所有服务都成功启动。\n    *   检查是否有服务异常退出 (`Exited`)。\n    *   查看服务的健康检查状态 (`healthy`/`unhealthy`)。\n    *   确认端口映射是否正确。\n\n---\n\n## 📜 4. `docker-compose logs`：看一看服务里发生了啥？\n\n当服务启动失败、异常退出，或者运行不正常时，查看它的日志是定位问题最直接的方式。`docker-compose logs` 命令可以**显示你的 Docker Compose 项目中一个或多个服务的标准输出和标准错误日志**。\n\n```bash\n# 查看当前项目里所有服务的历史日志\ndocker-compose logs\n\n# 常用选项 -f (或 --follow)：实时追踪并显示新的日志输出\n# 这在调试时非常有用，可以看到服务启动过程中的详细信息或运行时的错误\ndocker-compose logs -f\n\n# 查看特定服务的日志\ndocker-compose logs app db\n\n# 实时追踪特定服务的日志\ndocker-compose logs -f app\n\n# 常用选项 --tail number：只显示日志的最后 N 行\ndocker-compose logs --tail 50 app\n\n# 结合使用：实时追踪特定服务日志的最后100行（先显示历史的后100行，再追踪新的）\ndocker-compose logs -f --tail 100 app\n```\n\n*   **作用**：获取并显示一个或多个容器的日志流。\n*   **使用场景**：\n    *   排查服务启动失败的原因。\n    *   监控服务的运行状态和输出信息。\n    *   调试应用代码时查看打印的日志。\n    *   了解服务内部的详细执行过程。\n\n---\n\n## 🏃 5. `docker-compose exec`：钻进容器里“搞事情”！\n\n有时候你需要直接在运行中的容器里执行一些命令，比如进入一个 Web 容器的终端查看文件，或者进入数据库容器执行 SQL 命令，或者在应用容器里运行一个临时的脚本。`docker-compose exec` 命令就是用来**在指定的运行中容器里执行命令**。\n\n```bash\n# 基本用法：在 app 容器里执行一个简单的命令 (比如 ls -l)\ndocker-compose exec app ls -l /app\n\n# 常用选项 -it：分配一个伪终端并保持标准输入开放\n# 这对于进入交互式 shell (比如 bash) 是必须的\ndocker-compose exec -it app bash # 进入 app 容器的 bash 终端\n\n# 进入 db 容器，并使用 mysql 客户端连接数据库\n# 注意：这里的 mysql 命令是在 db 容器内部执行的\ndocker-compose exec -it db mysql -u root -p # 会提示输入密码\n\n# 在特定的服务容器里运行一个迁移脚本\ndocker-compose exec app npm run migrate\n```\n\n*   **作用**：在一个已经运行的容器内部执行任意命令。\n*   **使用场景**：\n    *   调试：查看容器内的文件、环境变量、进程等。\n    *   执行维护任务：运行数据库迁移、清理缓存等一次性脚本。\n    *   获取交互式终端：像 SSH 一样进入容器内部操作。\n\n---\n\n## 🧱 6. `docker-compose build`：只构建镜像，不启动！\n\n如果你的服务使用了 `build` 配置，`docker-compose up --build` 会在启动前构建镜像。但有时候你可能只想检查你的 `Dockerfile` 是否能成功构建，或者在部署前预先构建好所有镜像，而不想立即启动服务。`docker-compose build` 命令就是用来**单独构建或重新构建服务镜像**的。\n\n```bash\n# 构建当前项目里所有带有 build 配置的服务镜像\ndocker-compose build\n\n# 常用选项 --no-cache：构建时禁用缓存\n# 用于确保完全从头开始构建，排除缓存引起的问题\ndocker-compose build --no-cache app\n\n# 只构建特定的服务镜像\ndocker-compose build app db\n```\n\n*   **作用**：根据 `Dockerfile` 构建（或重新构建）服务镜像，但不创建或启动容器。\n*   **与 `up --build` 的区别**：\n    *   `docker-compose build`：只构建镜像。\n    *   `docker-compose up --build`：构建镜像后，继续创建和启动容器。\n*   **使用场景**：\n    *   在 CI/CD 流水线中，先构建镜像并推送到仓库。\n    *   验证 `Dockerfile` 的正确性。\n    *   预先准备好镜像，等待后续启动。\n\n---\n\n## 总结一下，常用的 Docker Compose 命令就是这几个：\n\n*   `docker-compose up -d`：启动你的应用（后台）。\n*   `docker-compose down`：停止并清理你的应用。\n*   `docker-compose ps`：查看你的服务状态。\n*   `docker-compose logs -f [服务名]`：实时查看服务日志。\n*   `docker-compose exec -it [服务名] bash`：进入容器终端进行调试。\n*   `docker-compose build [服务名]`：只构建镜像。\n\n掌握了这些命令，你就拿到了操作 Docker Compose 的“遥控器”，可以随心所欲地启动、停止和管理你的容器化应用栈了！\n\n---\n\n**本章小结**\n\n我们学习了 Docker Compose 最基础和最重要的几个命令：\n*   `up`：启动应用栈。\n*   `down`：停止并清理应用栈。\n*   `ps`：查看服务状态。\n*   `logs`：查看服务日志。\n*   `exec`：在容器内部执行命令。\n*   `build`：单独构建镜像。\n\n这些命令是日常使用 Docker Compose 的基石。但在实际应用中，服务的启动顺序、依赖关系、以及如何判断一个服务是否“真正准备好”是非常关键的问题。下一章，我们将深入探讨 `depends_on` 和 `healthcheck` 的高级用法，学习如何确保你的服务按正确顺序启动，并且能够互相可靠地通信！敬请期待！","source":"_posts/Docker/Docker Compose 常用命令篇（三）：运行、管理和停止你的应用.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 常用命令篇（三）：运行、管理和停止你的应用\"\ndate: '2025-06-07 12:55'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 34934\n---\n\n# 🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！\n\n嘿！你已经学会了如何用 `docker-compose.yml` 文件来描述你的应用栈（服务、卷、网络）。这就像有了一张详细的建筑图纸，告诉你你的应用需要哪些“房间”（服务）、“仓库”（卷）、“走廊”（网络），以及它们各自的配置。\n\n但是，光有图纸还不够啊！我们得把它变成现实，把这些“房间”盖起来，让它们“住人”（运行容器），让它们“通电通水”（网络连接），让“仓库”能存东西！\n\n这就轮到 **Docker Compose 的命令行工具**登场了！它们是把你的 `yml` 图纸变成眼前跑着的容器的魔法棒。掌握这些命令，你就能轻松地启动、停止、管理和调试你的整个应用了。\n\n今天，我们就来学习 Docker Compose 最最常用、也最重要的几个命令！\n\n---\n\n## 🚀 1. `docker-compose up`：启动你的整个应用！\n\n这是你使用 Docker Compose 时最频繁的命令，它的作用就是**根据你的 `docker-compose.yml` 文件，创建并启动所有定义的服务**。\n\n想象一下，你有一堆乐高积木的说明书（`docker-compose.yml`），`docker-compose up` 就是那个“开始拼装并启动”的按钮！\n\n```bash\n# 基本用法：启动你的项目里的所有服务\ndocker-compose up\n\n# 常用选项 -d：以后台（分离）模式运行\n# 这是最常用的方式，启动后终端不会被容器日志霸占\ndocker-compose up -d\n\n# 常用选项 --build：在启动前强制重新构建有 build 配置的服务镜像\n# 当你改动了本地代码或者 Dockerfile 时，就需要加上这个\ndocker-compose up -d --build\n\n# 常用选项 --force-recreate：强制重新创建容器，即使配置没有变化\n# 有时候用来解决一些奇怪的问题，或者确保应用了某些非配置类的改动（比如资源限制）\ndocker-compose up -d --force-recreate\n\n# 只启动特定的服务（以及它们的依赖）\n# 比如只启动 app 服务，如果 app 依赖 db，db 也会被启动\ndocker-compose up -d app db\n\n# 如果你的 docker-compose.yml 文件不在当前目录，或者名字不是 docker-compose.yml\n# 可以用 -f 参数指定文件\ndocker-compose -f /path/to/your/compose.yml up -d\n```\n\n*   **作用**：读取 `docker-compose.yml` 文件，执行构建（如果需要）、创建网络、创建卷、创建容器，并启动所有服务。\n*   **流程**：\n    1.  Docker Compose 读取当前目录（或 `-f` 指定）的 `docker-compose.yml` 文件。\n    2.  根据顶层 `networks` 定义，创建自定义网络（如果不存在）。\n    3.  根据顶层 `volumes` 定义，创建命名卷（如果不存在）。\n    4.  遍历 `services` 里的每个服务。\n    5.  如果服务有 `build` 配置，Docker Compose 会根据 `Dockerfile` 构建镜像（如果本地没有或者加了 `--build`）。\n    6.  如果服务有 `image` 配置，Docker Compose 会尝试拉取镜像（如果本地没有）。\n    7.  根据 `depends_on` 配置的服务依赖关系，按顺序创建和启动容器。\n    8.  将容器连接到指定的网络，进行端口映射，挂载数据卷，设置环境变量等等。\n    9.  启动容器里定义的应用进程。\n*   **使用场景**：\n    *   第一次运行你的 Docker Compose 项目。\n    *   在开发环境中启动整个应用栈。\n    *   更新了代码或配置文件后，重新部署服务。\n    *   从停止状态恢复运行。\n\n---\n\n## 🛑 2. `docker-compose down`：优雅地停止并移除你的应用！\n\n当你不需要运行你的应用栈时，直接关闭终端或者强制停止 Docker 可能导致资源残留。`docker-compose down` 是最推荐的方式来停止并清理你的 Docker Compose 项目。\n\n它就像是那个“关闭并拆除”的按钮，会停止所有运行中的容器，并移除与该项目相关的容器、网络和（可选）卷。\n\n```bash\n# 基本用法：停止并移除当前项目的所有容器和网络\ndocker-compose down\n\n# 常用选项 -v (或 --volumes)：同时移除声明在 yml 文件顶层的命名卷\n# **注意！** 这个操作会删除命名卷里存储的数据，慎用！\ndocker-compose down -v\n\n# 常用选项 --rmi type：移除服务使用的镜像\n# type 可以是 'local' (只移除 build 的镜像) 或 'all' (移除所有)\n# 不常用，一般不删除镜像，除非是彻底清理\ndocker-compose down --rmi local\n\n# 常用选项 --remove-orphans：移除那些不再被当前 docker-compose.yml 文件定义的容器\n# 有时候yml改动了，旧容器还在，可以用这个清理\ndocker-compose down --remove-orphans\n```\n\n*   **作用**：停止并删除由 `docker-compose up` 创建的容器、默认网络以及顶层定义的网络。可以选泽是否删除命名卷和镜像。\n*   **流程**：\n    1.  Docker Compose 识别出当前项目相关的容器和网络。\n    2.  按依赖关系的逆序（先停止依赖别人的服务），优雅地发送停止信号给容器。\n    3.  移除容器。\n    4.  移除项目默认创建的网络和顶层定义的网络。\n    5.  如果指定了 `-v`，则移除顶层声明的命名卷。\n    6.  如果指定了 `--rmi`，则移除相应的镜像。\n*   **使用场景**：\n    *   关闭开发环境。\n    *   进行大的项目配置或代码改动前，先完全停止清理。\n    *   彻底移除一个不再需要的应用栈。\n\n---\n\n## 👀 3. `docker-compose ps`：看看你的服务“活”得怎么样？\n\n`docker-compose up` 之后，你怎么知道你的服务是不是都正常运行了？`docker-compose ps` 命令就是用来**查看你的 Docker Compose 项目中所有服务的状态**。\n\n```bash\n# 查看当前项目里所有服务的状态\ndocker-compose ps\n```\n\n*   **作用**：列出当前 Docker Compose 项目所管理的所有容器，显示它们的名字、命令、状态、端口映射等信息。\n*   **输出解读**：\n    *   `Name`：容器的完整名称。\n    *   `Command`：容器启动时执行的命令。\n    *   `State`：容器的状态，比如 `Up` (运行中)、`Exited` (已退出)、`Up (health: starting)` (正在启动健康检查)、`Up (healthy)` (健康)、`Up (unhealthy)` (不健康)。\n    *   `Ports`：端口映射信息（比如 `0.0.0.0:8080->80/tcp` 表示宿主机的 8080 端口映射到容器的 80 端口）。\n*   **使用场景**：\n    *   确认所有服务都成功启动。\n    *   检查是否有服务异常退出 (`Exited`)。\n    *   查看服务的健康检查状态 (`healthy`/`unhealthy`)。\n    *   确认端口映射是否正确。\n\n---\n\n## 📜 4. `docker-compose logs`：看一看服务里发生了啥？\n\n当服务启动失败、异常退出，或者运行不正常时，查看它的日志是定位问题最直接的方式。`docker-compose logs` 命令可以**显示你的 Docker Compose 项目中一个或多个服务的标准输出和标准错误日志**。\n\n```bash\n# 查看当前项目里所有服务的历史日志\ndocker-compose logs\n\n# 常用选项 -f (或 --follow)：实时追踪并显示新的日志输出\n# 这在调试时非常有用，可以看到服务启动过程中的详细信息或运行时的错误\ndocker-compose logs -f\n\n# 查看特定服务的日志\ndocker-compose logs app db\n\n# 实时追踪特定服务的日志\ndocker-compose logs -f app\n\n# 常用选项 --tail number：只显示日志的最后 N 行\ndocker-compose logs --tail 50 app\n\n# 结合使用：实时追踪特定服务日志的最后100行（先显示历史的后100行，再追踪新的）\ndocker-compose logs -f --tail 100 app\n```\n\n*   **作用**：获取并显示一个或多个容器的日志流。\n*   **使用场景**：\n    *   排查服务启动失败的原因。\n    *   监控服务的运行状态和输出信息。\n    *   调试应用代码时查看打印的日志。\n    *   了解服务内部的详细执行过程。\n\n---\n\n## 🏃 5. `docker-compose exec`：钻进容器里“搞事情”！\n\n有时候你需要直接在运行中的容器里执行一些命令，比如进入一个 Web 容器的终端查看文件，或者进入数据库容器执行 SQL 命令，或者在应用容器里运行一个临时的脚本。`docker-compose exec` 命令就是用来**在指定的运行中容器里执行命令**。\n\n```bash\n# 基本用法：在 app 容器里执行一个简单的命令 (比如 ls -l)\ndocker-compose exec app ls -l /app\n\n# 常用选项 -it：分配一个伪终端并保持标准输入开放\n# 这对于进入交互式 shell (比如 bash) 是必须的\ndocker-compose exec -it app bash # 进入 app 容器的 bash 终端\n\n# 进入 db 容器，并使用 mysql 客户端连接数据库\n# 注意：这里的 mysql 命令是在 db 容器内部执行的\ndocker-compose exec -it db mysql -u root -p # 会提示输入密码\n\n# 在特定的服务容器里运行一个迁移脚本\ndocker-compose exec app npm run migrate\n```\n\n*   **作用**：在一个已经运行的容器内部执行任意命令。\n*   **使用场景**：\n    *   调试：查看容器内的文件、环境变量、进程等。\n    *   执行维护任务：运行数据库迁移、清理缓存等一次性脚本。\n    *   获取交互式终端：像 SSH 一样进入容器内部操作。\n\n---\n\n## 🧱 6. `docker-compose build`：只构建镜像，不启动！\n\n如果你的服务使用了 `build` 配置，`docker-compose up --build` 会在启动前构建镜像。但有时候你可能只想检查你的 `Dockerfile` 是否能成功构建，或者在部署前预先构建好所有镜像，而不想立即启动服务。`docker-compose build` 命令就是用来**单独构建或重新构建服务镜像**的。\n\n```bash\n# 构建当前项目里所有带有 build 配置的服务镜像\ndocker-compose build\n\n# 常用选项 --no-cache：构建时禁用缓存\n# 用于确保完全从头开始构建，排除缓存引起的问题\ndocker-compose build --no-cache app\n\n# 只构建特定的服务镜像\ndocker-compose build app db\n```\n\n*   **作用**：根据 `Dockerfile` 构建（或重新构建）服务镜像，但不创建或启动容器。\n*   **与 `up --build` 的区别**：\n    *   `docker-compose build`：只构建镜像。\n    *   `docker-compose up --build`：构建镜像后，继续创建和启动容器。\n*   **使用场景**：\n    *   在 CI/CD 流水线中，先构建镜像并推送到仓库。\n    *   验证 `Dockerfile` 的正确性。\n    *   预先准备好镜像，等待后续启动。\n\n---\n\n## 总结一下，常用的 Docker Compose 命令就是这几个：\n\n*   `docker-compose up -d`：启动你的应用（后台）。\n*   `docker-compose down`：停止并清理你的应用。\n*   `docker-compose ps`：查看你的服务状态。\n*   `docker-compose logs -f [服务名]`：实时查看服务日志。\n*   `docker-compose exec -it [服务名] bash`：进入容器终端进行调试。\n*   `docker-compose build [服务名]`：只构建镜像。\n\n掌握了这些命令，你就拿到了操作 Docker Compose 的“遥控器”，可以随心所欲地启动、停止和管理你的容器化应用栈了！\n\n---\n\n**本章小结**\n\n我们学习了 Docker Compose 最基础和最重要的几个命令：\n*   `up`：启动应用栈。\n*   `down`：停止并清理应用栈。\n*   `ps`：查看服务状态。\n*   `logs`：查看服务日志。\n*   `exec`：在容器内部执行命令。\n*   `build`：单独构建镜像。\n\n这些命令是日常使用 Docker Compose 的基石。但在实际应用中，服务的启动顺序、依赖关系、以及如何判断一个服务是否“真正准备好”是非常关键的问题。下一章，我们将深入探讨 `depends_on` 和 `healthcheck` 的高级用法，学习如何确保你的服务按正确顺序启动，并且能够互相可靠地通信！敬请期待！","slug":"Docker/Docker Compose 常用命令篇（三）：运行、管理和停止你的应用","published":1,"updated":"2025-06-07T15:58:53.663Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww5000bpkrcgh7g1mbp","content":"<h1 id=\"🐳-Docker-Compose-命令宝典-让你的应用栈“动”起来！\"><a href=\"#🐳-Docker-Compose-命令宝典-让你的应用栈“动”起来！\" class=\"headerlink\" title=\"🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！\"></a>🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！</h1><p>嘿！你已经学会了如何用 <code>docker-compose.yml</code> 文件来描述你的应用栈（服务、卷、网络）。这就像有了一张详细的建筑图纸，告诉你你的应用需要哪些“房间”（服务）、“仓库”（卷）、“走廊”（网络），以及它们各自的配置。</p>\n<p>但是，光有图纸还不够啊！我们得把它变成现实，把这些“房间”盖起来，让它们“住人”（运行容器），让它们“通电通水”（网络连接），让“仓库”能存东西！</p>\n<p>这就轮到 <strong>Docker Compose 的命令行工具</strong>登场了！它们是把你的 <code>yml</code> 图纸变成眼前跑着的容器的魔法棒。掌握这些命令，你就能轻松地启动、停止、管理和调试你的整个应用了。</p>\n<p>今天，我们就来学习 Docker Compose 最最常用、也最重要的几个命令！</p>\n<hr>\n<h2 id=\"🚀-1-docker-compose-up：启动你的整个应用！\"><a href=\"#🚀-1-docker-compose-up：启动你的整个应用！\" class=\"headerlink\" title=\"🚀 1. docker-compose up：启动你的整个应用！\"></a>🚀 1. <code>docker-compose up</code>：启动你的整个应用！</h2><p>这是你使用 Docker Compose 时最频繁的命令，它的作用就是<strong>根据你的 <code>docker-compose.yml</code> 文件，创建并启动所有定义的服务</strong>。</p>\n<p>想象一下，你有一堆乐高积木的说明书（<code>docker-compose.yml</code>），<code>docker-compose up</code> 就是那个“开始拼装并启动”的按钮！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：启动你的项目里的所有服务</span></span><br><span class=\"line\">docker-compose up</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -d：以后台（分离）模式运行</span></span><br><span class=\"line\"><span class=\"comment\"># 这是最常用的方式，启动后终端不会被容器日志霸占</span></span><br><span class=\"line\">docker-compose up -d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --build：在启动前强制重新构建有 build 配置的服务镜像</span></span><br><span class=\"line\"><span class=\"comment\"># 当你改动了本地代码或者 Dockerfile 时，就需要加上这个</span></span><br><span class=\"line\">docker-compose up -d --build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --force-recreate：强制重新创建容器，即使配置没有变化</span></span><br><span class=\"line\"><span class=\"comment\"># 有时候用来解决一些奇怪的问题，或者确保应用了某些非配置类的改动（比如资源限制）</span></span><br><span class=\"line\">docker-compose up -d --force-recreate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只启动特定的服务（以及它们的依赖）</span></span><br><span class=\"line\"><span class=\"comment\"># 比如只启动 app 服务，如果 app 依赖 db，db 也会被启动</span></span><br><span class=\"line\">docker-compose up -d app db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果你的 docker-compose.yml 文件不在当前目录，或者名字不是 docker-compose.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 可以用 -f 参数指定文件</span></span><br><span class=\"line\">docker-compose -f /path/to/your/compose.yml up -d</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：读取 <code>docker-compose.yml</code> 文件，执行构建（如果需要）、创建网络、创建卷、创建容器，并启动所有服务。</li>\n<li><strong>流程</strong>：<ol>\n<li>Docker Compose 读取当前目录（或 <code>-f</code> 指定）的 <code>docker-compose.yml</code> 文件。</li>\n<li>根据顶层 <code>networks</code> 定义，创建自定义网络（如果不存在）。</li>\n<li>根据顶层 <code>volumes</code> 定义，创建命名卷（如果不存在）。</li>\n<li>遍历 <code>services</code> 里的每个服务。</li>\n<li>如果服务有 <code>build</code> 配置，Docker Compose 会根据 <code>Dockerfile</code> 构建镜像（如果本地没有或者加了 <code>--build</code>）。</li>\n<li>如果服务有 <code>image</code> 配置，Docker Compose 会尝试拉取镜像（如果本地没有）。</li>\n<li>根据 <code>depends_on</code> 配置的服务依赖关系，按顺序创建和启动容器。</li>\n<li>将容器连接到指定的网络，进行端口映射，挂载数据卷，设置环境变量等等。</li>\n<li>启动容器里定义的应用进程。</li>\n</ol>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>第一次运行你的 Docker Compose 项目。</li>\n<li>在开发环境中启动整个应用栈。</li>\n<li>更新了代码或配置文件后，重新部署服务。</li>\n<li>从停止状态恢复运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🛑-2-docker-compose-down：优雅地停止并移除你的应用！\"><a href=\"#🛑-2-docker-compose-down：优雅地停止并移除你的应用！\" class=\"headerlink\" title=\"🛑 2. docker-compose down：优雅地停止并移除你的应用！\"></a>🛑 2. <code>docker-compose down</code>：优雅地停止并移除你的应用！</h2><p>当你不需要运行你的应用栈时，直接关闭终端或者强制停止 Docker 可能导致资源残留。<code>docker-compose down</code> 是最推荐的方式来停止并清理你的 Docker Compose 项目。</p>\n<p>它就像是那个“关闭并拆除”的按钮，会停止所有运行中的容器，并移除与该项目相关的容器、网络和（可选）卷。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：停止并移除当前项目的所有容器和网络</span></span><br><span class=\"line\">docker-compose down</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -v (或 --volumes)：同时移除声明在 yml 文件顶层的命名卷</span></span><br><span class=\"line\"><span class=\"comment\"># **注意！** 这个操作会删除命名卷里存储的数据，慎用！</span></span><br><span class=\"line\">docker-compose down -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --rmi type：移除服务使用的镜像</span></span><br><span class=\"line\"><span class=\"comment\"># type 可以是 &#x27;local&#x27; (只移除 build 的镜像) 或 &#x27;all&#x27; (移除所有)</span></span><br><span class=\"line\"><span class=\"comment\"># 不常用，一般不删除镜像，除非是彻底清理</span></span><br><span class=\"line\">docker-compose down --rmi <span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --remove-orphans：移除那些不再被当前 docker-compose.yml 文件定义的容器</span></span><br><span class=\"line\"><span class=\"comment\"># 有时候yml改动了，旧容器还在，可以用这个清理</span></span><br><span class=\"line\">docker-compose down --remove-orphans</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：停止并删除由 <code>docker-compose up</code> 创建的容器、默认网络以及顶层定义的网络。可以选泽是否删除命名卷和镜像。</li>\n<li><strong>流程</strong>：<ol>\n<li>Docker Compose 识别出当前项目相关的容器和网络。</li>\n<li>按依赖关系的逆序（先停止依赖别人的服务），优雅地发送停止信号给容器。</li>\n<li>移除容器。</li>\n<li>移除项目默认创建的网络和顶层定义的网络。</li>\n<li>如果指定了 <code>-v</code>，则移除顶层声明的命名卷。</li>\n<li>如果指定了 <code>--rmi</code>，则移除相应的镜像。</li>\n</ol>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>关闭开发环境。</li>\n<li>进行大的项目配置或代码改动前，先完全停止清理。</li>\n<li>彻底移除一个不再需要的应用栈。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"👀-3-docker-compose-ps：看看你的服务“活”得怎么样？\"><a href=\"#👀-3-docker-compose-ps：看看你的服务“活”得怎么样？\" class=\"headerlink\" title=\"👀 3. docker-compose ps：看看你的服务“活”得怎么样？\"></a>👀 3. <code>docker-compose ps</code>：看看你的服务“活”得怎么样？</h2><p><code>docker-compose up</code> 之后，你怎么知道你的服务是不是都正常运行了？<code>docker-compose ps</code> 命令就是用来<strong>查看你的 Docker Compose 项目中所有服务的状态</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前项目里所有服务的状态</span></span><br><span class=\"line\">docker-compose ps</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：列出当前 Docker Compose 项目所管理的所有容器，显示它们的名字、命令、状态、端口映射等信息。</li>\n<li><strong>输出解读</strong>：<ul>\n<li><code>Name</code>：容器的完整名称。</li>\n<li><code>Command</code>：容器启动时执行的命令。</li>\n<li><code>State</code>：容器的状态，比如 <code>Up</code> (运行中)、<code>Exited</code> (已退出)、<code>Up (health: starting)</code> (正在启动健康检查)、<code>Up (healthy)</code> (健康)、<code>Up (unhealthy)</code> (不健康)。</li>\n<li><code>Ports</code>：端口映射信息（比如 <code>0.0.0.0:8080-&gt;80/tcp</code> 表示宿主机的 8080 端口映射到容器的 80 端口）。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>确认所有服务都成功启动。</li>\n<li>检查是否有服务异常退出 (<code>Exited</code>)。</li>\n<li>查看服务的健康检查状态 (<code>healthy</code>&#x2F;<code>unhealthy</code>)。</li>\n<li>确认端口映射是否正确。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📜-4-docker-compose-logs：看一看服务里发生了啥？\"><a href=\"#📜-4-docker-compose-logs：看一看服务里发生了啥？\" class=\"headerlink\" title=\"📜 4. docker-compose logs：看一看服务里发生了啥？\"></a>📜 4. <code>docker-compose logs</code>：看一看服务里发生了啥？</h2><p>当服务启动失败、异常退出，或者运行不正常时，查看它的日志是定位问题最直接的方式。<code>docker-compose logs</code> 命令可以<strong>显示你的 Docker Compose 项目中一个或多个服务的标准输出和标准错误日志</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前项目里所有服务的历史日志</span></span><br><span class=\"line\">docker-compose logs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -f (或 --follow)：实时追踪并显示新的日志输出</span></span><br><span class=\"line\"><span class=\"comment\"># 这在调试时非常有用，可以看到服务启动过程中的详细信息或运行时的错误</span></span><br><span class=\"line\">docker-compose logs -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看特定服务的日志</span></span><br><span class=\"line\">docker-compose logs app db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实时追踪特定服务的日志</span></span><br><span class=\"line\">docker-compose logs -f app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --tail number：只显示日志的最后 N 行</span></span><br><span class=\"line\">docker-compose logs --<span class=\"built_in\">tail</span> 50 app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合使用：实时追踪特定服务日志的最后100行（先显示历史的后100行，再追踪新的）</span></span><br><span class=\"line\">docker-compose logs -f --<span class=\"built_in\">tail</span> 100 app</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：获取并显示一个或多个容器的日志流。</li>\n<li><strong>使用场景</strong>：<ul>\n<li>排查服务启动失败的原因。</li>\n<li>监控服务的运行状态和输出信息。</li>\n<li>调试应用代码时查看打印的日志。</li>\n<li>了解服务内部的详细执行过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🏃-5-docker-compose-exec：钻进容器里“搞事情”！\"><a href=\"#🏃-5-docker-compose-exec：钻进容器里“搞事情”！\" class=\"headerlink\" title=\"🏃 5. docker-compose exec：钻进容器里“搞事情”！\"></a>🏃 5. <code>docker-compose exec</code>：钻进容器里“搞事情”！</h2><p>有时候你需要直接在运行中的容器里执行一些命令，比如进入一个 Web 容器的终端查看文件，或者进入数据库容器执行 SQL 命令，或者在应用容器里运行一个临时的脚本。<code>docker-compose exec</code> 命令就是用来<strong>在指定的运行中容器里执行命令</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：在 app 容器里执行一个简单的命令 (比如 ls -l)</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> app <span class=\"built_in\">ls</span> -l /app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -it：分配一个伪终端并保持标准输入开放</span></span><br><span class=\"line\"><span class=\"comment\"># 这对于进入交互式 shell (比如 bash) 是必须的</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> -it app bash <span class=\"comment\"># 进入 app 容器的 bash 终端</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 db 容器，并使用 mysql 客户端连接数据库</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：这里的 mysql 命令是在 db 容器内部执行的</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> -it db mysql -u root -p <span class=\"comment\"># 会提示输入密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在特定的服务容器里运行一个迁移脚本</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> app npm run migrate</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：在一个已经运行的容器内部执行任意命令。</li>\n<li><strong>使用场景</strong>：<ul>\n<li>调试：查看容器内的文件、环境变量、进程等。</li>\n<li>执行维护任务：运行数据库迁移、清理缓存等一次性脚本。</li>\n<li>获取交互式终端：像 SSH 一样进入容器内部操作。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧱-6-docker-compose-build：只构建镜像，不启动！\"><a href=\"#🧱-6-docker-compose-build：只构建镜像，不启动！\" class=\"headerlink\" title=\"🧱 6. docker-compose build：只构建镜像，不启动！\"></a>🧱 6. <code>docker-compose build</code>：只构建镜像，不启动！</h2><p>如果你的服务使用了 <code>build</code> 配置，<code>docker-compose up --build</code> 会在启动前构建镜像。但有时候你可能只想检查你的 <code>Dockerfile</code> 是否能成功构建，或者在部署前预先构建好所有镜像，而不想立即启动服务。<code>docker-compose build</code> 命令就是用来<strong>单独构建或重新构建服务镜像</strong>的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建当前项目里所有带有 build 配置的服务镜像</span></span><br><span class=\"line\">docker-compose build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --no-cache：构建时禁用缓存</span></span><br><span class=\"line\"><span class=\"comment\"># 用于确保完全从头开始构建，排除缓存引起的问题</span></span><br><span class=\"line\">docker-compose build --no-cache app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只构建特定的服务镜像</span></span><br><span class=\"line\">docker-compose build app db</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：根据 <code>Dockerfile</code> 构建（或重新构建）服务镜像，但不创建或启动容器。</li>\n<li><strong>与 <code>up --build</code> 的区别</strong>：<ul>\n<li><code>docker-compose build</code>：只构建镜像。</li>\n<li><code>docker-compose up --build</code>：构建镜像后，继续创建和启动容器。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>在 CI&#x2F;CD 流水线中，先构建镜像并推送到仓库。</li>\n<li>验证 <code>Dockerfile</code> 的正确性。</li>\n<li>预先准备好镜像，等待后续启动。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"总结一下，常用的-Docker-Compose-命令就是这几个：\"><a href=\"#总结一下，常用的-Docker-Compose-命令就是这几个：\" class=\"headerlink\" title=\"总结一下，常用的 Docker Compose 命令就是这几个：\"></a>总结一下，常用的 Docker Compose 命令就是这几个：</h2><ul>\n<li><code>docker-compose up -d</code>：启动你的应用（后台）。</li>\n<li><code>docker-compose down</code>：停止并清理你的应用。</li>\n<li><code>docker-compose ps</code>：查看你的服务状态。</li>\n<li><code>docker-compose logs -f [服务名]</code>：实时查看服务日志。</li>\n<li><code>docker-compose exec -it [服务名] bash</code>：进入容器终端进行调试。</li>\n<li><code>docker-compose build [服务名]</code>：只构建镜像。</li>\n</ul>\n<p>掌握了这些命令，你就拿到了操作 Docker Compose 的“遥控器”，可以随心所欲地启动、停止和管理你的容器化应用栈了！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了 Docker Compose 最基础和最重要的几个命令：</p>\n<ul>\n<li><code>up</code>：启动应用栈。</li>\n<li><code>down</code>：停止并清理应用栈。</li>\n<li><code>ps</code>：查看服务状态。</li>\n<li><code>logs</code>：查看服务日志。</li>\n<li><code>exec</code>：在容器内部执行命令。</li>\n<li><code>build</code>：单独构建镜像。</li>\n</ul>\n<p>这些命令是日常使用 Docker Compose 的基石。但在实际应用中，服务的启动顺序、依赖关系、以及如何判断一个服务是否“真正准备好”是非常关键的问题。下一章，我们将深入探讨 <code>depends_on</code> 和 <code>healthcheck</code> 的高级用法，学习如何确保你的服务按正确顺序启动，并且能够互相可靠地通信！敬请期待！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-Docker-Compose-命令宝典-让你的应用栈“动”起来！\"><a href=\"#🐳-Docker-Compose-命令宝典-让你的应用栈“动”起来！\" class=\"headerlink\" title=\"🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！\"></a>🐳 Docker Compose 命令宝典 - 让你的应用栈“动”起来！</h1><p>嘿！你已经学会了如何用 <code>docker-compose.yml</code> 文件来描述你的应用栈（服务、卷、网络）。这就像有了一张详细的建筑图纸，告诉你你的应用需要哪些“房间”（服务）、“仓库”（卷）、“走廊”（网络），以及它们各自的配置。</p>\n<p>但是，光有图纸还不够啊！我们得把它变成现实，把这些“房间”盖起来，让它们“住人”（运行容器），让它们“通电通水”（网络连接），让“仓库”能存东西！</p>\n<p>这就轮到 <strong>Docker Compose 的命令行工具</strong>登场了！它们是把你的 <code>yml</code> 图纸变成眼前跑着的容器的魔法棒。掌握这些命令，你就能轻松地启动、停止、管理和调试你的整个应用了。</p>\n<p>今天，我们就来学习 Docker Compose 最最常用、也最重要的几个命令！</p>\n<hr>\n<h2 id=\"🚀-1-docker-compose-up：启动你的整个应用！\"><a href=\"#🚀-1-docker-compose-up：启动你的整个应用！\" class=\"headerlink\" title=\"🚀 1. docker-compose up：启动你的整个应用！\"></a>🚀 1. <code>docker-compose up</code>：启动你的整个应用！</h2><p>这是你使用 Docker Compose 时最频繁的命令，它的作用就是<strong>根据你的 <code>docker-compose.yml</code> 文件，创建并启动所有定义的服务</strong>。</p>\n<p>想象一下，你有一堆乐高积木的说明书（<code>docker-compose.yml</code>），<code>docker-compose up</code> 就是那个“开始拼装并启动”的按钮！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：启动你的项目里的所有服务</span></span><br><span class=\"line\">docker-compose up</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -d：以后台（分离）模式运行</span></span><br><span class=\"line\"><span class=\"comment\"># 这是最常用的方式，启动后终端不会被容器日志霸占</span></span><br><span class=\"line\">docker-compose up -d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --build：在启动前强制重新构建有 build 配置的服务镜像</span></span><br><span class=\"line\"><span class=\"comment\"># 当你改动了本地代码或者 Dockerfile 时，就需要加上这个</span></span><br><span class=\"line\">docker-compose up -d --build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --force-recreate：强制重新创建容器，即使配置没有变化</span></span><br><span class=\"line\"><span class=\"comment\"># 有时候用来解决一些奇怪的问题，或者确保应用了某些非配置类的改动（比如资源限制）</span></span><br><span class=\"line\">docker-compose up -d --force-recreate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只启动特定的服务（以及它们的依赖）</span></span><br><span class=\"line\"><span class=\"comment\"># 比如只启动 app 服务，如果 app 依赖 db，db 也会被启动</span></span><br><span class=\"line\">docker-compose up -d app db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果你的 docker-compose.yml 文件不在当前目录，或者名字不是 docker-compose.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 可以用 -f 参数指定文件</span></span><br><span class=\"line\">docker-compose -f /path/to/your/compose.yml up -d</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：读取 <code>docker-compose.yml</code> 文件，执行构建（如果需要）、创建网络、创建卷、创建容器，并启动所有服务。</li>\n<li><strong>流程</strong>：<ol>\n<li>Docker Compose 读取当前目录（或 <code>-f</code> 指定）的 <code>docker-compose.yml</code> 文件。</li>\n<li>根据顶层 <code>networks</code> 定义，创建自定义网络（如果不存在）。</li>\n<li>根据顶层 <code>volumes</code> 定义，创建命名卷（如果不存在）。</li>\n<li>遍历 <code>services</code> 里的每个服务。</li>\n<li>如果服务有 <code>build</code> 配置，Docker Compose 会根据 <code>Dockerfile</code> 构建镜像（如果本地没有或者加了 <code>--build</code>）。</li>\n<li>如果服务有 <code>image</code> 配置，Docker Compose 会尝试拉取镜像（如果本地没有）。</li>\n<li>根据 <code>depends_on</code> 配置的服务依赖关系，按顺序创建和启动容器。</li>\n<li>将容器连接到指定的网络，进行端口映射，挂载数据卷，设置环境变量等等。</li>\n<li>启动容器里定义的应用进程。</li>\n</ol>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>第一次运行你的 Docker Compose 项目。</li>\n<li>在开发环境中启动整个应用栈。</li>\n<li>更新了代码或配置文件后，重新部署服务。</li>\n<li>从停止状态恢复运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🛑-2-docker-compose-down：优雅地停止并移除你的应用！\"><a href=\"#🛑-2-docker-compose-down：优雅地停止并移除你的应用！\" class=\"headerlink\" title=\"🛑 2. docker-compose down：优雅地停止并移除你的应用！\"></a>🛑 2. <code>docker-compose down</code>：优雅地停止并移除你的应用！</h2><p>当你不需要运行你的应用栈时，直接关闭终端或者强制停止 Docker 可能导致资源残留。<code>docker-compose down</code> 是最推荐的方式来停止并清理你的 Docker Compose 项目。</p>\n<p>它就像是那个“关闭并拆除”的按钮，会停止所有运行中的容器，并移除与该项目相关的容器、网络和（可选）卷。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：停止并移除当前项目的所有容器和网络</span></span><br><span class=\"line\">docker-compose down</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -v (或 --volumes)：同时移除声明在 yml 文件顶层的命名卷</span></span><br><span class=\"line\"><span class=\"comment\"># **注意！** 这个操作会删除命名卷里存储的数据，慎用！</span></span><br><span class=\"line\">docker-compose down -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --rmi type：移除服务使用的镜像</span></span><br><span class=\"line\"><span class=\"comment\"># type 可以是 &#x27;local&#x27; (只移除 build 的镜像) 或 &#x27;all&#x27; (移除所有)</span></span><br><span class=\"line\"><span class=\"comment\"># 不常用，一般不删除镜像，除非是彻底清理</span></span><br><span class=\"line\">docker-compose down --rmi <span class=\"built_in\">local</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --remove-orphans：移除那些不再被当前 docker-compose.yml 文件定义的容器</span></span><br><span class=\"line\"><span class=\"comment\"># 有时候yml改动了，旧容器还在，可以用这个清理</span></span><br><span class=\"line\">docker-compose down --remove-orphans</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：停止并删除由 <code>docker-compose up</code> 创建的容器、默认网络以及顶层定义的网络。可以选泽是否删除命名卷和镜像。</li>\n<li><strong>流程</strong>：<ol>\n<li>Docker Compose 识别出当前项目相关的容器和网络。</li>\n<li>按依赖关系的逆序（先停止依赖别人的服务），优雅地发送停止信号给容器。</li>\n<li>移除容器。</li>\n<li>移除项目默认创建的网络和顶层定义的网络。</li>\n<li>如果指定了 <code>-v</code>，则移除顶层声明的命名卷。</li>\n<li>如果指定了 <code>--rmi</code>，则移除相应的镜像。</li>\n</ol>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>关闭开发环境。</li>\n<li>进行大的项目配置或代码改动前，先完全停止清理。</li>\n<li>彻底移除一个不再需要的应用栈。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"👀-3-docker-compose-ps：看看你的服务“活”得怎么样？\"><a href=\"#👀-3-docker-compose-ps：看看你的服务“活”得怎么样？\" class=\"headerlink\" title=\"👀 3. docker-compose ps：看看你的服务“活”得怎么样？\"></a>👀 3. <code>docker-compose ps</code>：看看你的服务“活”得怎么样？</h2><p><code>docker-compose up</code> 之后，你怎么知道你的服务是不是都正常运行了？<code>docker-compose ps</code> 命令就是用来<strong>查看你的 Docker Compose 项目中所有服务的状态</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前项目里所有服务的状态</span></span><br><span class=\"line\">docker-compose ps</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：列出当前 Docker Compose 项目所管理的所有容器，显示它们的名字、命令、状态、端口映射等信息。</li>\n<li><strong>输出解读</strong>：<ul>\n<li><code>Name</code>：容器的完整名称。</li>\n<li><code>Command</code>：容器启动时执行的命令。</li>\n<li><code>State</code>：容器的状态，比如 <code>Up</code> (运行中)、<code>Exited</code> (已退出)、<code>Up (health: starting)</code> (正在启动健康检查)、<code>Up (healthy)</code> (健康)、<code>Up (unhealthy)</code> (不健康)。</li>\n<li><code>Ports</code>：端口映射信息（比如 <code>0.0.0.0:8080-&gt;80/tcp</code> 表示宿主机的 8080 端口映射到容器的 80 端口）。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>确认所有服务都成功启动。</li>\n<li>检查是否有服务异常退出 (<code>Exited</code>)。</li>\n<li>查看服务的健康检查状态 (<code>healthy</code>&#x2F;<code>unhealthy</code>)。</li>\n<li>确认端口映射是否正确。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📜-4-docker-compose-logs：看一看服务里发生了啥？\"><a href=\"#📜-4-docker-compose-logs：看一看服务里发生了啥？\" class=\"headerlink\" title=\"📜 4. docker-compose logs：看一看服务里发生了啥？\"></a>📜 4. <code>docker-compose logs</code>：看一看服务里发生了啥？</h2><p>当服务启动失败、异常退出，或者运行不正常时，查看它的日志是定位问题最直接的方式。<code>docker-compose logs</code> 命令可以<strong>显示你的 Docker Compose 项目中一个或多个服务的标准输出和标准错误日志</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前项目里所有服务的历史日志</span></span><br><span class=\"line\">docker-compose logs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -f (或 --follow)：实时追踪并显示新的日志输出</span></span><br><span class=\"line\"><span class=\"comment\"># 这在调试时非常有用，可以看到服务启动过程中的详细信息或运行时的错误</span></span><br><span class=\"line\">docker-compose logs -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看特定服务的日志</span></span><br><span class=\"line\">docker-compose logs app db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实时追踪特定服务的日志</span></span><br><span class=\"line\">docker-compose logs -f app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --tail number：只显示日志的最后 N 行</span></span><br><span class=\"line\">docker-compose logs --<span class=\"built_in\">tail</span> 50 app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结合使用：实时追踪特定服务日志的最后100行（先显示历史的后100行，再追踪新的）</span></span><br><span class=\"line\">docker-compose logs -f --<span class=\"built_in\">tail</span> 100 app</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：获取并显示一个或多个容器的日志流。</li>\n<li><strong>使用场景</strong>：<ul>\n<li>排查服务启动失败的原因。</li>\n<li>监控服务的运行状态和输出信息。</li>\n<li>调试应用代码时查看打印的日志。</li>\n<li>了解服务内部的详细执行过程。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🏃-5-docker-compose-exec：钻进容器里“搞事情”！\"><a href=\"#🏃-5-docker-compose-exec：钻进容器里“搞事情”！\" class=\"headerlink\" title=\"🏃 5. docker-compose exec：钻进容器里“搞事情”！\"></a>🏃 5. <code>docker-compose exec</code>：钻进容器里“搞事情”！</h2><p>有时候你需要直接在运行中的容器里执行一些命令，比如进入一个 Web 容器的终端查看文件，或者进入数据库容器执行 SQL 命令，或者在应用容器里运行一个临时的脚本。<code>docker-compose exec</code> 命令就是用来<strong>在指定的运行中容器里执行命令</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基本用法：在 app 容器里执行一个简单的命令 (比如 ls -l)</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> app <span class=\"built_in\">ls</span> -l /app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 -it：分配一个伪终端并保持标准输入开放</span></span><br><span class=\"line\"><span class=\"comment\"># 这对于进入交互式 shell (比如 bash) 是必须的</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> -it app bash <span class=\"comment\"># 进入 app 容器的 bash 终端</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 db 容器，并使用 mysql 客户端连接数据库</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：这里的 mysql 命令是在 db 容器内部执行的</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> -it db mysql -u root -p <span class=\"comment\"># 会提示输入密码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在特定的服务容器里运行一个迁移脚本</span></span><br><span class=\"line\">docker-compose <span class=\"built_in\">exec</span> app npm run migrate</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：在一个已经运行的容器内部执行任意命令。</li>\n<li><strong>使用场景</strong>：<ul>\n<li>调试：查看容器内的文件、环境变量、进程等。</li>\n<li>执行维护任务：运行数据库迁移、清理缓存等一次性脚本。</li>\n<li>获取交互式终端：像 SSH 一样进入容器内部操作。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧱-6-docker-compose-build：只构建镜像，不启动！\"><a href=\"#🧱-6-docker-compose-build：只构建镜像，不启动！\" class=\"headerlink\" title=\"🧱 6. docker-compose build：只构建镜像，不启动！\"></a>🧱 6. <code>docker-compose build</code>：只构建镜像，不启动！</h2><p>如果你的服务使用了 <code>build</code> 配置，<code>docker-compose up --build</code> 会在启动前构建镜像。但有时候你可能只想检查你的 <code>Dockerfile</code> 是否能成功构建，或者在部署前预先构建好所有镜像，而不想立即启动服务。<code>docker-compose build</code> 命令就是用来<strong>单独构建或重新构建服务镜像</strong>的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 构建当前项目里所有带有 build 配置的服务镜像</span></span><br><span class=\"line\">docker-compose build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常用选项 --no-cache：构建时禁用缓存</span></span><br><span class=\"line\"><span class=\"comment\"># 用于确保完全从头开始构建，排除缓存引起的问题</span></span><br><span class=\"line\">docker-compose build --no-cache app</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只构建特定的服务镜像</span></span><br><span class=\"line\">docker-compose build app db</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：根据 <code>Dockerfile</code> 构建（或重新构建）服务镜像，但不创建或启动容器。</li>\n<li><strong>与 <code>up --build</code> 的区别</strong>：<ul>\n<li><code>docker-compose build</code>：只构建镜像。</li>\n<li><code>docker-compose up --build</code>：构建镜像后，继续创建和启动容器。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>在 CI&#x2F;CD 流水线中，先构建镜像并推送到仓库。</li>\n<li>验证 <code>Dockerfile</code> 的正确性。</li>\n<li>预先准备好镜像，等待后续启动。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"总结一下，常用的-Docker-Compose-命令就是这几个：\"><a href=\"#总结一下，常用的-Docker-Compose-命令就是这几个：\" class=\"headerlink\" title=\"总结一下，常用的 Docker Compose 命令就是这几个：\"></a>总结一下，常用的 Docker Compose 命令就是这几个：</h2><ul>\n<li><code>docker-compose up -d</code>：启动你的应用（后台）。</li>\n<li><code>docker-compose down</code>：停止并清理你的应用。</li>\n<li><code>docker-compose ps</code>：查看你的服务状态。</li>\n<li><code>docker-compose logs -f [服务名]</code>：实时查看服务日志。</li>\n<li><code>docker-compose exec -it [服务名] bash</code>：进入容器终端进行调试。</li>\n<li><code>docker-compose build [服务名]</code>：只构建镜像。</li>\n</ul>\n<p>掌握了这些命令，你就拿到了操作 Docker Compose 的“遥控器”，可以随心所欲地启动、停止和管理你的容器化应用栈了！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了 Docker Compose 最基础和最重要的几个命令：</p>\n<ul>\n<li><code>up</code>：启动应用栈。</li>\n<li><code>down</code>：停止并清理应用栈。</li>\n<li><code>ps</code>：查看服务状态。</li>\n<li><code>logs</code>：查看服务日志。</li>\n<li><code>exec</code>：在容器内部执行命令。</li>\n<li><code>build</code>：单独构建镜像。</li>\n</ul>\n<p>这些命令是日常使用 Docker Compose 的基石。但在实际应用中，服务的启动顺序、依赖关系、以及如何判断一个服务是否“真正准备好”是非常关键的问题。下一章，我们将深入探讨 <code>depends_on</code> 和 <code>healthcheck</code> 的高级用法，学习如何确保你的服务按正确顺序启动，并且能够互相可靠地通信！敬请期待！</p>\n"},{"title":"🐳 Dockerfile + Docker Compose 教程（含字段注释）","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":48960,"date":"2025-06-06T16:00:00.000Z","_content":"\n# 🐳 Dockerfile + Docker Compose 教程（含字段注释）\n\n---\n\n## 📦 一、Dockerfile 教程（构建镜像）\n\n`Dockerfile` 是用于定义 Docker 镜像内容的脚本。你可以用它自动打包部署环境和项目。\n\n### 📁 示例：构建一个 Node.js 应用镜像\n\n```dockerfile\n# 使用官方 Node 镜像作为基础镜像\nFROM node:18\n\n# 设置容器内的工作目录\nWORKDIR /app\n\n# 复制依赖文件（更高缓存利用）\nCOPY package*.json ./\n\n# 安装依赖\nRUN npm install\n\n# 复制项目文件到容器\nCOPY . .\n\n# 映射端口（仅用于文档说明，实际映射需用 docker run 或 docker-compose）\nEXPOSE 3000\n\n# 启动应用\nCMD [\"npm\", \"start\"]\n```\n\n### 🧾 字段解释\n\n| 指令      | 含义                               |\n| --------- | ---------------------------------- |\n| `FROM`    | 指定基础镜像                       |\n| `WORKDIR` | 设置容器中的工作目录               |\n| `COPY`    | 将文件复制进镜像                   |\n| `RUN`     | 执行命令（在构建时执行）           |\n| `EXPOSE`  | 声明容器会监听的端口（非实际映射） |\n| `CMD`     | 容器启动时执行的默认命令           |\n\n---\n\n## 🧩 二、Docker Compose 教程（管理多容器）\n\n`docker-compose.yml` 是用来定义多个服务（容器）的配置文件，常用于本地开发或测试部署。\n\n---\n\n### 🌐 示例：Node.js + MongoDB 服务组合\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build:\n      context: .              # Dockerfile 所在路径\n      dockerfile: Dockerfile # 可选指定文件名\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n    depends_on:\n      - mongo\n    environment:\n      - MONGO_URL=mongodb://mongo:27017/mydb\n    command: [\"npm\", \"run\", \"dev\"]\n    restart: always\n    networks:\n      - backend\n\n  mongo:\n    image: mongo:6\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongo-data:/data/db\n    restart: on-failure\n    networks:\n      - backend\n\nvolumes:\n  mongo-data:\n\nnetworks:\n  backend:\n```\n\n---\n\n### 🧾 所有常用字段注解（Compose v3.8）\n\n#### ✅ 根级字段\n\n| 字段       | 说明                       |\n| ---------- | -------------------------- |\n| `version`  | Compose 文件的语法版本     |\n| `services` | 所有要运行的服务（容器）   |\n| `volumes`  | 声明可复用的数据卷         |\n| `networks` | 声明自定义网络             |\n| `configs`  | 管理配置文件（高级用法）   |\n| `secrets`  | 管理敏感数据，如密码、证书 |\n\n---\n\n#### ✅ `services` 下常见字段\n\n| 字段                   | 类型          | 说明                                                           |\n| ---------------------- | ------------- | -------------------------------------------------------------- |\n| `image`                | string        | 使用已有镜像                                                   |\n| `build`                | object/string | 使用 Dockerfile 构建镜像（支持配置项）                         |\n| `context`              | string        | 构建上下文路径                                                 |\n| `dockerfile`           | string        | Dockerfile 文件名                                              |\n| `ports`                | list          | 端口映射（主机:容器）                                          |\n| `volumes`              | list          | 数据卷挂载（持久化或挂载代码）                                 |\n| `environment`          | list/map      | 设置环境变量                                                   |\n| `env_file`             | string/list   | 从文件中读取环境变量                                           |\n| `depends_on`           | list          | 定义服务之间的启动顺序                                         |\n| `command`              | string/list   | 覆盖容器启动时默认命令                                         |\n| `entrypoint`           | string/list   | 覆盖默认 entrypoint                                            |\n| `restart`              | string        | 容器重启策略（`no`, `always`, `on-failure`, `unless-stopped`） |\n| `networks`             | list          | 加入一个或多个网络                                             |\n| `hostname`             | string        | 容器主机名                                                     |\n| `extra_hosts`          | list          | 添加 hosts 映射（本地 DNS）                                    |\n| `logging`              | object        | 配置日志驱动                                                   |\n| `healthcheck`          | object        | 设置健康检查                                                   |\n| `tty`                  | bool          | 分配 TTY 伪终端（多用于交互容器）                              |\n| `stdin_open`           | bool          | 保持 STDIN 打开（`docker run -i`）                             |\n| `depends_on.condition` | object        | 控制服务依赖条件（需要配合 `healthcheck`）                     |\n\n---\n\n#### ✅ `volumes` 下字段\n\n```yaml\nvolumes:\n  db-data:\n    driver: local         # 存储驱动\n    driver_opts:          # 驱动参数\n      type: none\n      device: /my/data\n      o: bind\n```\n\n---\n\n#### ✅ `networks` 下字段\n\n```yaml\nnetworks:\n  backend:\n    driver: bridge        # 网络驱动（默认为 bridge）\n    ipam:                 # 自定义 IP 地址管理（可选）\n      config:\n        - subnet: 172.16.238.0/24\n```\n\n---\n\n#### ✅ `configs` & `secrets`（仅 Swarm 模式）\n\n```yaml\nconfigs:\n  my_config:\n    file: ./config.json\n\nsecrets:\n  db_password:\n    file: ./pw.txt\n```\n\n---\n\n## 🚀 三、常用命令速查\n\n| 命令                           | 说明                   |\n| ------------------------------ | ---------------------- |\n| `docker-compose up`            | 构建 + 启动所有服务    |\n| `docker-compose up -d`         | 后台运行               |\n| `docker-compose down`          | 停止并清理容器、网络等 |\n| `docker-compose ps`            | 查看运行中的服务       |\n| `docker-compose logs -f`       | 查看日志               |\n| `docker-compose exec app bash` | 进入容器终端           |\n| `docker-compose build`         | 仅构建镜像，不启动     |\n| `docker-compose stop`          | 暂停服务，不删除容器   |\n| `docker-compose restart`       | 重启服务               |\n\n---\n\n## 🧯 四、常见问题排查\n\n| 问题             | 原因                          | 解决方法                                       |\n| ---------------- | ----------------------------- | ---------------------------------------------- |\n| 服务端口访问不到 | `ports` 映射未设置或被占用    | 确认 `宿主机:容器端口` 正确且未冲突            |\n| 代码热更新无效   | 未挂载 `volumes` 或 Node 缓存 | 检查 `volumes`，可加 `nodemon`                 |\n| 数据丢失         | 缺少数据卷挂载                | 添加 `volumes`，确保路径正确                   |\n| 服务顺序问题     | `depends_on` 无法确保服务就绪 | 使用 `healthcheck` 配合 `depends_on.condition` |\n\n---\n\n## 📘 五、推荐项目结构\n\n```\nmy-app/\n├── docker-compose.yml\n├── Dockerfile\n├── .env\n├── package.json\n├── config/\n├── secrets/\n└── src/\n    └── index.js\n```\n\n---\n\n## 📚 六、延伸阅读\n\n- Docker 官方文档：https://docs.docker.com/\n- Compose 文件语法参考：https://docs.docker.com/compose/compose-file/\n- 官方 Compose 示例：https://github.com/docker/awesome-compose\n- Swarm 集群：https://docs.docker.com/engine/swarm/\n\n---\n\n> 作者：**[937bb]**  \n> 本文适用于初学者与中小团队服务部署使用，转载请注明出处 🐳\n","source":"_posts/Docker/Docker Compose 教程（含字段注释）.md","raw":"---\ntitle: \"\\U0001F433 Dockerfile + Docker Compose 教程（含字段注释）\"\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 48960\ndate: 2025-06-07 00:00:00\n---\n\n# 🐳 Dockerfile + Docker Compose 教程（含字段注释）\n\n---\n\n## 📦 一、Dockerfile 教程（构建镜像）\n\n`Dockerfile` 是用于定义 Docker 镜像内容的脚本。你可以用它自动打包部署环境和项目。\n\n### 📁 示例：构建一个 Node.js 应用镜像\n\n```dockerfile\n# 使用官方 Node 镜像作为基础镜像\nFROM node:18\n\n# 设置容器内的工作目录\nWORKDIR /app\n\n# 复制依赖文件（更高缓存利用）\nCOPY package*.json ./\n\n# 安装依赖\nRUN npm install\n\n# 复制项目文件到容器\nCOPY . .\n\n# 映射端口（仅用于文档说明，实际映射需用 docker run 或 docker-compose）\nEXPOSE 3000\n\n# 启动应用\nCMD [\"npm\", \"start\"]\n```\n\n### 🧾 字段解释\n\n| 指令      | 含义                               |\n| --------- | ---------------------------------- |\n| `FROM`    | 指定基础镜像                       |\n| `WORKDIR` | 设置容器中的工作目录               |\n| `COPY`    | 将文件复制进镜像                   |\n| `RUN`     | 执行命令（在构建时执行）           |\n| `EXPOSE`  | 声明容器会监听的端口（非实际映射） |\n| `CMD`     | 容器启动时执行的默认命令           |\n\n---\n\n## 🧩 二、Docker Compose 教程（管理多容器）\n\n`docker-compose.yml` 是用来定义多个服务（容器）的配置文件，常用于本地开发或测试部署。\n\n---\n\n### 🌐 示例：Node.js + MongoDB 服务组合\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build:\n      context: .              # Dockerfile 所在路径\n      dockerfile: Dockerfile # 可选指定文件名\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n    depends_on:\n      - mongo\n    environment:\n      - MONGO_URL=mongodb://mongo:27017/mydb\n    command: [\"npm\", \"run\", \"dev\"]\n    restart: always\n    networks:\n      - backend\n\n  mongo:\n    image: mongo:6\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongo-data:/data/db\n    restart: on-failure\n    networks:\n      - backend\n\nvolumes:\n  mongo-data:\n\nnetworks:\n  backend:\n```\n\n---\n\n### 🧾 所有常用字段注解（Compose v3.8）\n\n#### ✅ 根级字段\n\n| 字段       | 说明                       |\n| ---------- | -------------------------- |\n| `version`  | Compose 文件的语法版本     |\n| `services` | 所有要运行的服务（容器）   |\n| `volumes`  | 声明可复用的数据卷         |\n| `networks` | 声明自定义网络             |\n| `configs`  | 管理配置文件（高级用法）   |\n| `secrets`  | 管理敏感数据，如密码、证书 |\n\n---\n\n#### ✅ `services` 下常见字段\n\n| 字段                   | 类型          | 说明                                                           |\n| ---------------------- | ------------- | -------------------------------------------------------------- |\n| `image`                | string        | 使用已有镜像                                                   |\n| `build`                | object/string | 使用 Dockerfile 构建镜像（支持配置项）                         |\n| `context`              | string        | 构建上下文路径                                                 |\n| `dockerfile`           | string        | Dockerfile 文件名                                              |\n| `ports`                | list          | 端口映射（主机:容器）                                          |\n| `volumes`              | list          | 数据卷挂载（持久化或挂载代码）                                 |\n| `environment`          | list/map      | 设置环境变量                                                   |\n| `env_file`             | string/list   | 从文件中读取环境变量                                           |\n| `depends_on`           | list          | 定义服务之间的启动顺序                                         |\n| `command`              | string/list   | 覆盖容器启动时默认命令                                         |\n| `entrypoint`           | string/list   | 覆盖默认 entrypoint                                            |\n| `restart`              | string        | 容器重启策略（`no`, `always`, `on-failure`, `unless-stopped`） |\n| `networks`             | list          | 加入一个或多个网络                                             |\n| `hostname`             | string        | 容器主机名                                                     |\n| `extra_hosts`          | list          | 添加 hosts 映射（本地 DNS）                                    |\n| `logging`              | object        | 配置日志驱动                                                   |\n| `healthcheck`          | object        | 设置健康检查                                                   |\n| `tty`                  | bool          | 分配 TTY 伪终端（多用于交互容器）                              |\n| `stdin_open`           | bool          | 保持 STDIN 打开（`docker run -i`）                             |\n| `depends_on.condition` | object        | 控制服务依赖条件（需要配合 `healthcheck`）                     |\n\n---\n\n#### ✅ `volumes` 下字段\n\n```yaml\nvolumes:\n  db-data:\n    driver: local         # 存储驱动\n    driver_opts:          # 驱动参数\n      type: none\n      device: /my/data\n      o: bind\n```\n\n---\n\n#### ✅ `networks` 下字段\n\n```yaml\nnetworks:\n  backend:\n    driver: bridge        # 网络驱动（默认为 bridge）\n    ipam:                 # 自定义 IP 地址管理（可选）\n      config:\n        - subnet: 172.16.238.0/24\n```\n\n---\n\n#### ✅ `configs` & `secrets`（仅 Swarm 模式）\n\n```yaml\nconfigs:\n  my_config:\n    file: ./config.json\n\nsecrets:\n  db_password:\n    file: ./pw.txt\n```\n\n---\n\n## 🚀 三、常用命令速查\n\n| 命令                           | 说明                   |\n| ------------------------------ | ---------------------- |\n| `docker-compose up`            | 构建 + 启动所有服务    |\n| `docker-compose up -d`         | 后台运行               |\n| `docker-compose down`          | 停止并清理容器、网络等 |\n| `docker-compose ps`            | 查看运行中的服务       |\n| `docker-compose logs -f`       | 查看日志               |\n| `docker-compose exec app bash` | 进入容器终端           |\n| `docker-compose build`         | 仅构建镜像，不启动     |\n| `docker-compose stop`          | 暂停服务，不删除容器   |\n| `docker-compose restart`       | 重启服务               |\n\n---\n\n## 🧯 四、常见问题排查\n\n| 问题             | 原因                          | 解决方法                                       |\n| ---------------- | ----------------------------- | ---------------------------------------------- |\n| 服务端口访问不到 | `ports` 映射未设置或被占用    | 确认 `宿主机:容器端口` 正确且未冲突            |\n| 代码热更新无效   | 未挂载 `volumes` 或 Node 缓存 | 检查 `volumes`，可加 `nodemon`                 |\n| 数据丢失         | 缺少数据卷挂载                | 添加 `volumes`，确保路径正确                   |\n| 服务顺序问题     | `depends_on` 无法确保服务就绪 | 使用 `healthcheck` 配合 `depends_on.condition` |\n\n---\n\n## 📘 五、推荐项目结构\n\n```\nmy-app/\n├── docker-compose.yml\n├── Dockerfile\n├── .env\n├── package.json\n├── config/\n├── secrets/\n└── src/\n    └── index.js\n```\n\n---\n\n## 📚 六、延伸阅读\n\n- Docker 官方文档：https://docs.docker.com/\n- Compose 文件语法参考：https://docs.docker.com/compose/compose-file/\n- 官方 Compose 示例：https://github.com/docker/awesome-compose\n- Swarm 集群：https://docs.docker.com/engine/swarm/\n\n---\n\n> 作者：**[937bb]**  \n> 本文适用于初学者与中小团队服务部署使用，转载请注明出处 🐳\n","slug":"Docker/Docker Compose 教程（含字段注释）","published":1,"updated":"2025-06-07T15:58:53.663Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww6000fpkrc60aic9wa","content":"<h1 id=\"🐳-Dockerfile-Docker-Compose-教程（含字段注释）\"><a href=\"#🐳-Dockerfile-Docker-Compose-教程（含字段注释）\" class=\"headerlink\" title=\"🐳 Dockerfile + Docker Compose 教程（含字段注释）\"></a>🐳 Dockerfile + Docker Compose 教程（含字段注释）</h1><hr>\n<h2 id=\"📦-一、Dockerfile-教程（构建镜像）\"><a href=\"#📦-一、Dockerfile-教程（构建镜像）\" class=\"headerlink\" title=\"📦 一、Dockerfile 教程（构建镜像）\"></a>📦 一、Dockerfile 教程（构建镜像）</h2><p><code>Dockerfile</code> 是用于定义 Docker 镜像内容的脚本。你可以用它自动打包部署环境和项目。</p>\n<h3 id=\"📁-示例：构建一个-Node-js-应用镜像\"><a href=\"#📁-示例：构建一个-Node-js-应用镜像\" class=\"headerlink\" title=\"📁 示例：构建一个 Node.js 应用镜像\"></a>📁 示例：构建一个 Node.js 应用镜像</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用官方 Node 镜像作为基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器内的工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制依赖文件（更高缓存利用）</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package*.json ./</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制项目文件到容器</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 映射端口（仅用于文档说明，实际映射需用 docker run 或 docker-compose）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动应用</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🧾-字段解释\"><a href=\"#🧾-字段解释\" class=\"headerlink\" title=\"🧾 字段解释\"></a>🧾 字段解释</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FROM</code></td>\n<td>指定基础镜像</td>\n</tr>\n<tr>\n<td><code>WORKDIR</code></td>\n<td>设置容器中的工作目录</td>\n</tr>\n<tr>\n<td><code>COPY</code></td>\n<td>将文件复制进镜像</td>\n</tr>\n<tr>\n<td><code>RUN</code></td>\n<td>执行命令（在构建时执行）</td>\n</tr>\n<tr>\n<td><code>EXPOSE</code></td>\n<td>声明容器会监听的端口（非实际映射）</td>\n</tr>\n<tr>\n<td><code>CMD</code></td>\n<td>容器启动时执行的默认命令</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧩-二、Docker-Compose-教程（管理多容器）\"><a href=\"#🧩-二、Docker-Compose-教程（管理多容器）\" class=\"headerlink\" title=\"🧩 二、Docker Compose 教程（管理多容器）\"></a>🧩 二、Docker Compose 教程（管理多容器）</h2><p><code>docker-compose.yml</code> 是用来定义多个服务（容器）的配置文件，常用于本地开发或测试部署。</p>\n<hr>\n<h3 id=\"🌐-示例：Node-js-MongoDB-服务组合\"><a href=\"#🌐-示例：Node-js-MongoDB-服务组合\" class=\"headerlink\" title=\"🌐 示例：Node.js + MongoDB 服务组合\"></a>🌐 示例：Node.js + MongoDB 服务组合</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span>              <span class=\"comment\"># Dockerfile 所在路径</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 可选指定文件名</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MONGO_URL=mongodb://mongo:27017/mydb</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;dev&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">mongo:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo:6</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;27017:27017&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo-data:/data/db</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">on-failure</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🧾-所有常用字段注解（Compose-v3-8）\"><a href=\"#🧾-所有常用字段注解（Compose-v3-8）\" class=\"headerlink\" title=\"🧾 所有常用字段注解（Compose v3.8）\"></a>🧾 所有常用字段注解（Compose v3.8）</h3><h4 id=\"✅-根级字段\"><a href=\"#✅-根级字段\" class=\"headerlink\" title=\"✅ 根级字段\"></a>✅ 根级字段</h4><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>version</code></td>\n<td>Compose 文件的语法版本</td>\n</tr>\n<tr>\n<td><code>services</code></td>\n<td>所有要运行的服务（容器）</td>\n</tr>\n<tr>\n<td><code>volumes</code></td>\n<td>声明可复用的数据卷</td>\n</tr>\n<tr>\n<td><code>networks</code></td>\n<td>声明自定义网络</td>\n</tr>\n<tr>\n<td><code>configs</code></td>\n<td>管理配置文件（高级用法）</td>\n</tr>\n<tr>\n<td><code>secrets</code></td>\n<td>管理敏感数据，如密码、证书</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"✅-services-下常见字段\"><a href=\"#✅-services-下常见字段\" class=\"headerlink\" title=\"✅ services 下常见字段\"></a>✅ <code>services</code> 下常见字段</h4><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>image</code></td>\n<td>string</td>\n<td>使用已有镜像</td>\n</tr>\n<tr>\n<td><code>build</code></td>\n<td>object&#x2F;string</td>\n<td>使用 Dockerfile 构建镜像（支持配置项）</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>string</td>\n<td>构建上下文路径</td>\n</tr>\n<tr>\n<td><code>dockerfile</code></td>\n<td>string</td>\n<td>Dockerfile 文件名</td>\n</tr>\n<tr>\n<td><code>ports</code></td>\n<td>list</td>\n<td>端口映射（主机:容器）</td>\n</tr>\n<tr>\n<td><code>volumes</code></td>\n<td>list</td>\n<td>数据卷挂载（持久化或挂载代码）</td>\n</tr>\n<tr>\n<td><code>environment</code></td>\n<td>list&#x2F;map</td>\n<td>设置环境变量</td>\n</tr>\n<tr>\n<td><code>env_file</code></td>\n<td>string&#x2F;list</td>\n<td>从文件中读取环境变量</td>\n</tr>\n<tr>\n<td><code>depends_on</code></td>\n<td>list</td>\n<td>定义服务之间的启动顺序</td>\n</tr>\n<tr>\n<td><code>command</code></td>\n<td>string&#x2F;list</td>\n<td>覆盖容器启动时默认命令</td>\n</tr>\n<tr>\n<td><code>entrypoint</code></td>\n<td>string&#x2F;list</td>\n<td>覆盖默认 entrypoint</td>\n</tr>\n<tr>\n<td><code>restart</code></td>\n<td>string</td>\n<td>容器重启策略（<code>no</code>, <code>always</code>, <code>on-failure</code>, <code>unless-stopped</code>）</td>\n</tr>\n<tr>\n<td><code>networks</code></td>\n<td>list</td>\n<td>加入一个或多个网络</td>\n</tr>\n<tr>\n<td><code>hostname</code></td>\n<td>string</td>\n<td>容器主机名</td>\n</tr>\n<tr>\n<td><code>extra_hosts</code></td>\n<td>list</td>\n<td>添加 hosts 映射（本地 DNS）</td>\n</tr>\n<tr>\n<td><code>logging</code></td>\n<td>object</td>\n<td>配置日志驱动</td>\n</tr>\n<tr>\n<td><code>healthcheck</code></td>\n<td>object</td>\n<td>设置健康检查</td>\n</tr>\n<tr>\n<td><code>tty</code></td>\n<td>bool</td>\n<td>分配 TTY 伪终端（多用于交互容器）</td>\n</tr>\n<tr>\n<td><code>stdin_open</code></td>\n<td>bool</td>\n<td>保持 STDIN 打开（<code>docker run -i</code>）</td>\n</tr>\n<tr>\n<td><code>depends_on.condition</code></td>\n<td>object</td>\n<td>控制服务依赖条件（需要配合 <code>healthcheck</code>）</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"✅-volumes-下字段\"><a href=\"#✅-volumes-下字段\" class=\"headerlink\" title=\"✅ volumes 下字段\"></a>✅ <code>volumes</code> 下字段</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span>         <span class=\"comment\"># 存储驱动</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span>          <span class=\"comment\"># 驱动参数</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">none</span></span><br><span class=\"line\">      <span class=\"attr\">device:</span> <span class=\"string\">/my/data</span></span><br><span class=\"line\">      <span class=\"attr\">o:</span> <span class=\"string\">bind</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"✅-networks-下字段\"><a href=\"#✅-networks-下字段\" class=\"headerlink\" title=\"✅ networks 下字段\"></a>✅ <code>networks</code> 下字段</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>        <span class=\"comment\"># 网络驱动（默认为 bridge）</span></span><br><span class=\"line\">    <span class=\"attr\">ipam:</span>                 <span class=\"comment\"># 自定义 IP 地址管理（可选）</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">subnet:</span> <span class=\"number\">172.16</span><span class=\"number\">.238</span><span class=\"number\">.0</span><span class=\"string\">/24</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"✅-configs-secrets（仅-Swarm-模式）\"><a href=\"#✅-configs-secrets（仅-Swarm-模式）\" class=\"headerlink\" title=\"✅ configs &amp; secrets（仅 Swarm 模式）\"></a>✅ <code>configs</code> &amp; <code>secrets</code>（仅 Swarm 模式）</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">configs:</span></span><br><span class=\"line\">  <span class=\"attr\">my_config:</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./config.json</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secrets:</span></span><br><span class=\"line\">  <span class=\"attr\">db_password:</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./pw.txt</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-三、常用命令速查\"><a href=\"#🚀-三、常用命令速查\" class=\"headerlink\" title=\"🚀 三、常用命令速查\"></a>🚀 三、常用命令速查</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>docker-compose up</code></td>\n<td>构建 + 启动所有服务</td>\n</tr>\n<tr>\n<td><code>docker-compose up -d</code></td>\n<td>后台运行</td>\n</tr>\n<tr>\n<td><code>docker-compose down</code></td>\n<td>停止并清理容器、网络等</td>\n</tr>\n<tr>\n<td><code>docker-compose ps</code></td>\n<td>查看运行中的服务</td>\n</tr>\n<tr>\n<td><code>docker-compose logs -f</code></td>\n<td>查看日志</td>\n</tr>\n<tr>\n<td><code>docker-compose exec app bash</code></td>\n<td>进入容器终端</td>\n</tr>\n<tr>\n<td><code>docker-compose build</code></td>\n<td>仅构建镜像，不启动</td>\n</tr>\n<tr>\n<td><code>docker-compose stop</code></td>\n<td>暂停服务，不删除容器</td>\n</tr>\n<tr>\n<td><code>docker-compose restart</code></td>\n<td>重启服务</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧯-四、常见问题排查\"><a href=\"#🧯-四、常见问题排查\" class=\"headerlink\" title=\"🧯 四、常见问题排查\"></a>🧯 四、常见问题排查</h2><table>\n<thead>\n<tr>\n<th>问题</th>\n<th>原因</th>\n<th>解决方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务端口访问不到</td>\n<td><code>ports</code> 映射未设置或被占用</td>\n<td>确认 <code>宿主机:容器端口</code> 正确且未冲突</td>\n</tr>\n<tr>\n<td>代码热更新无效</td>\n<td>未挂载 <code>volumes</code> 或 Node 缓存</td>\n<td>检查 <code>volumes</code>，可加 <code>nodemon</code></td>\n</tr>\n<tr>\n<td>数据丢失</td>\n<td>缺少数据卷挂载</td>\n<td>添加 <code>volumes</code>，确保路径正确</td>\n</tr>\n<tr>\n<td>服务顺序问题</td>\n<td><code>depends_on</code> 无法确保服务就绪</td>\n<td>使用 <code>healthcheck</code> 配合 <code>depends_on.condition</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📘-五、推荐项目结构\"><a href=\"#📘-五、推荐项目结构\" class=\"headerlink\" title=\"📘 五、推荐项目结构\"></a>📘 五、推荐项目结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-app/</span><br><span class=\"line\">├── docker-compose.yml</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── .env</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── config/</span><br><span class=\"line\">├── secrets/</span><br><span class=\"line\">└── src/</span><br><span class=\"line\">    └── index.js</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📚-六、延伸阅读\"><a href=\"#📚-六、延伸阅读\" class=\"headerlink\" title=\"📚 六、延伸阅读\"></a>📚 六、延伸阅读</h2><ul>\n<li>Docker 官方文档：<a href=\"https://docs.docker.com/\">https://docs.docker.com/</a></li>\n<li>Compose 文件语法参考：<a href=\"https://docs.docker.com/compose/compose-file/\">https://docs.docker.com/compose/compose-file/</a></li>\n<li>官方 Compose 示例：<a href=\"https://github.com/docker/awesome-compose\">https://github.com/docker/awesome-compose</a></li>\n<li>Swarm 集群：<a href=\"https://docs.docker.com/engine/swarm/\">https://docs.docker.com/engine/swarm/</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适用于初学者与中小团队服务部署使用，转载请注明出处 🐳</p>\n</blockquote>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-Dockerfile-Docker-Compose-教程（含字段注释）\"><a href=\"#🐳-Dockerfile-Docker-Compose-教程（含字段注释）\" class=\"headerlink\" title=\"🐳 Dockerfile + Docker Compose 教程（含字段注释）\"></a>🐳 Dockerfile + Docker Compose 教程（含字段注释）</h1><hr>\n<h2 id=\"📦-一、Dockerfile-教程（构建镜像）\"><a href=\"#📦-一、Dockerfile-教程（构建镜像）\" class=\"headerlink\" title=\"📦 一、Dockerfile 教程（构建镜像）\"></a>📦 一、Dockerfile 教程（构建镜像）</h2><p><code>Dockerfile</code> 是用于定义 Docker 镜像内容的脚本。你可以用它自动打包部署环境和项目。</p>\n<h3 id=\"📁-示例：构建一个-Node-js-应用镜像\"><a href=\"#📁-示例：构建一个-Node-js-应用镜像\" class=\"headerlink\" title=\"📁 示例：构建一个 Node.js 应用镜像\"></a>📁 示例：构建一个 Node.js 应用镜像</h3><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用官方 Node 镜像作为基础镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置容器内的工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制依赖文件（更高缓存利用）</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package*.json ./</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制项目文件到容器</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 映射端口（仅用于文档说明，实际映射需用 docker run 或 docker-compose）</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动应用</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"🧾-字段解释\"><a href=\"#🧾-字段解释\" class=\"headerlink\" title=\"🧾 字段解释\"></a>🧾 字段解释</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FROM</code></td>\n<td>指定基础镜像</td>\n</tr>\n<tr>\n<td><code>WORKDIR</code></td>\n<td>设置容器中的工作目录</td>\n</tr>\n<tr>\n<td><code>COPY</code></td>\n<td>将文件复制进镜像</td>\n</tr>\n<tr>\n<td><code>RUN</code></td>\n<td>执行命令（在构建时执行）</td>\n</tr>\n<tr>\n<td><code>EXPOSE</code></td>\n<td>声明容器会监听的端口（非实际映射）</td>\n</tr>\n<tr>\n<td><code>CMD</code></td>\n<td>容器启动时执行的默认命令</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧩-二、Docker-Compose-教程（管理多容器）\"><a href=\"#🧩-二、Docker-Compose-教程（管理多容器）\" class=\"headerlink\" title=\"🧩 二、Docker Compose 教程（管理多容器）\"></a>🧩 二、Docker Compose 教程（管理多容器）</h2><p><code>docker-compose.yml</code> 是用来定义多个服务（容器）的配置文件，常用于本地开发或测试部署。</p>\n<hr>\n<h3 id=\"🌐-示例：Node-js-MongoDB-服务组合\"><a href=\"#🌐-示例：Node-js-MongoDB-服务组合\" class=\"headerlink\" title=\"🌐 示例：Node.js + MongoDB 服务组合\"></a>🌐 示例：Node.js + MongoDB 服务组合</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span>              <span class=\"comment\"># Dockerfile 所在路径</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile</span> <span class=\"comment\"># 可选指定文件名</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MONGO_URL=mongodb://mongo:27017/mydb</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;dev&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">mongo:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo:6</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;27017:27017&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo-data:/data/db</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">on-failure</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">backend</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"🧾-所有常用字段注解（Compose-v3-8）\"><a href=\"#🧾-所有常用字段注解（Compose-v3-8）\" class=\"headerlink\" title=\"🧾 所有常用字段注解（Compose v3.8）\"></a>🧾 所有常用字段注解（Compose v3.8）</h3><h4 id=\"✅-根级字段\"><a href=\"#✅-根级字段\" class=\"headerlink\" title=\"✅ 根级字段\"></a>✅ 根级字段</h4><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>version</code></td>\n<td>Compose 文件的语法版本</td>\n</tr>\n<tr>\n<td><code>services</code></td>\n<td>所有要运行的服务（容器）</td>\n</tr>\n<tr>\n<td><code>volumes</code></td>\n<td>声明可复用的数据卷</td>\n</tr>\n<tr>\n<td><code>networks</code></td>\n<td>声明自定义网络</td>\n</tr>\n<tr>\n<td><code>configs</code></td>\n<td>管理配置文件（高级用法）</td>\n</tr>\n<tr>\n<td><code>secrets</code></td>\n<td>管理敏感数据，如密码、证书</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"✅-services-下常见字段\"><a href=\"#✅-services-下常见字段\" class=\"headerlink\" title=\"✅ services 下常见字段\"></a>✅ <code>services</code> 下常见字段</h4><table>\n<thead>\n<tr>\n<th>字段</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>image</code></td>\n<td>string</td>\n<td>使用已有镜像</td>\n</tr>\n<tr>\n<td><code>build</code></td>\n<td>object&#x2F;string</td>\n<td>使用 Dockerfile 构建镜像（支持配置项）</td>\n</tr>\n<tr>\n<td><code>context</code></td>\n<td>string</td>\n<td>构建上下文路径</td>\n</tr>\n<tr>\n<td><code>dockerfile</code></td>\n<td>string</td>\n<td>Dockerfile 文件名</td>\n</tr>\n<tr>\n<td><code>ports</code></td>\n<td>list</td>\n<td>端口映射（主机:容器）</td>\n</tr>\n<tr>\n<td><code>volumes</code></td>\n<td>list</td>\n<td>数据卷挂载（持久化或挂载代码）</td>\n</tr>\n<tr>\n<td><code>environment</code></td>\n<td>list&#x2F;map</td>\n<td>设置环境变量</td>\n</tr>\n<tr>\n<td><code>env_file</code></td>\n<td>string&#x2F;list</td>\n<td>从文件中读取环境变量</td>\n</tr>\n<tr>\n<td><code>depends_on</code></td>\n<td>list</td>\n<td>定义服务之间的启动顺序</td>\n</tr>\n<tr>\n<td><code>command</code></td>\n<td>string&#x2F;list</td>\n<td>覆盖容器启动时默认命令</td>\n</tr>\n<tr>\n<td><code>entrypoint</code></td>\n<td>string&#x2F;list</td>\n<td>覆盖默认 entrypoint</td>\n</tr>\n<tr>\n<td><code>restart</code></td>\n<td>string</td>\n<td>容器重启策略（<code>no</code>, <code>always</code>, <code>on-failure</code>, <code>unless-stopped</code>）</td>\n</tr>\n<tr>\n<td><code>networks</code></td>\n<td>list</td>\n<td>加入一个或多个网络</td>\n</tr>\n<tr>\n<td><code>hostname</code></td>\n<td>string</td>\n<td>容器主机名</td>\n</tr>\n<tr>\n<td><code>extra_hosts</code></td>\n<td>list</td>\n<td>添加 hosts 映射（本地 DNS）</td>\n</tr>\n<tr>\n<td><code>logging</code></td>\n<td>object</td>\n<td>配置日志驱动</td>\n</tr>\n<tr>\n<td><code>healthcheck</code></td>\n<td>object</td>\n<td>设置健康检查</td>\n</tr>\n<tr>\n<td><code>tty</code></td>\n<td>bool</td>\n<td>分配 TTY 伪终端（多用于交互容器）</td>\n</tr>\n<tr>\n<td><code>stdin_open</code></td>\n<td>bool</td>\n<td>保持 STDIN 打开（<code>docker run -i</code>）</td>\n</tr>\n<tr>\n<td><code>depends_on.condition</code></td>\n<td>object</td>\n<td>控制服务依赖条件（需要配合 <code>healthcheck</code>）</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"✅-volumes-下字段\"><a href=\"#✅-volumes-下字段\" class=\"headerlink\" title=\"✅ volumes 下字段\"></a>✅ <code>volumes</code> 下字段</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db-data:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">local</span>         <span class=\"comment\"># 存储驱动</span></span><br><span class=\"line\">    <span class=\"attr\">driver_opts:</span>          <span class=\"comment\"># 驱动参数</span></span><br><span class=\"line\">      <span class=\"attr\">type:</span> <span class=\"string\">none</span></span><br><span class=\"line\">      <span class=\"attr\">device:</span> <span class=\"string\">/my/data</span></span><br><span class=\"line\">      <span class=\"attr\">o:</span> <span class=\"string\">bind</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"✅-networks-下字段\"><a href=\"#✅-networks-下字段\" class=\"headerlink\" title=\"✅ networks 下字段\"></a>✅ <code>networks</code> 下字段</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span>        <span class=\"comment\"># 网络驱动（默认为 bridge）</span></span><br><span class=\"line\">    <span class=\"attr\">ipam:</span>                 <span class=\"comment\"># 自定义 IP 地址管理（可选）</span></span><br><span class=\"line\">      <span class=\"attr\">config:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">subnet:</span> <span class=\"number\">172.16</span><span class=\"number\">.238</span><span class=\"number\">.0</span><span class=\"string\">/24</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"✅-configs-secrets（仅-Swarm-模式）\"><a href=\"#✅-configs-secrets（仅-Swarm-模式）\" class=\"headerlink\" title=\"✅ configs &amp; secrets（仅 Swarm 模式）\"></a>✅ <code>configs</code> &amp; <code>secrets</code>（仅 Swarm 模式）</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">configs:</span></span><br><span class=\"line\">  <span class=\"attr\">my_config:</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./config.json</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secrets:</span></span><br><span class=\"line\">  <span class=\"attr\">db_password:</span></span><br><span class=\"line\">    <span class=\"attr\">file:</span> <span class=\"string\">./pw.txt</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-三、常用命令速查\"><a href=\"#🚀-三、常用命令速查\" class=\"headerlink\" title=\"🚀 三、常用命令速查\"></a>🚀 三、常用命令速查</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>docker-compose up</code></td>\n<td>构建 + 启动所有服务</td>\n</tr>\n<tr>\n<td><code>docker-compose up -d</code></td>\n<td>后台运行</td>\n</tr>\n<tr>\n<td><code>docker-compose down</code></td>\n<td>停止并清理容器、网络等</td>\n</tr>\n<tr>\n<td><code>docker-compose ps</code></td>\n<td>查看运行中的服务</td>\n</tr>\n<tr>\n<td><code>docker-compose logs -f</code></td>\n<td>查看日志</td>\n</tr>\n<tr>\n<td><code>docker-compose exec app bash</code></td>\n<td>进入容器终端</td>\n</tr>\n<tr>\n<td><code>docker-compose build</code></td>\n<td>仅构建镜像，不启动</td>\n</tr>\n<tr>\n<td><code>docker-compose stop</code></td>\n<td>暂停服务，不删除容器</td>\n</tr>\n<tr>\n<td><code>docker-compose restart</code></td>\n<td>重启服务</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧯-四、常见问题排查\"><a href=\"#🧯-四、常见问题排查\" class=\"headerlink\" title=\"🧯 四、常见问题排查\"></a>🧯 四、常见问题排查</h2><table>\n<thead>\n<tr>\n<th>问题</th>\n<th>原因</th>\n<th>解决方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务端口访问不到</td>\n<td><code>ports</code> 映射未设置或被占用</td>\n<td>确认 <code>宿主机:容器端口</code> 正确且未冲突</td>\n</tr>\n<tr>\n<td>代码热更新无效</td>\n<td>未挂载 <code>volumes</code> 或 Node 缓存</td>\n<td>检查 <code>volumes</code>，可加 <code>nodemon</code></td>\n</tr>\n<tr>\n<td>数据丢失</td>\n<td>缺少数据卷挂载</td>\n<td>添加 <code>volumes</code>，确保路径正确</td>\n</tr>\n<tr>\n<td>服务顺序问题</td>\n<td><code>depends_on</code> 无法确保服务就绪</td>\n<td>使用 <code>healthcheck</code> 配合 <code>depends_on.condition</code></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"📘-五、推荐项目结构\"><a href=\"#📘-五、推荐项目结构\" class=\"headerlink\" title=\"📘 五、推荐项目结构\"></a>📘 五、推荐项目结构</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-app/</span><br><span class=\"line\">├── docker-compose.yml</span><br><span class=\"line\">├── Dockerfile</span><br><span class=\"line\">├── .env</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── config/</span><br><span class=\"line\">├── secrets/</span><br><span class=\"line\">└── src/</span><br><span class=\"line\">    └── index.js</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📚-六、延伸阅读\"><a href=\"#📚-六、延伸阅读\" class=\"headerlink\" title=\"📚 六、延伸阅读\"></a>📚 六、延伸阅读</h2><ul>\n<li>Docker 官方文档：<a href=\"https://docs.docker.com/\">https://docs.docker.com/</a></li>\n<li>Compose 文件语法参考：<a href=\"https://docs.docker.com/compose/compose-file/\">https://docs.docker.com/compose/compose-file/</a></li>\n<li>官方 Compose 示例：<a href=\"https://github.com/docker/awesome-compose\">https://github.com/docker/awesome-compose</a></li>\n<li>Swarm 集群：<a href=\"https://docs.docker.com/engine/swarm/\">https://docs.docker.com/engine/swarm/</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>作者：<strong>[937bb]</strong><br>本文适用于初学者与中小团队服务部署使用，转载请注明出处 🐳</p>\n</blockquote>\n"},{"title":"🐳 构建一个完整的应用栈：实战与最佳实践指南","date":"2025-06-07T06:30:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":45458,"_content":"\n# 🐳 构建一个完整的应用栈：实战与最佳实践指南\n\n想象一下，你正在开发一个简单的 Web 应用，它包含：\n\n*   一个**前端**：可能是静态文件或者一个单页应用 (SPA)，通过 Nginx 提供服务。\n*   一个**后端 API**：使用 Node.js 编写，处理业务逻辑。\n*   一个**数据库**：使用 MySQL 存储数据。\n*   一个**缓存**：使用 Redis 提高性能。\n\n这是一个非常常见的应用架构。如果不使用 Docker，你需要分别安装和配置 Nginx、Node.js 环境、MySQL、Redis，处理它们之间的连接、版本冲突、启动顺序等等，非常繁琐。\n\n有了 Docker Compose，这一切都变得简单起来！我们可以用一个 `docker-compose.yml` 文件来描述整个应用栈，然后用一个命令搞定启动和管理。\n\n---\n\n## 🏗️ 实际应用栈示例：一个 `docker-compose.yml` 文件搞定一切！\n\n让我们来看一个完整的 `docker-compose.yml` 文件，它定义并编排上面提到的四个服务：\n\n```yaml\n# 文件名: docker-compose.yml\n# 这是一个典型的开发环境配置示例\n\nversion: '3.8' # 使用较新的文件格式版本，支持健康检查条件等特性\n\n# services: 定义我们的应用栈包含的所有服务\nservices:\n\n  # --- 前端服务 ---\n  # 比如使用 Nginx 提供静态文件或代理到后端\n  frontend:\n    # build: 从本地的 ./frontend 目录构建镜像，假设里面有你的前端代码和 Dockerfile\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile.dev # 可以指定一个用于开发的 Dockerfile\n\n    # image: 如果是生产环境，你可能会直接使用预构建好的镜像\n    # image: my-frontend-nginx:latest\n\n    # container_name: 给容器一个易记的名字 (可选，开发环境方便)\n    container_name: my_app_frontend\n\n    # ports: 端口映射，让外部（你的浏览器）能访问到前端服务\n    ports:\n      - \"80:80\" # 将宿主机的 80 端口映射到容器内部 Nginx 的 80 端口\n\n    # volumes: 挂载本地代码，方便开发时热更新 (仅开发环境常用)\n    volumes:\n      # 将宿主机 ./frontend/dist 目录（你的前端构建输出）挂载到容器 Nginx 的静态文件目录\n      - ./frontend/dist:/usr/share/nginx/html\n      # 如果需要修改 Nginx 配置，也可以挂载配置文件\n      # - ./frontend/nginx.conf:/etc/nginx/nginx.conf\n\n    # depends_on: 前端可能需要后端启动才能完全工作 (比如通过后端 API 获取数据)\n    # 这里我们假设前端只是提供静态文件，不直接依赖 backend 的启动，但如果前端需要调用后端API，可以加上依赖，但 service_healthy 通常是给后端依赖数据库/缓存用的\n    # 如果前端是一个 SPA，启动时不直接依赖后端，但运行中会调用，这里的 depends_on 可以省略\n    # depends_on:\n    #   backend:\n    #     condition: service_started # 或者 service_healthy 如果 backend 配置了 healthcheck\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，可以访问 backend\n\n  # --- 后端服务 ---\n  # 比如使用 Node.js 编写的 API\n  backend:\n    # build: 从本地的 ./backend 目录构建镜像\n    build:\n      context: ./backend\n      dockerfile: Dockerfile.dev # 开发环境 Dockerfile\n\n    # image: 生产环境使用预构建镜像\n    # image: my-backend-api:latest\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_backend\n\n    # ports: 端口映射 (如果需要从外部直接访问后端，比如调试API)\n    # 如果后端只被 frontend 或其他服务在内部网络访问，这里可以不映射端口\n    ports:\n      - \"3001:3000\" # 将宿主机的 3001 端口映射到容器内部 Node.js 应用监听的 3000 端口\n\n    # volumes: 挂载本地代码和 node_modules (开发环境)\n    volumes:\n      # 将宿主机 ./backend 目录挂载到容器 /app 目录\n      - ./backend:/app\n      # 特殊处理 node_modules：Node.js 应用的依赖通常很庞大且宿主机和容器的架构可能不同\n      # 推荐使用一个匿名卷或命名卷来存放 node_modules\n      # 这样既能保证依赖在容器里，又能避免本地挂载覆盖容器里安装好的依赖\n      - /app/node_modules # 这是一个匿名卷的简写，表示挂载一个匿名卷到 /app/node_modules\n                          # 如果 /app/node_modules 在容器构建时就存在，这个匿名卷会隐藏它\n                          # 更好的做法是在 Dockerfile 里将 node_modules 安装到另一个目录，或者在 Compose 里使用命名卷\n                          # 比如 volumes: - node_modules_volume:/app/node_modules\n                          # 但匿名卷的写法在开发中也常见，用于隔离依赖\n      # 持久化日志目录\n      # - backend_logs:/app/logs\n\n    # environment: 设置环境变量，将数据库和缓存的连接信息传给后端应用\n    environment:\n      NODE_ENV: development # 或者 production\n      # 数据库连接信息，通过服务名访问，因为它们在同一个网络\n      DB_HOST: db\n      DB_USER: ${DB_USER:-root} # 从 .env 或宿主机环境变量获取，如果没设置则默认 root\n      DB_PASSWORD: ${DB_PASSWORD} # 从 .env 或宿主机环境变量获取\n      DB_NAME: myapp_db\n      # 缓存连接信息\n      REDIS_HOST: redis\n      REDIS_PORT: 6379\n\n    # depends_on: 后端依赖数据库和缓存，并且需要它们已经健康就绪\n    depends_on:\n      db:\n        condition: service_healthy # 等待 db 容器健康\n      redis:\n        condition: service_healthy # 等待 redis 容器健康\n\n    # healthcheck: 后端应用自身的健康检查\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/healthz\"] # 假设后端提供 /healthz 接口\n      interval: 15s # 每 15 秒检查一次\n      timeout: 5s   # 超时 5 秒\n      retries: 3    # 失败 3 次后标记 unhealthy\n      start_period: 30s # 启动后 30 秒内检查失败不计入重试\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，可以访问 db 和 redis\n\n    # resource limits: 在生产环境会加上资源限制\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '1.0'\n    #       memory: 1G\n\n  # --- 数据库服务 ---\n  # 比如 MySQL\n  db:\n    image: mysql:5.7 # 使用官方 MySQL 镜像\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_mysql_db\n\n    # volumes: 持久化数据库数据！使用命名卷\n    volumes:\n      - db_data:/var/lib/mysql # 将 db_data 命名卷挂载到容器里 MySQL 存放数据的地方\n\n    # environment: 设置数据库的环境变量 (初始化密码、数据库名等)\n    environment:\n      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} # 从 .env 或宿主机环境变量获取 root 密码\n      MYSQL_DATABASE: myapp_db # 自动创建的数据库名\n      # MYSQL_USER: myuser # 如果需要非 root 用户\n      # MYSQL_PASSWORD: mypassword # 如果需要非 root 用户密码\n\n    # ports: 如果需要从宿主机使用客户端工具（如 Navicat）连接数据库，可以映射端口\n    # - \"3306:3306\" # 慎重！这会将数据库暴露给宿主机所有进程，生产环境不推荐直接映射，应通过跳板机或内网访问\n\n    # healthcheck: 数据库健康检查，非常重要，backend 依赖它的 healthy 状态\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"] # 检查数据库连接是否正常\n      interval: 10s # 每 10 秒检查一次\n      timeout: 5s   # 超时 5 秒\n      retries: 5    # 失败 5 次后标记 unhealthy\n      start_period: 20s # 启动后 20 秒内检查失败不计入重试 (给数据库初始化时间)\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，供 backend 访问\n\n    # resource limits: 数据库服务可能需要较多资源\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '2.0'\n    #       memory: 2G\n\n  # --- 缓存服务 ---\n  # 比如 Redis\n  redis:\n    image: redis:7.2-alpine # 使用官方 Redis 镜像 (alpine 版本更小)\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_redis\n\n    # volumes: 持久化 Redis 数据 (如果需要，通常是 RDB 或 AOF 文件)\n    # 如果只是作为临时缓存，数据不重要，可以不挂载卷\n    volumes:\n      - redis_data:/data # Redis 默认将数据存放在 /data 目录\n\n    # ports: 如果需要从宿主机使用客户端工具连接 Redis，可以映射端口\n    # - \"6379:6379\" # 同数据库一样，生产环境慎重直接映射\n\n    # healthcheck: Redis 健康检查\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"] # 检查 Redis 是否响应 PING 命令\n      interval: 5s    # 每 5 秒检查一次\n      timeout: 3s     # 超时 3 秒\n      retries: 3      # 失败 3 次后标记 unhealthy\n      start_period: 10s # 启动后 10 秒内检查失败不计入重试\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，供 backend 访问\n\n    # resource limits: Redis 通常不需要太多资源 (除非数据量非常大)\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '0.5'\n    #       memory: 256M\n\n# volumes: 在顶层声明命名卷，用于持久化数据\nvolumes:\n  db_data: # MySQL 数据卷\n  redis_data: # Redis 数据卷\n  # backend_logs: # 如果后端需要持久化日志，声明这个卷\n\n# networks: 在顶层声明自定义网络，让服务能通过服务名互相通信\nnetworks:\n  app_network: # 声明一个叫 app_network 的网络\n    # driver: bridge 是默认类型，通常不用写\n```\n\n为了让上面的 `docker-compose.yml` 示例能运行，你还需要：\n\n1.  在项目根目录创建 `frontend` 和 `backend` 两个子文件夹。\n2.  在 `frontend` 文件夹里，创建一个 `Dockerfile.dev` 和一个简单的 `dist` 文件夹（模拟前端构建输出）。`Dockerfile.dev` 里可以使用 `nginx:latest` 镜像，并将 `dist` 文件夹内容复制进去。\n3.  在 `backend` 文件夹里，创建一个 `Dockerfile.dev` 和一个简单的 Node.js 应用入口文件（比如 `index.js`）。`Dockerfile.dev` 可以使用 `node:lts-alpine` 镜像，将代码复制进去，安装依赖，并定义启动命令。\n4.  在项目根目录创建一个 `.env` 文件，至少包含 `DB_PASSWORD` 和 `DB_ROOT_PASSWORD`。\n\n**运行方法：**\n\n1.  进入项目根目录。\n2.  确保 Docker Desktop 或 Docker Engine 正在运行。\n3.  执行命令启动整个应用栈：\n    ```bash\n    docker-compose up -d --build\n    # -d: 后台运行\n    # --build: 强制重新构建 frontend 和 backend 服务的镜像 (因为它们使用了 build)\n    ```\n4.  使用 `docker-compose ps` 查看服务状态，确认它们都处于 `Up (healthy)` 状态。\n5.  访问 `http://localhost` (如果前端映射到 80) 或 `http://localhost:3001` (如果直接访问后端) 来测试你的应用。\n6.  使用 `docker-compose logs -f` 查看日志。\n7.  完成后，使用 `docker-compose down` 停止并清理。\n\n---\n\n## 🏆 Docker Compose 编写的最佳实践\n\n通过上面的例子，我们已经综合运用了大部分学过的知识。为了写出更清晰、更易于维护的 `docker-compose.yml` 文件，这里有一些通用的最佳实践建议：\n\n1.  **使用最新稳定版本**：在文件顶部指定 `version`，并尽量使用较新的稳定版本（比如 `3.8+`），以便使用最新的功能和语法。\n2.  **结构清晰，服务独立**：将不同的服务定义在 `services` 下面，每个服务块负责一个独立的组件。服务之间通过网络互相通信。\n3.  **使用自定义网络**：始终在顶层声明自定义网络 (`networks`)，并让相关的服务加入同一个网络。这比使用默认网络更清晰，也方便隔离。服务在同一个自定义网络中可以通过**服务名**互相访问，无需查找 IP 地址。\n4.  **持久化重要数据使用命名卷**：对于数据库数据、上传文件、重要的日志等需要长期保存的数据，一定要使用顶层声明的**命名卷** (`volumes`)。命名卷由 Docker 管理，生命周期独立于容器，能有效防止数据丢失。避免在生产环境使用绑定挂载来持久化应用数据。\n5.  **开发环境利用绑定挂载**：在开发环境中，利用绑定挂载 (`volumes: .:/app`) 将本地代码同步到容器，实现代码修改后的快速反馈（热更新），提高开发效率。\n6.  **环境变量管理配置**：将应用的配置信息（数据库连接、API 密钥等）通过 `environment` 或 `env_file` 传递给容器。使用 `${VAR_NAME}` 语法引用环境变量。\n7.  **利用 `.env` 文件加载默认变量**：在项目根目录创建 `.env` 文件存放非敏感的默认环境变量。\n8.  **使用多文件管理不同环境**：对于开发、测试、生产等不同环境，创建基础文件 (`docker-compose.yml`) 和环境覆盖文件 (`docker-compose.dev.yml`, `docker-compose.prod.yml`)，通过 `docker-compose -f ... -f ... up` 来组合使用。\n9.  **定义清晰的服务依赖**：使用 `depends_on` 来表达服务间的启动顺序依赖。\n10. **配置 Healthcheck 并结合 `service_healthy`**：为关键服务（尤其是数据库、缓存、下游 API）配置 `healthcheck`，并在依赖它们的服务中使用 `depends_on: condition: service_healthy` 来确保依赖的服务真正就绪后再启动当前服务。这是构建稳定应用栈的关键。\n11. **在生产环境配置资源限制**：使用 `deploy.resources.limits` 或 `cpu_quota`, `mem_limit` 来限制容器可用的 CPU 和内存，防止资源耗尽，提高系统稳定性。\n12. **合理配置日志驱动**：根据环境需求配置 `logging` 驱动。开发环境限制日志文件大小，生产环境通常发送到集中的日志收集系统。\n13. **避免在生产环境使用 `container_name`**：固定的容器名不适合 Scale Up 和多实例部署，主要用于开发环境方便手动操作。\n14. **编写清晰的 Dockerfile**：Docker Compose 负责编排，Dockerfile 负责构建单个服务镜像。编写高效、安全的 Dockerfile 是构建优秀 Docker 应用的基础。\n15. **注释**：在复杂的 `docker-compose.yml` 文件中添加注释，解释各个部分的作用和配置，提高可读性。\n\n遵循这些最佳实践，你的 Docker Compose 文件将不仅能工作，而且会更易于理解、管理和维护，无论是你自己还是团队的其他成员，都能更顺畅地使用它来开发和部署应用。\n\n---\n\n**本章小结**\n\n我们通过一个完整的 Web 应用栈示例，将之前学到的 `version`, `services`, `volumes`, `networks`, `build`, `image`, `ports`, `environment`, `depends_on: service_healthy`, `healthcheck`, `restart`, `container_name`, `deploy.resources` 等字段和概念综合应用了一遍。\n\n同时，我们也总结了 Docker Compose 编写的 15 条最佳实践，它们是提升你 Docker Compose 文件质量的重要指南。\n\n恭喜你！到这里，你已经掌握了使用 Docker Compose 定义、配置和管理一个多服务应用栈的核心技能。你现在可以自信地使用 Docker Compose 来容器化你的应用项目了！\n\nDocker 的世界远不止 Docker Compose，还有 Docker Swarm、Kubernetes 等更强大的容器编排工具。但 Docker Compose 是入门容器化应用编排的绝佳起点，它简洁易用，非常适合开发环境和简单的生产部署。\n\n希望这个系列的教程对你有帮助！祝你在容器化之旅中一切顺利！","source":"_posts/Docker/Docker Compose 深入服务配置篇（七）：实战与最佳实践指南.md","raw":"---\ntitle: \"\\U0001F433 构建一个完整的应用栈：实战与最佳实践指南\"\ndate: '2025-06-07 14:30'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 45458\n---\n\n# 🐳 构建一个完整的应用栈：实战与最佳实践指南\n\n想象一下，你正在开发一个简单的 Web 应用，它包含：\n\n*   一个**前端**：可能是静态文件或者一个单页应用 (SPA)，通过 Nginx 提供服务。\n*   一个**后端 API**：使用 Node.js 编写，处理业务逻辑。\n*   一个**数据库**：使用 MySQL 存储数据。\n*   一个**缓存**：使用 Redis 提高性能。\n\n这是一个非常常见的应用架构。如果不使用 Docker，你需要分别安装和配置 Nginx、Node.js 环境、MySQL、Redis，处理它们之间的连接、版本冲突、启动顺序等等，非常繁琐。\n\n有了 Docker Compose，这一切都变得简单起来！我们可以用一个 `docker-compose.yml` 文件来描述整个应用栈，然后用一个命令搞定启动和管理。\n\n---\n\n## 🏗️ 实际应用栈示例：一个 `docker-compose.yml` 文件搞定一切！\n\n让我们来看一个完整的 `docker-compose.yml` 文件，它定义并编排上面提到的四个服务：\n\n```yaml\n# 文件名: docker-compose.yml\n# 这是一个典型的开发环境配置示例\n\nversion: '3.8' # 使用较新的文件格式版本，支持健康检查条件等特性\n\n# services: 定义我们的应用栈包含的所有服务\nservices:\n\n  # --- 前端服务 ---\n  # 比如使用 Nginx 提供静态文件或代理到后端\n  frontend:\n    # build: 从本地的 ./frontend 目录构建镜像，假设里面有你的前端代码和 Dockerfile\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile.dev # 可以指定一个用于开发的 Dockerfile\n\n    # image: 如果是生产环境，你可能会直接使用预构建好的镜像\n    # image: my-frontend-nginx:latest\n\n    # container_name: 给容器一个易记的名字 (可选，开发环境方便)\n    container_name: my_app_frontend\n\n    # ports: 端口映射，让外部（你的浏览器）能访问到前端服务\n    ports:\n      - \"80:80\" # 将宿主机的 80 端口映射到容器内部 Nginx 的 80 端口\n\n    # volumes: 挂载本地代码，方便开发时热更新 (仅开发环境常用)\n    volumes:\n      # 将宿主机 ./frontend/dist 目录（你的前端构建输出）挂载到容器 Nginx 的静态文件目录\n      - ./frontend/dist:/usr/share/nginx/html\n      # 如果需要修改 Nginx 配置，也可以挂载配置文件\n      # - ./frontend/nginx.conf:/etc/nginx/nginx.conf\n\n    # depends_on: 前端可能需要后端启动才能完全工作 (比如通过后端 API 获取数据)\n    # 这里我们假设前端只是提供静态文件，不直接依赖 backend 的启动，但如果前端需要调用后端API，可以加上依赖，但 service_healthy 通常是给后端依赖数据库/缓存用的\n    # 如果前端是一个 SPA，启动时不直接依赖后端，但运行中会调用，这里的 depends_on 可以省略\n    # depends_on:\n    #   backend:\n    #     condition: service_started # 或者 service_healthy 如果 backend 配置了 healthcheck\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，可以访问 backend\n\n  # --- 后端服务 ---\n  # 比如使用 Node.js 编写的 API\n  backend:\n    # build: 从本地的 ./backend 目录构建镜像\n    build:\n      context: ./backend\n      dockerfile: Dockerfile.dev # 开发环境 Dockerfile\n\n    # image: 生产环境使用预构建镜像\n    # image: my-backend-api:latest\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_backend\n\n    # ports: 端口映射 (如果需要从外部直接访问后端，比如调试API)\n    # 如果后端只被 frontend 或其他服务在内部网络访问，这里可以不映射端口\n    ports:\n      - \"3001:3000\" # 将宿主机的 3001 端口映射到容器内部 Node.js 应用监听的 3000 端口\n\n    # volumes: 挂载本地代码和 node_modules (开发环境)\n    volumes:\n      # 将宿主机 ./backend 目录挂载到容器 /app 目录\n      - ./backend:/app\n      # 特殊处理 node_modules：Node.js 应用的依赖通常很庞大且宿主机和容器的架构可能不同\n      # 推荐使用一个匿名卷或命名卷来存放 node_modules\n      # 这样既能保证依赖在容器里，又能避免本地挂载覆盖容器里安装好的依赖\n      - /app/node_modules # 这是一个匿名卷的简写，表示挂载一个匿名卷到 /app/node_modules\n                          # 如果 /app/node_modules 在容器构建时就存在，这个匿名卷会隐藏它\n                          # 更好的做法是在 Dockerfile 里将 node_modules 安装到另一个目录，或者在 Compose 里使用命名卷\n                          # 比如 volumes: - node_modules_volume:/app/node_modules\n                          # 但匿名卷的写法在开发中也常见，用于隔离依赖\n      # 持久化日志目录\n      # - backend_logs:/app/logs\n\n    # environment: 设置环境变量，将数据库和缓存的连接信息传给后端应用\n    environment:\n      NODE_ENV: development # 或者 production\n      # 数据库连接信息，通过服务名访问，因为它们在同一个网络\n      DB_HOST: db\n      DB_USER: ${DB_USER:-root} # 从 .env 或宿主机环境变量获取，如果没设置则默认 root\n      DB_PASSWORD: ${DB_PASSWORD} # 从 .env 或宿主机环境变量获取\n      DB_NAME: myapp_db\n      # 缓存连接信息\n      REDIS_HOST: redis\n      REDIS_PORT: 6379\n\n    # depends_on: 后端依赖数据库和缓存，并且需要它们已经健康就绪\n    depends_on:\n      db:\n        condition: service_healthy # 等待 db 容器健康\n      redis:\n        condition: service_healthy # 等待 redis 容器健康\n\n    # healthcheck: 后端应用自身的健康检查\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/healthz\"] # 假设后端提供 /healthz 接口\n      interval: 15s # 每 15 秒检查一次\n      timeout: 5s   # 超时 5 秒\n      retries: 3    # 失败 3 次后标记 unhealthy\n      start_period: 30s # 启动后 30 秒内检查失败不计入重试\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，可以访问 db 和 redis\n\n    # resource limits: 在生产环境会加上资源限制\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '1.0'\n    #       memory: 1G\n\n  # --- 数据库服务 ---\n  # 比如 MySQL\n  db:\n    image: mysql:5.7 # 使用官方 MySQL 镜像\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_mysql_db\n\n    # volumes: 持久化数据库数据！使用命名卷\n    volumes:\n      - db_data:/var/lib/mysql # 将 db_data 命名卷挂载到容器里 MySQL 存放数据的地方\n\n    # environment: 设置数据库的环境变量 (初始化密码、数据库名等)\n    environment:\n      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD} # 从 .env 或宿主机环境变量获取 root 密码\n      MYSQL_DATABASE: myapp_db # 自动创建的数据库名\n      # MYSQL_USER: myuser # 如果需要非 root 用户\n      # MYSQL_PASSWORD: mypassword # 如果需要非 root 用户密码\n\n    # ports: 如果需要从宿主机使用客户端工具（如 Navicat）连接数据库，可以映射端口\n    # - \"3306:3306\" # 慎重！这会将数据库暴露给宿主机所有进程，生产环境不推荐直接映射，应通过跳板机或内网访问\n\n    # healthcheck: 数据库健康检查，非常重要，backend 依赖它的 healthy 状态\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"] # 检查数据库连接是否正常\n      interval: 10s # 每 10 秒检查一次\n      timeout: 5s   # 超时 5 秒\n      retries: 5    # 失败 5 次后标记 unhealthy\n      start_period: 20s # 启动后 20 秒内检查失败不计入重试 (给数据库初始化时间)\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，供 backend 访问\n\n    # resource limits: 数据库服务可能需要较多资源\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '2.0'\n    #       memory: 2G\n\n  # --- 缓存服务 ---\n  # 比如 Redis\n  redis:\n    image: redis:7.2-alpine # 使用官方 Redis 镜像 (alpine 版本更小)\n\n    # container_name: 给容器起名字 (可选)\n    container_name: my_app_redis\n\n    # volumes: 持久化 Redis 数据 (如果需要，通常是 RDB 或 AOF 文件)\n    # 如果只是作为临时缓存，数据不重要，可以不挂载卷\n    volumes:\n      - redis_data:/data # Redis 默认将数据存放在 /data 目录\n\n    # ports: 如果需要从宿主机使用客户端工具连接 Redis，可以映射端口\n    # - \"6379:6379\" # 同数据库一样，生产环境慎重直接映射\n\n    # healthcheck: Redis 健康检查\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"] # 检查 Redis 是否响应 PING 命令\n      interval: 5s    # 每 5 秒检查一次\n      timeout: 3s     # 超时 3 秒\n      retries: 3      # 失败 3 次后标记 unhealthy\n      start_period: 10s # 启动后 10 秒内检查失败不计入重试\n\n    restart: unless-stopped # 异常退出时自动重启\n\n    networks:\n      - app_network # 加入应用网络，供 backend 访问\n\n    # resource limits: Redis 通常不需要太多资源 (除非数据量非常大)\n    # deploy:\n    #   resources:\n    #     limits:\n    #       cpus: '0.5'\n    #       memory: 256M\n\n# volumes: 在顶层声明命名卷，用于持久化数据\nvolumes:\n  db_data: # MySQL 数据卷\n  redis_data: # Redis 数据卷\n  # backend_logs: # 如果后端需要持久化日志，声明这个卷\n\n# networks: 在顶层声明自定义网络，让服务能通过服务名互相通信\nnetworks:\n  app_network: # 声明一个叫 app_network 的网络\n    # driver: bridge 是默认类型，通常不用写\n```\n\n为了让上面的 `docker-compose.yml` 示例能运行，你还需要：\n\n1.  在项目根目录创建 `frontend` 和 `backend` 两个子文件夹。\n2.  在 `frontend` 文件夹里，创建一个 `Dockerfile.dev` 和一个简单的 `dist` 文件夹（模拟前端构建输出）。`Dockerfile.dev` 里可以使用 `nginx:latest` 镜像，并将 `dist` 文件夹内容复制进去。\n3.  在 `backend` 文件夹里，创建一个 `Dockerfile.dev` 和一个简单的 Node.js 应用入口文件（比如 `index.js`）。`Dockerfile.dev` 可以使用 `node:lts-alpine` 镜像，将代码复制进去，安装依赖，并定义启动命令。\n4.  在项目根目录创建一个 `.env` 文件，至少包含 `DB_PASSWORD` 和 `DB_ROOT_PASSWORD`。\n\n**运行方法：**\n\n1.  进入项目根目录。\n2.  确保 Docker Desktop 或 Docker Engine 正在运行。\n3.  执行命令启动整个应用栈：\n    ```bash\n    docker-compose up -d --build\n    # -d: 后台运行\n    # --build: 强制重新构建 frontend 和 backend 服务的镜像 (因为它们使用了 build)\n    ```\n4.  使用 `docker-compose ps` 查看服务状态，确认它们都处于 `Up (healthy)` 状态。\n5.  访问 `http://localhost` (如果前端映射到 80) 或 `http://localhost:3001` (如果直接访问后端) 来测试你的应用。\n6.  使用 `docker-compose logs -f` 查看日志。\n7.  完成后，使用 `docker-compose down` 停止并清理。\n\n---\n\n## 🏆 Docker Compose 编写的最佳实践\n\n通过上面的例子，我们已经综合运用了大部分学过的知识。为了写出更清晰、更易于维护的 `docker-compose.yml` 文件，这里有一些通用的最佳实践建议：\n\n1.  **使用最新稳定版本**：在文件顶部指定 `version`，并尽量使用较新的稳定版本（比如 `3.8+`），以便使用最新的功能和语法。\n2.  **结构清晰，服务独立**：将不同的服务定义在 `services` 下面，每个服务块负责一个独立的组件。服务之间通过网络互相通信。\n3.  **使用自定义网络**：始终在顶层声明自定义网络 (`networks`)，并让相关的服务加入同一个网络。这比使用默认网络更清晰，也方便隔离。服务在同一个自定义网络中可以通过**服务名**互相访问，无需查找 IP 地址。\n4.  **持久化重要数据使用命名卷**：对于数据库数据、上传文件、重要的日志等需要长期保存的数据，一定要使用顶层声明的**命名卷** (`volumes`)。命名卷由 Docker 管理，生命周期独立于容器，能有效防止数据丢失。避免在生产环境使用绑定挂载来持久化应用数据。\n5.  **开发环境利用绑定挂载**：在开发环境中，利用绑定挂载 (`volumes: .:/app`) 将本地代码同步到容器，实现代码修改后的快速反馈（热更新），提高开发效率。\n6.  **环境变量管理配置**：将应用的配置信息（数据库连接、API 密钥等）通过 `environment` 或 `env_file` 传递给容器。使用 `${VAR_NAME}` 语法引用环境变量。\n7.  **利用 `.env` 文件加载默认变量**：在项目根目录创建 `.env` 文件存放非敏感的默认环境变量。\n8.  **使用多文件管理不同环境**：对于开发、测试、生产等不同环境，创建基础文件 (`docker-compose.yml`) 和环境覆盖文件 (`docker-compose.dev.yml`, `docker-compose.prod.yml`)，通过 `docker-compose -f ... -f ... up` 来组合使用。\n9.  **定义清晰的服务依赖**：使用 `depends_on` 来表达服务间的启动顺序依赖。\n10. **配置 Healthcheck 并结合 `service_healthy`**：为关键服务（尤其是数据库、缓存、下游 API）配置 `healthcheck`，并在依赖它们的服务中使用 `depends_on: condition: service_healthy` 来确保依赖的服务真正就绪后再启动当前服务。这是构建稳定应用栈的关键。\n11. **在生产环境配置资源限制**：使用 `deploy.resources.limits` 或 `cpu_quota`, `mem_limit` 来限制容器可用的 CPU 和内存，防止资源耗尽，提高系统稳定性。\n12. **合理配置日志驱动**：根据环境需求配置 `logging` 驱动。开发环境限制日志文件大小，生产环境通常发送到集中的日志收集系统。\n13. **避免在生产环境使用 `container_name`**：固定的容器名不适合 Scale Up 和多实例部署，主要用于开发环境方便手动操作。\n14. **编写清晰的 Dockerfile**：Docker Compose 负责编排，Dockerfile 负责构建单个服务镜像。编写高效、安全的 Dockerfile 是构建优秀 Docker 应用的基础。\n15. **注释**：在复杂的 `docker-compose.yml` 文件中添加注释，解释各个部分的作用和配置，提高可读性。\n\n遵循这些最佳实践，你的 Docker Compose 文件将不仅能工作，而且会更易于理解、管理和维护，无论是你自己还是团队的其他成员，都能更顺畅地使用它来开发和部署应用。\n\n---\n\n**本章小结**\n\n我们通过一个完整的 Web 应用栈示例，将之前学到的 `version`, `services`, `volumes`, `networks`, `build`, `image`, `ports`, `environment`, `depends_on: service_healthy`, `healthcheck`, `restart`, `container_name`, `deploy.resources` 等字段和概念综合应用了一遍。\n\n同时，我们也总结了 Docker Compose 编写的 15 条最佳实践，它们是提升你 Docker Compose 文件质量的重要指南。\n\n恭喜你！到这里，你已经掌握了使用 Docker Compose 定义、配置和管理一个多服务应用栈的核心技能。你现在可以自信地使用 Docker Compose 来容器化你的应用项目了！\n\nDocker 的世界远不止 Docker Compose，还有 Docker Swarm、Kubernetes 等更强大的容器编排工具。但 Docker Compose 是入门容器化应用编排的绝佳起点，它简洁易用，非常适合开发环境和简单的生产部署。\n\n希望这个系列的教程对你有帮助！祝你在容器化之旅中一切顺利！","slug":"Docker/Docker Compose 深入服务配置篇（七）：实战与最佳实践指南","published":1,"updated":"2025-06-07T15:58:53.663Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww6000hpkrc9lkpbxj8","content":"<h1 id=\"🐳-构建一个完整的应用栈：实战与最佳实践指南\"><a href=\"#🐳-构建一个完整的应用栈：实战与最佳实践指南\" class=\"headerlink\" title=\"🐳 构建一个完整的应用栈：实战与最佳实践指南\"></a>🐳 构建一个完整的应用栈：实战与最佳实践指南</h1><p>想象一下，你正在开发一个简单的 Web 应用，它包含：</p>\n<ul>\n<li>一个<strong>前端</strong>：可能是静态文件或者一个单页应用 (SPA)，通过 Nginx 提供服务。</li>\n<li>一个<strong>后端 API</strong>：使用 Node.js 编写，处理业务逻辑。</li>\n<li>一个<strong>数据库</strong>：使用 MySQL 存储数据。</li>\n<li>一个<strong>缓存</strong>：使用 Redis 提高性能。</li>\n</ul>\n<p>这是一个非常常见的应用架构。如果不使用 Docker，你需要分别安装和配置 Nginx、Node.js 环境、MySQL、Redis，处理它们之间的连接、版本冲突、启动顺序等等，非常繁琐。</p>\n<p>有了 Docker Compose，这一切都变得简单起来！我们可以用一个 <code>docker-compose.yml</code> 文件来描述整个应用栈，然后用一个命令搞定启动和管理。</p>\n<hr>\n<h2 id=\"🏗️-实际应用栈示例：一个-docker-compose-yml-文件搞定一切！\"><a href=\"#🏗️-实际应用栈示例：一个-docker-compose-yml-文件搞定一切！\" class=\"headerlink\" title=\"🏗️ 实际应用栈示例：一个 docker-compose.yml 文件搞定一切！\"></a>🏗️ 实际应用栈示例：一个 <code>docker-compose.yml</code> 文件搞定一切！</h2><p>让我们来看一个完整的 <code>docker-compose.yml</code> 文件，它定义并编排上面提到的四个服务：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这是一个典型的开发环境配置示例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 使用较新的文件格式版本，支持健康检查条件等特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># services: 定义我们的应用栈包含的所有服务</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 前端服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如使用 Nginx 提供静态文件或代理到后端</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地的 ./frontend 目录构建镜像，假设里面有你的前端代码和 Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./frontend</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 可以指定一个用于开发的 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># image: 如果是生产环境，你可能会直接使用预构建好的镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># image: my-frontend-nginx:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器一个易记的名字 (可选，开发环境方便)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_frontend</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射，让外部（你的浏览器）能访问到前端服务</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:80&quot;</span> <span class=\"comment\"># 将宿主机的 80 端口映射到容器内部 Nginx 的 80 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 挂载本地代码，方便开发时热更新 (仅开发环境常用)</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 将宿主机 ./frontend/dist 目录（你的前端构建输出）挂载到容器 Nginx 的静态文件目录</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./frontend/dist:/usr/share/nginx/html</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果需要修改 Nginx 配置，也可以挂载配置文件</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./frontend/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 前端可能需要后端启动才能完全工作 (比如通过后端 API 获取数据)</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里我们假设前端只是提供静态文件，不直接依赖 backend 的启动，但如果前端需要调用后端API，可以加上依赖，但 service_healthy 通常是给后端依赖数据库/缓存用的</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果前端是一个 SPA，启动时不直接依赖后端，但运行中会调用，这里的 depends_on 可以省略</span></span><br><span class=\"line\">    <span class=\"comment\"># depends_on:</span></span><br><span class=\"line\">    <span class=\"comment\">#   backend:</span></span><br><span class=\"line\">    <span class=\"comment\">#     condition: service_started # 或者 service_healthy 如果 backend 配置了 healthcheck</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，可以访问 backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 后端服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如使用 Node.js 编写的 API</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地的 ./backend 目录构建镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./backend</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 开发环境 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># image: 生产环境使用预构建镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># image: my-backend-api:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射 (如果需要从外部直接访问后端，比如调试API)</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果后端只被 frontend 或其他服务在内部网络访问，这里可以不映射端口</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3001:3000&quot;</span> <span class=\"comment\"># 将宿主机的 3001 端口映射到容器内部 Node.js 应用监听的 3000 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 挂载本地代码和 node_modules (开发环境)</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 将宿主机 ./backend 目录挂载到容器 /app 目录</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./backend:/app</span></span><br><span class=\"line\">      <span class=\"comment\"># 特殊处理 node_modules：Node.js 应用的依赖通常很庞大且宿主机和容器的架构可能不同</span></span><br><span class=\"line\">      <span class=\"comment\"># 推荐使用一个匿名卷或命名卷来存放 node_modules</span></span><br><span class=\"line\">      <span class=\"comment\"># 这样既能保证依赖在容器里，又能避免本地挂载覆盖容器里安装好的依赖</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/node_modules</span> <span class=\"comment\"># 这是一个匿名卷的简写，表示挂载一个匿名卷到 /app/node_modules</span></span><br><span class=\"line\">                          <span class=\"comment\"># 如果 /app/node_modules 在容器构建时就存在，这个匿名卷会隐藏它</span></span><br><span class=\"line\">                          <span class=\"comment\"># 更好的做法是在 Dockerfile 里将 node_modules 安装到另一个目录，或者在 Compose 里使用命名卷</span></span><br><span class=\"line\">                          <span class=\"comment\"># 比如 volumes: - node_modules_volume:/app/node_modules</span></span><br><span class=\"line\">                          <span class=\"comment\"># 但匿名卷的写法在开发中也常见，用于隔离依赖</span></span><br><span class=\"line\">      <span class=\"comment\"># 持久化日志目录</span></span><br><span class=\"line\">      <span class=\"comment\"># - backend_logs:/app/logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置环境变量，将数据库和缓存的连接信息传给后端应用</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span> <span class=\"comment\"># 或者 production</span></span><br><span class=\"line\">      <span class=\"comment\"># 数据库连接信息，通过服务名访问，因为它们在同一个网络</span></span><br><span class=\"line\">      <span class=\"attr\">DB_HOST:</span> <span class=\"string\">db</span></span><br><span class=\"line\">      <span class=\"attr\">DB_USER:</span> <span class=\"string\">$&#123;DB_USER:-root&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取，如果没设置则默认 root</span></span><br><span class=\"line\">      <span class=\"attr\">DB_PASSWORD:</span> <span class=\"string\">$&#123;DB_PASSWORD&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取</span></span><br><span class=\"line\">      <span class=\"attr\">DB_NAME:</span> <span class=\"string\">myapp_db</span></span><br><span class=\"line\">      <span class=\"comment\"># 缓存连接信息</span></span><br><span class=\"line\">      <span class=\"attr\">REDIS_HOST:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">      <span class=\"attr\">REDIS_PORT:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 后端依赖数据库和缓存，并且需要它们已经健康就绪</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 db 容器健康</span></span><br><span class=\"line\">      <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 redis 容器健康</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 后端应用自身的健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/healthz&quot;</span>] <span class=\"comment\"># 假设后端提供 /healthz 接口</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">15s</span> <span class=\"comment\"># 每 15 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 超时 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>    <span class=\"comment\"># 失败 3 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span> <span class=\"comment\"># 启动后 30 秒内检查失败不计入重试</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，可以访问 db 和 redis</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: 在生产环境会加上资源限制</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 1G</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 数据库服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如 MySQL</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用官方 MySQL 镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_mysql_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 持久化数据库数据！使用命名卷</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 将 db_data 命名卷挂载到容器里 MySQL 存放数据的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置数据库的环境变量 (初始化密码、数据库名等)</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"string\">$&#123;DB_ROOT_PASSWORD&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取 root 密码</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_db</span> <span class=\"comment\"># 自动创建的数据库名</span></span><br><span class=\"line\">      <span class=\"comment\"># MYSQL_USER: myuser # 如果需要非 root 用户</span></span><br><span class=\"line\">      <span class=\"comment\"># MYSQL_PASSWORD: mypassword # 如果需要非 root 用户密码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 如果需要从宿主机使用客户端工具（如 Navicat）连接数据库，可以映射端口</span></span><br><span class=\"line\">    <span class=\"comment\"># - &quot;3306:3306&quot; # 慎重！这会将数据库暴露给宿主机所有进程，生产环境不推荐直接映射，应通过跳板机或内网访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 数据库健康检查，非常重要，backend 依赖它的 healthy 状态</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>] <span class=\"comment\"># 检查数据库连接是否正常</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每 10 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 超时 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span>    <span class=\"comment\"># 失败 5 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">20s</span> <span class=\"comment\"># 启动后 20 秒内检查失败不计入重试 (给数据库初始化时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，供 backend 访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: 数据库服务可能需要较多资源</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;2.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 2G</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 缓存服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如 Redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.2-alpine</span> <span class=\"comment\"># 使用官方 Redis 镜像 (alpine 版本更小)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_redis</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 持久化 Redis 数据 (如果需要，通常是 RDB 或 AOF 文件)</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果只是作为临时缓存，数据不重要，可以不挂载卷</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis_data:/data</span> <span class=\"comment\"># Redis 默认将数据存放在 /data 目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 如果需要从宿主机使用客户端工具连接 Redis，可以映射端口</span></span><br><span class=\"line\">    <span class=\"comment\"># - &quot;6379:6379&quot; # 同数据库一样，生产环境慎重直接映射</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: Redis 健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;redis-cli&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>] <span class=\"comment\"># 检查 Redis 是否响应 PING 命令</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">5s</span>    <span class=\"comment\"># 每 5 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span>     <span class=\"comment\"># 超时 3 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>      <span class=\"comment\"># 失败 3 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 启动后 10 秒内检查失败不计入重试</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，供 backend 访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: Redis 通常不需要太多资源 (除非数据量非常大)</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;0.5&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 256M</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在顶层声明命名卷，用于持久化数据</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># MySQL 数据卷</span></span><br><span class=\"line\">  <span class=\"attr\">redis_data:</span> <span class=\"comment\"># Redis 数据卷</span></span><br><span class=\"line\">  <span class=\"comment\"># backend_logs: # 如果后端需要持久化日志，声明这个卷</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在顶层声明自定义网络，让服务能通过服务名互相通信</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 声明一个叫 app_network 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<p>为了让上面的 <code>docker-compose.yml</code> 示例能运行，你还需要：</p>\n<ol>\n<li>在项目根目录创建 <code>frontend</code> 和 <code>backend</code> 两个子文件夹。</li>\n<li>在 <code>frontend</code> 文件夹里，创建一个 <code>Dockerfile.dev</code> 和一个简单的 <code>dist</code> 文件夹（模拟前端构建输出）。<code>Dockerfile.dev</code> 里可以使用 <code>nginx:latest</code> 镜像，并将 <code>dist</code> 文件夹内容复制进去。</li>\n<li>在 <code>backend</code> 文件夹里，创建一个 <code>Dockerfile.dev</code> 和一个简单的 Node.js 应用入口文件（比如 <code>index.js</code>）。<code>Dockerfile.dev</code> 可以使用 <code>node:lts-alpine</code> 镜像，将代码复制进去，安装依赖，并定义启动命令。</li>\n<li>在项目根目录创建一个 <code>.env</code> 文件，至少包含 <code>DB_PASSWORD</code> 和 <code>DB_ROOT_PASSWORD</code>。</li>\n</ol>\n<p><strong>运行方法：</strong></p>\n<ol>\n<li>进入项目根目录。</li>\n<li>确保 Docker Desktop 或 Docker Engine 正在运行。</li>\n<li>执行命令启动整个应用栈：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d --build</span><br><span class=\"line\"><span class=\"comment\"># -d: 后台运行</span></span><br><span class=\"line\"><span class=\"comment\"># --build: 强制重新构建 frontend 和 backend 服务的镜像 (因为它们使用了 build)</span></span><br></pre></td></tr></table></figure></li>\n<li>使用 <code>docker-compose ps</code> 查看服务状态，确认它们都处于 <code>Up (healthy)</code> 状态。</li>\n<li>访问 <code>http://localhost</code> (如果前端映射到 80) 或 <code>http://localhost:3001</code> (如果直接访问后端) 来测试你的应用。</li>\n<li>使用 <code>docker-compose logs -f</code> 查看日志。</li>\n<li>完成后，使用 <code>docker-compose down</code> 停止并清理。</li>\n</ol>\n<hr>\n<h2 id=\"🏆-Docker-Compose-编写的最佳实践\"><a href=\"#🏆-Docker-Compose-编写的最佳实践\" class=\"headerlink\" title=\"🏆 Docker Compose 编写的最佳实践\"></a>🏆 Docker Compose 编写的最佳实践</h2><p>通过上面的例子，我们已经综合运用了大部分学过的知识。为了写出更清晰、更易于维护的 <code>docker-compose.yml</code> 文件，这里有一些通用的最佳实践建议：</p>\n<ol>\n<li><strong>使用最新稳定版本</strong>：在文件顶部指定 <code>version</code>，并尽量使用较新的稳定版本（比如 <code>3.8+</code>），以便使用最新的功能和语法。</li>\n<li><strong>结构清晰，服务独立</strong>：将不同的服务定义在 <code>services</code> 下面，每个服务块负责一个独立的组件。服务之间通过网络互相通信。</li>\n<li><strong>使用自定义网络</strong>：始终在顶层声明自定义网络 (<code>networks</code>)，并让相关的服务加入同一个网络。这比使用默认网络更清晰，也方便隔离。服务在同一个自定义网络中可以通过<strong>服务名</strong>互相访问，无需查找 IP 地址。</li>\n<li><strong>持久化重要数据使用命名卷</strong>：对于数据库数据、上传文件、重要的日志等需要长期保存的数据，一定要使用顶层声明的<strong>命名卷</strong> (<code>volumes</code>)。命名卷由 Docker 管理，生命周期独立于容器，能有效防止数据丢失。避免在生产环境使用绑定挂载来持久化应用数据。</li>\n<li><strong>开发环境利用绑定挂载</strong>：在开发环境中，利用绑定挂载 (<code>volumes: .:/app</code>) 将本地代码同步到容器，实现代码修改后的快速反馈（热更新），提高开发效率。</li>\n<li><strong>环境变量管理配置</strong>：将应用的配置信息（数据库连接、API 密钥等）通过 <code>environment</code> 或 <code>env_file</code> 传递给容器。使用 <code>$&#123;VAR_NAME&#125;</code> 语法引用环境变量。</li>\n<li><strong>利用 <code>.env</code> 文件加载默认变量</strong>：在项目根目录创建 <code>.env</code> 文件存放非敏感的默认环境变量。</li>\n<li><strong>使用多文件管理不同环境</strong>：对于开发、测试、生产等不同环境，创建基础文件 (<code>docker-compose.yml</code>) 和环境覆盖文件 (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code>)，通过 <code>docker-compose -f ... -f ... up</code> 来组合使用。</li>\n<li><strong>定义清晰的服务依赖</strong>：使用 <code>depends_on</code> 来表达服务间的启动顺序依赖。</li>\n<li><strong>配置 Healthcheck 并结合 <code>service_healthy</code></strong>：为关键服务（尤其是数据库、缓存、下游 API）配置 <code>healthcheck</code>，并在依赖它们的服务中使用 <code>depends_on: condition: service_healthy</code> 来确保依赖的服务真正就绪后再启动当前服务。这是构建稳定应用栈的关键。</li>\n<li><strong>在生产环境配置资源限制</strong>：使用 <code>deploy.resources.limits</code> 或 <code>cpu_quota</code>, <code>mem_limit</code> 来限制容器可用的 CPU 和内存，防止资源耗尽，提高系统稳定性。</li>\n<li><strong>合理配置日志驱动</strong>：根据环境需求配置 <code>logging</code> 驱动。开发环境限制日志文件大小，生产环境通常发送到集中的日志收集系统。</li>\n<li><strong>避免在生产环境使用 <code>container_name</code></strong>：固定的容器名不适合 Scale Up 和多实例部署，主要用于开发环境方便手动操作。</li>\n<li><strong>编写清晰的 Dockerfile</strong>：Docker Compose 负责编排，Dockerfile 负责构建单个服务镜像。编写高效、安全的 Dockerfile 是构建优秀 Docker 应用的基础。</li>\n<li><strong>注释</strong>：在复杂的 <code>docker-compose.yml</code> 文件中添加注释，解释各个部分的作用和配置，提高可读性。</li>\n</ol>\n<p>遵循这些最佳实践，你的 Docker Compose 文件将不仅能工作，而且会更易于理解、管理和维护，无论是你自己还是团队的其他成员，都能更顺畅地使用它来开发和部署应用。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们通过一个完整的 Web 应用栈示例，将之前学到的 <code>version</code>, <code>services</code>, <code>volumes</code>, <code>networks</code>, <code>build</code>, <code>image</code>, <code>ports</code>, <code>environment</code>, <code>depends_on: service_healthy</code>, <code>healthcheck</code>, <code>restart</code>, <code>container_name</code>, <code>deploy.resources</code> 等字段和概念综合应用了一遍。</p>\n<p>同时，我们也总结了 Docker Compose 编写的 15 条最佳实践，它们是提升你 Docker Compose 文件质量的重要指南。</p>\n<p>恭喜你！到这里，你已经掌握了使用 Docker Compose 定义、配置和管理一个多服务应用栈的核心技能。你现在可以自信地使用 Docker Compose 来容器化你的应用项目了！</p>\n<p>Docker 的世界远不止 Docker Compose，还有 Docker Swarm、Kubernetes 等更强大的容器编排工具。但 Docker Compose 是入门容器化应用编排的绝佳起点，它简洁易用，非常适合开发环境和简单的生产部署。</p>\n<p>希望这个系列的教程对你有帮助！祝你在容器化之旅中一切顺利！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-构建一个完整的应用栈：实战与最佳实践指南\"><a href=\"#🐳-构建一个完整的应用栈：实战与最佳实践指南\" class=\"headerlink\" title=\"🐳 构建一个完整的应用栈：实战与最佳实践指南\"></a>🐳 构建一个完整的应用栈：实战与最佳实践指南</h1><p>想象一下，你正在开发一个简单的 Web 应用，它包含：</p>\n<ul>\n<li>一个<strong>前端</strong>：可能是静态文件或者一个单页应用 (SPA)，通过 Nginx 提供服务。</li>\n<li>一个<strong>后端 API</strong>：使用 Node.js 编写，处理业务逻辑。</li>\n<li>一个<strong>数据库</strong>：使用 MySQL 存储数据。</li>\n<li>一个<strong>缓存</strong>：使用 Redis 提高性能。</li>\n</ul>\n<p>这是一个非常常见的应用架构。如果不使用 Docker，你需要分别安装和配置 Nginx、Node.js 环境、MySQL、Redis，处理它们之间的连接、版本冲突、启动顺序等等，非常繁琐。</p>\n<p>有了 Docker Compose，这一切都变得简单起来！我们可以用一个 <code>docker-compose.yml</code> 文件来描述整个应用栈，然后用一个命令搞定启动和管理。</p>\n<hr>\n<h2 id=\"🏗️-实际应用栈示例：一个-docker-compose-yml-文件搞定一切！\"><a href=\"#🏗️-实际应用栈示例：一个-docker-compose-yml-文件搞定一切！\" class=\"headerlink\" title=\"🏗️ 实际应用栈示例：一个 docker-compose.yml 文件搞定一切！\"></a>🏗️ 实际应用栈示例：一个 <code>docker-compose.yml</code> 文件搞定一切！</h2><p>让我们来看一个完整的 <code>docker-compose.yml</code> 文件，它定义并编排上面提到的四个服务：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这是一个典型的开发环境配置示例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 使用较新的文件格式版本，支持健康检查条件等特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># services: 定义我们的应用栈包含的所有服务</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 前端服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如使用 Nginx 提供静态文件或代理到后端</span></span><br><span class=\"line\">  <span class=\"attr\">frontend:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地的 ./frontend 目录构建镜像，假设里面有你的前端代码和 Dockerfile</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./frontend</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 可以指定一个用于开发的 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># image: 如果是生产环境，你可能会直接使用预构建好的镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># image: my-frontend-nginx:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器一个易记的名字 (可选，开发环境方便)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_frontend</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射，让外部（你的浏览器）能访问到前端服务</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:80&quot;</span> <span class=\"comment\"># 将宿主机的 80 端口映射到容器内部 Nginx 的 80 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 挂载本地代码，方便开发时热更新 (仅开发环境常用)</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 将宿主机 ./frontend/dist 目录（你的前端构建输出）挂载到容器 Nginx 的静态文件目录</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./frontend/dist:/usr/share/nginx/html</span></span><br><span class=\"line\">      <span class=\"comment\"># 如果需要修改 Nginx 配置，也可以挂载配置文件</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./frontend/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 前端可能需要后端启动才能完全工作 (比如通过后端 API 获取数据)</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里我们假设前端只是提供静态文件，不直接依赖 backend 的启动，但如果前端需要调用后端API，可以加上依赖，但 service_healthy 通常是给后端依赖数据库/缓存用的</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果前端是一个 SPA，启动时不直接依赖后端，但运行中会调用，这里的 depends_on 可以省略</span></span><br><span class=\"line\">    <span class=\"comment\"># depends_on:</span></span><br><span class=\"line\">    <span class=\"comment\">#   backend:</span></span><br><span class=\"line\">    <span class=\"comment\">#     condition: service_started # 或者 service_healthy 如果 backend 配置了 healthcheck</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，可以访问 backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 后端服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如使用 Node.js 编写的 API</span></span><br><span class=\"line\">  <span class=\"attr\">backend:</span></span><br><span class=\"line\">    <span class=\"comment\"># build: 从本地的 ./backend 目录构建镜像</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">./backend</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 开发环境 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># image: 生产环境使用预构建镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># image: my-backend-api:latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_backend</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 端口映射 (如果需要从外部直接访问后端，比如调试API)</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果后端只被 frontend 或其他服务在内部网络访问，这里可以不映射端口</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3001:3000&quot;</span> <span class=\"comment\"># 将宿主机的 3001 端口映射到容器内部 Node.js 应用监听的 3000 端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 挂载本地代码和 node_modules (开发环境)</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 将宿主机 ./backend 目录挂载到容器 /app 目录</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./backend:/app</span></span><br><span class=\"line\">      <span class=\"comment\"># 特殊处理 node_modules：Node.js 应用的依赖通常很庞大且宿主机和容器的架构可能不同</span></span><br><span class=\"line\">      <span class=\"comment\"># 推荐使用一个匿名卷或命名卷来存放 node_modules</span></span><br><span class=\"line\">      <span class=\"comment\"># 这样既能保证依赖在容器里，又能避免本地挂载覆盖容器里安装好的依赖</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/node_modules</span> <span class=\"comment\"># 这是一个匿名卷的简写，表示挂载一个匿名卷到 /app/node_modules</span></span><br><span class=\"line\">                          <span class=\"comment\"># 如果 /app/node_modules 在容器构建时就存在，这个匿名卷会隐藏它</span></span><br><span class=\"line\">                          <span class=\"comment\"># 更好的做法是在 Dockerfile 里将 node_modules 安装到另一个目录，或者在 Compose 里使用命名卷</span></span><br><span class=\"line\">                          <span class=\"comment\"># 比如 volumes: - node_modules_volume:/app/node_modules</span></span><br><span class=\"line\">                          <span class=\"comment\"># 但匿名卷的写法在开发中也常见，用于隔离依赖</span></span><br><span class=\"line\">      <span class=\"comment\"># 持久化日志目录</span></span><br><span class=\"line\">      <span class=\"comment\"># - backend_logs:/app/logs</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置环境变量，将数据库和缓存的连接信息传给后端应用</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span> <span class=\"comment\"># 或者 production</span></span><br><span class=\"line\">      <span class=\"comment\"># 数据库连接信息，通过服务名访问，因为它们在同一个网络</span></span><br><span class=\"line\">      <span class=\"attr\">DB_HOST:</span> <span class=\"string\">db</span></span><br><span class=\"line\">      <span class=\"attr\">DB_USER:</span> <span class=\"string\">$&#123;DB_USER:-root&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取，如果没设置则默认 root</span></span><br><span class=\"line\">      <span class=\"attr\">DB_PASSWORD:</span> <span class=\"string\">$&#123;DB_PASSWORD&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取</span></span><br><span class=\"line\">      <span class=\"attr\">DB_NAME:</span> <span class=\"string\">myapp_db</span></span><br><span class=\"line\">      <span class=\"comment\"># 缓存连接信息</span></span><br><span class=\"line\">      <span class=\"attr\">REDIS_HOST:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">      <span class=\"attr\">REDIS_PORT:</span> <span class=\"number\">6379</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># depends_on: 后端依赖数据库和缓存，并且需要它们已经健康就绪</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 db 容器健康</span></span><br><span class=\"line\">      <span class=\"attr\">redis:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 redis 容器健康</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 后端应用自身的健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/healthz&quot;</span>] <span class=\"comment\"># 假设后端提供 /healthz 接口</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">15s</span> <span class=\"comment\"># 每 15 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 超时 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>    <span class=\"comment\"># 失败 3 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span> <span class=\"comment\"># 启动后 30 秒内检查失败不计入重试</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，可以访问 db 和 redis</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: 在生产环境会加上资源限制</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;1.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 1G</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 数据库服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如 MySQL</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span> <span class=\"comment\"># 使用官方 MySQL 镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_mysql_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 持久化数据库数据！使用命名卷</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 将 db_data 命名卷挂载到容器里 MySQL 存放数据的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># environment: 设置数据库的环境变量 (初始化密码、数据库名等)</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_ROOT_PASSWORD:</span> <span class=\"string\">$&#123;DB_ROOT_PASSWORD&#125;</span> <span class=\"comment\"># 从 .env 或宿主机环境变量获取 root 密码</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_db</span> <span class=\"comment\"># 自动创建的数据库名</span></span><br><span class=\"line\">      <span class=\"comment\"># MYSQL_USER: myuser # 如果需要非 root 用户</span></span><br><span class=\"line\">      <span class=\"comment\"># MYSQL_PASSWORD: mypassword # 如果需要非 root 用户密码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 如果需要从宿主机使用客户端工具（如 Navicat）连接数据库，可以映射端口</span></span><br><span class=\"line\">    <span class=\"comment\"># - &quot;3306:3306&quot; # 慎重！这会将数据库暴露给宿主机所有进程，生产环境不推荐直接映射，应通过跳板机或内网访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: 数据库健康检查，非常重要，backend 依赖它的 healthy 状态</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>] <span class=\"comment\"># 检查数据库连接是否正常</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每 10 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 超时 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span>    <span class=\"comment\"># 失败 5 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">20s</span> <span class=\"comment\"># 启动后 20 秒内检查失败不计入重试 (给数据库初始化时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，供 backend 访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: 数据库服务可能需要较多资源</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;2.0&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 2G</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># --- 缓存服务 ---</span></span><br><span class=\"line\">  <span class=\"comment\"># 比如 Redis</span></span><br><span class=\"line\">  <span class=\"attr\">redis:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis:7.2-alpine</span> <span class=\"comment\"># 使用官方 Redis 镜像 (alpine 版本更小)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给容器起名字 (可选)</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_redis</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># volumes: 持久化 Redis 数据 (如果需要，通常是 RDB 或 AOF 文件)</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果只是作为临时缓存，数据不重要，可以不挂载卷</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis_data:/data</span> <span class=\"comment\"># Redis 默认将数据存放在 /data 目录</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ports: 如果需要从宿主机使用客户端工具连接 Redis，可以映射端口</span></span><br><span class=\"line\">    <span class=\"comment\"># - &quot;6379:6379&quot; # 同数据库一样，生产环境慎重直接映射</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># healthcheck: Redis 健康检查</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;redis-cli&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>] <span class=\"comment\"># 检查 Redis 是否响应 PING 命令</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">5s</span>    <span class=\"comment\"># 每 5 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span>     <span class=\"comment\"># 超时 3 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span>      <span class=\"comment\"># 失败 3 次后标记 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 启动后 10 秒内检查失败不计入重试</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 异常退出时自动重启</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># 加入应用网络，供 backend 访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># resource limits: Redis 通常不需要太多资源 (除非数据量非常大)</span></span><br><span class=\"line\">    <span class=\"comment\"># deploy:</span></span><br><span class=\"line\">    <span class=\"comment\">#   resources:</span></span><br><span class=\"line\">    <span class=\"comment\">#     limits:</span></span><br><span class=\"line\">    <span class=\"comment\">#       cpus: &#x27;0.5&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">#       memory: 256M</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># volumes: 在顶层声明命名卷，用于持久化数据</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># MySQL 数据卷</span></span><br><span class=\"line\">  <span class=\"attr\">redis_data:</span> <span class=\"comment\"># Redis 数据卷</span></span><br><span class=\"line\">  <span class=\"comment\"># backend_logs: # 如果后端需要持久化日志，声明这个卷</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># networks: 在顶层声明自定义网络，让服务能通过服务名互相通信</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 声明一个叫 app_network 的网络</span></span><br><span class=\"line\">    <span class=\"comment\"># driver: bridge 是默认类型，通常不用写</span></span><br></pre></td></tr></table></figure>\n\n<p>为了让上面的 <code>docker-compose.yml</code> 示例能运行，你还需要：</p>\n<ol>\n<li>在项目根目录创建 <code>frontend</code> 和 <code>backend</code> 两个子文件夹。</li>\n<li>在 <code>frontend</code> 文件夹里，创建一个 <code>Dockerfile.dev</code> 和一个简单的 <code>dist</code> 文件夹（模拟前端构建输出）。<code>Dockerfile.dev</code> 里可以使用 <code>nginx:latest</code> 镜像，并将 <code>dist</code> 文件夹内容复制进去。</li>\n<li>在 <code>backend</code> 文件夹里，创建一个 <code>Dockerfile.dev</code> 和一个简单的 Node.js 应用入口文件（比如 <code>index.js</code>）。<code>Dockerfile.dev</code> 可以使用 <code>node:lts-alpine</code> 镜像，将代码复制进去，安装依赖，并定义启动命令。</li>\n<li>在项目根目录创建一个 <code>.env</code> 文件，至少包含 <code>DB_PASSWORD</code> 和 <code>DB_ROOT_PASSWORD</code>。</li>\n</ol>\n<p><strong>运行方法：</strong></p>\n<ol>\n<li>进入项目根目录。</li>\n<li>确保 Docker Desktop 或 Docker Engine 正在运行。</li>\n<li>执行命令启动整个应用栈：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d --build</span><br><span class=\"line\"><span class=\"comment\"># -d: 后台运行</span></span><br><span class=\"line\"><span class=\"comment\"># --build: 强制重新构建 frontend 和 backend 服务的镜像 (因为它们使用了 build)</span></span><br></pre></td></tr></table></figure></li>\n<li>使用 <code>docker-compose ps</code> 查看服务状态，确认它们都处于 <code>Up (healthy)</code> 状态。</li>\n<li>访问 <code>http://localhost</code> (如果前端映射到 80) 或 <code>http://localhost:3001</code> (如果直接访问后端) 来测试你的应用。</li>\n<li>使用 <code>docker-compose logs -f</code> 查看日志。</li>\n<li>完成后，使用 <code>docker-compose down</code> 停止并清理。</li>\n</ol>\n<hr>\n<h2 id=\"🏆-Docker-Compose-编写的最佳实践\"><a href=\"#🏆-Docker-Compose-编写的最佳实践\" class=\"headerlink\" title=\"🏆 Docker Compose 编写的最佳实践\"></a>🏆 Docker Compose 编写的最佳实践</h2><p>通过上面的例子，我们已经综合运用了大部分学过的知识。为了写出更清晰、更易于维护的 <code>docker-compose.yml</code> 文件，这里有一些通用的最佳实践建议：</p>\n<ol>\n<li><strong>使用最新稳定版本</strong>：在文件顶部指定 <code>version</code>，并尽量使用较新的稳定版本（比如 <code>3.8+</code>），以便使用最新的功能和语法。</li>\n<li><strong>结构清晰，服务独立</strong>：将不同的服务定义在 <code>services</code> 下面，每个服务块负责一个独立的组件。服务之间通过网络互相通信。</li>\n<li><strong>使用自定义网络</strong>：始终在顶层声明自定义网络 (<code>networks</code>)，并让相关的服务加入同一个网络。这比使用默认网络更清晰，也方便隔离。服务在同一个自定义网络中可以通过<strong>服务名</strong>互相访问，无需查找 IP 地址。</li>\n<li><strong>持久化重要数据使用命名卷</strong>：对于数据库数据、上传文件、重要的日志等需要长期保存的数据，一定要使用顶层声明的<strong>命名卷</strong> (<code>volumes</code>)。命名卷由 Docker 管理，生命周期独立于容器，能有效防止数据丢失。避免在生产环境使用绑定挂载来持久化应用数据。</li>\n<li><strong>开发环境利用绑定挂载</strong>：在开发环境中，利用绑定挂载 (<code>volumes: .:/app</code>) 将本地代码同步到容器，实现代码修改后的快速反馈（热更新），提高开发效率。</li>\n<li><strong>环境变量管理配置</strong>：将应用的配置信息（数据库连接、API 密钥等）通过 <code>environment</code> 或 <code>env_file</code> 传递给容器。使用 <code>$&#123;VAR_NAME&#125;</code> 语法引用环境变量。</li>\n<li><strong>利用 <code>.env</code> 文件加载默认变量</strong>：在项目根目录创建 <code>.env</code> 文件存放非敏感的默认环境变量。</li>\n<li><strong>使用多文件管理不同环境</strong>：对于开发、测试、生产等不同环境，创建基础文件 (<code>docker-compose.yml</code>) 和环境覆盖文件 (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code>)，通过 <code>docker-compose -f ... -f ... up</code> 来组合使用。</li>\n<li><strong>定义清晰的服务依赖</strong>：使用 <code>depends_on</code> 来表达服务间的启动顺序依赖。</li>\n<li><strong>配置 Healthcheck 并结合 <code>service_healthy</code></strong>：为关键服务（尤其是数据库、缓存、下游 API）配置 <code>healthcheck</code>，并在依赖它们的服务中使用 <code>depends_on: condition: service_healthy</code> 来确保依赖的服务真正就绪后再启动当前服务。这是构建稳定应用栈的关键。</li>\n<li><strong>在生产环境配置资源限制</strong>：使用 <code>deploy.resources.limits</code> 或 <code>cpu_quota</code>, <code>mem_limit</code> 来限制容器可用的 CPU 和内存，防止资源耗尽，提高系统稳定性。</li>\n<li><strong>合理配置日志驱动</strong>：根据环境需求配置 <code>logging</code> 驱动。开发环境限制日志文件大小，生产环境通常发送到集中的日志收集系统。</li>\n<li><strong>避免在生产环境使用 <code>container_name</code></strong>：固定的容器名不适合 Scale Up 和多实例部署，主要用于开发环境方便手动操作。</li>\n<li><strong>编写清晰的 Dockerfile</strong>：Docker Compose 负责编排，Dockerfile 负责构建单个服务镜像。编写高效、安全的 Dockerfile 是构建优秀 Docker 应用的基础。</li>\n<li><strong>注释</strong>：在复杂的 <code>docker-compose.yml</code> 文件中添加注释，解释各个部分的作用和配置，提高可读性。</li>\n</ol>\n<p>遵循这些最佳实践，你的 Docker Compose 文件将不仅能工作，而且会更易于理解、管理和维护，无论是你自己还是团队的其他成员，都能更顺畅地使用它来开发和部署应用。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们通过一个完整的 Web 应用栈示例，将之前学到的 <code>version</code>, <code>services</code>, <code>volumes</code>, <code>networks</code>, <code>build</code>, <code>image</code>, <code>ports</code>, <code>environment</code>, <code>depends_on: service_healthy</code>, <code>healthcheck</code>, <code>restart</code>, <code>container_name</code>, <code>deploy.resources</code> 等字段和概念综合应用了一遍。</p>\n<p>同时，我们也总结了 Docker Compose 编写的 15 条最佳实践，它们是提升你 Docker Compose 文件质量的重要指南。</p>\n<p>恭喜你！到这里，你已经掌握了使用 Docker Compose 定义、配置和管理一个多服务应用栈的核心技能。你现在可以自信地使用 Docker Compose 来容器化你的应用项目了！</p>\n<p>Docker 的世界远不止 Docker Compose，还有 Docker Swarm、Kubernetes 等更强大的容器编排工具。但 Docker Compose 是入门容器化应用编排的绝佳起点，它简洁易用，非常适合开发环境和简单的生产部署。</p>\n<p>希望这个系列的教程对你有帮助！祝你在容器化之旅中一切顺利！</p>\n"},{"title":"🐳 Docker Compose 深入服务配置篇（六）：资源限制与其他字段","date":"2025-06-07T06:00:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":37214,"_content":"\n# 🐳 精细控制你的容器：资源限制、命名与日志配置！\n\n你好呀！欢迎来到 Docker Compose 教程的第六章！我们已经一起走过了 Docker Compose 的基础构建（服务配置）、整体结构（顶层定义）、操作命令、服务依赖与健康检查，以及灵活的多环境配置。你的 Docker Compose “功力”正在显著提升！\n\n现在，是时候看看一些更进阶的服务配置字段了。这些字段虽然不像 `image`、`ports`、`volumes` 那样常用，但在特定的场景下却非常重要，比如控制容器对服务器资源的占用、给容器起个好记的名字，或者调整容器的日志行为。\n\n掌握这些字段，能让你对容器的控制更加精细，构建出更稳定、更易于管理的 Docker 化应用。\n\n---\n\n## 🏷️ 1. `container_name`：给你的容器起个专属名字\n\n默认情况下，Docker Compose 会给容器起一个由项目名、服务名和序号组成的冗长名字（比如 `myapp_web_1`）。虽然可以通过服务名在 Docker 网络中互相访问，但有时候你可能希望给特定的容器起一个更简单、更固定、更容易记住的名字。\n\n`container_name` 字段就是用来干这个的！\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    image: my-web-app\n    # container_name: 给这个服务创建的容器指定一个固定的名字\n    container_name: my_awesome_web_container # 我想让 web 服务的容器名字就叫这个\n\n  db:\n    image: mysql:5.7\n    # container_name:\n    container_name: my_project_mysql # 数据库容器名字\n\n# ... 其他配置 ...\n```\n\n*   **作用**：为服务创建的容器指定一个固定的、用户友好的名称。\n*   **优点**：\n    *   **易于识别**：在 `docker ps` 命令输出中一眼就能认出容器。\n    *   **方便操作**：可以直接使用这个固定名字来执行 `docker stop`, `docker rm`, `docker exec` 等 Docker 命令，而不用找那个长长的自动生成的名字。\n*   **缺点和注意事项**：\n    *   **唯一性**：Docker 容器的名字在宿主机上必须是唯一的。如果你的 `docker-compose.yml` 文件会部署多次（比如在不同的服务器上），或者同一个服务需要运行多个副本（`replicas > 1`，这在 Docker Compose V3 配合 Swarm/Kubernetes 时才会用到），就不能使用 `container_name`，因为这样会导致名字冲突。\n    *   **不适用于 Scale Up**：因为名字是固定的，如果你通过 `docker-compose up --scale web=3` 运行 `web` 服务创建多个副本，只有第一个容器能成功使用 `container_name`，后面的会因为名字冲突而失败。\n*   **适合场景**：\n    *   开发环境，容器数量少且固定，方便调试和手动操作。\n    *   单实例运行的服务（不打算 Scale Up）。\n\n---\n\n## 🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！\n\n容器虽然提供了隔离，但默认情况下，容器里的应用可以使用宿主机几乎全部的 CPU 和内存资源。如果你的应用出现 Bug 导致内存泄漏或者 CPU 占用 100%，它可能会影响甚至拖垮宿主机上运行的其他服务或进程。\n\n为了避免这种情况，在生产环境或者资源有限的环境中，强烈建议给你的容器设置**资源限制 (Resource Limits)**。Docker Compose 提供了字段来让你限制容器可以使用的 CPU 和内存。\n\n### 内存限制\n\n*   **`mem_limit`**：设置容器可以使用的**最大内存量**（包括 RAM 和 Swap）。\n*   **`memswap_limit`**：设置容器可以使用的总内存（RAM + Swap）。如果 `memswap_limit` 大于 `mem_limit`，差值就是容器可以使用 Swap 的最大量。如果 `memswap_limit` 和 `mem_limit` 相等，则禁用 Swap。如果 `memswap_limit` 不设置且 `mem_limit` 设置了，则容器可以使用 Swap 的量是 `mem_limit` 的两倍。\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-memory-hungry-app\n    # mem_limit: 限制容器最大内存使用，例如 512MB\n    mem_limit: 512m # 支持 b, k, m, g (bytes, kilobytes, megabytes, gigabytes) 单位\n\n    # memswap_limit: 限制总内存 (RAM + Swap)。这里设置为 1g，表示可以额外使用 512m 的 Swap (1g - 512m)\n    memswap_limit: 1g\n\n    # 如果只想限制 RAM 且禁用 Swap，可以这样：\n    # mem_limit: 512m\n    # memswap_limit: 512m # RAM 和 Swap 上限相等，禁用 Swap\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：防止单个容器耗尽宿主机的内存资源，提高系统的稳定性。\n*   **流程**：当容器尝试使用的内存超过 `mem_limit` 时，Docker 会尝试终止该容器中的进程。\n\n### CPU 限制\n\nCPU 限制有几种方式，可以提供不同粒度的控制：\n\n*   **`cpu_shares` (或 `cpu_weight`)**：设置 CPU “份额”或“权重”。这是一个相对值。如果两个容器，一个 `cpu_shares` 是 1024 (默认值)，另一个是 512，当 CPU 资源紧张时，第一个容器可能会获得两倍于第二个容器的 CPU 时间。这是一个软限制。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        cpu_shares: 512 # 分配的 CPU 份额较低，在 CPU 竞争时优先级低\n\n      worker:\n        image: my-background-worker\n        cpu_shares: 1024 # 默认值\n      # ...\n    ```\n    *   **作用**：在 CPU 资源紧张时，按比例分配 CPU 时间给容器。\n    *   **适合场景**：区分服务的优先级，重要的服务给更高的份额。\n\n*   **`cpu_quota` 和 `cpu_period`**：更精确的 CPU 硬限制。`cpu_period` 设置一个周期（默认 100ms），`cpu_quota` 设置在这个周期内容器最多可以使用多少 CPU 时间（微秒，1ms = 1000us）。\n    *   例如，`cpu_period: 100ms` (或 `100000`)，`cpu_quota: 50000`，表示在每 100ms 内，容器最多使用 50ms 的 CPU 时间，相当于限制为 0.5 个 CPU 核。\n    *   如果宿主机有 4 个 CPU 核，设置 `cpu_quota: 200000` 相当于限制为 2 个 CPU 核 (`200000 / 100000 = 2`)。\n    *   通常只设置 `cpu_quota`，`cpu_period` 使用默认值即可。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        # cpu_quota: 限制在每个周期内最多使用 50000 微秒的 CPU 时间 (相当于 0.5 个 CPU 核)\n        cpu_quota: 50000\n        # cpu_period: 周期，默认 100000 微秒 (100ms)\n        # cpu_period: 100000 # 通常不用写\n\n      # ...\n    ```\n    *   **作用**：将容器的 CPU 使用限制在固定的上限，即使宿主机资源富余，也不会超过这个限制。\n    *   **适合场景**：严格控制服务占用的 CPU 资源，避免其影响其他关键服务，或者根据服务需求分配固定的 CPU 核数。\n\n*   **`cpuset`**：将容器绑定到特定的 CPU 核。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        cpuset: \"0,1\" # 将容器限定在宿主机的 CPU 核 0 和 1 上运行\n\n      worker:\n        image: my-worker\n        cpuset: \"2\" # 将容器限定在宿主机的 CPU 核 2 上运行\n      # ...\n    ```\n    *   **作用**：将容器的 CPU 使用锁定在特定的 CPU 核，可以用于性能调优或隔离。\n    *   **适合场景**：需要隔离高性能应用，或者在 NUMA 架构下优化性能。\n\n### 新的 `resources` 语法 (Compose V3.8+)\n\n在 Docker Compose V3.8 及更高版本中，推荐使用 `resources` 字段来组织资源限制，结构更清晰。\n\n```yaml\nversion: '3.8' # 确保版本 >= 3.8\n\nservices:\n  app:\n    image: my-app\n    deploy: # 资源限制通常是部署相关的配置，放在 deploy 下 (Swarm Mode 语法，但在 Compose V3+ 中也常用于普通模式)\n      resources:\n        limits: # 硬限制 (不能超过)\n          cpus: '0.5' # 限制为 0.5 个 CPU 核 (相当于 cpu_quota / cpu_period)\n          memory: 512M # 限制最大内存 512MB (相当于 mem_limit)\n        reservations: # 预留资源 (保证至少拥有)\n          cpus: '0.25' # 预留 0.25 个 CPU 核\n          memory: 256M # 预留 256MB 内存\n    # ... 其他配置 ...\n```\n*注意：`deploy` 字段最初是用于 Docker Swarm 模式的部署配置，但在 Docker Compose V3.8+ 中，`deploy.resources` 也被用于普通模式下的资源限制。同时，旧的顶层 `cpus`, `mem_limit`, `memswap_limit` 等字段仍然可用，但推荐使用 `deploy.resources`。`cpu_shares` 和 `cpuset` 不在 `deploy.resources` 下，仍是服务顶层字段。*\n\n*   **`deploy.resources.limits`**：定义容器可以使用的资源上限（硬限制）。\n*   **`deploy.resources.reservations`**：定义为容器预留的资源量。当宿主机资源不足时，Docker 会优先保证预留了资源的容器。这是一个软保证，但有助于调度。\n\n*   **资源限制总结**：\n    *   **内存**：`mem_limit` 是最重要的，通常和 `memswap_limit` 一起用。\n    *   **CPU**：\n        *   软限制：`cpu_shares` (按比例分配 CPU 时间)\n        *   硬限制：`cpu_quota` / `cpu_period` (限制绝对 CPU 使用上限) 或 `deploy.resources.limits.cpus` (推荐 V3.8+)。\n        *   绑定核心：`cpuset` (将容器绑定到特定核)。\n    *   **推荐**：在生产环境，至少设置 `mem_limit` 和 `deploy.resources.limits.cpus` 或 `cpu_quota`。\n\n---\n\n## 🔖 3. `labels`：给你的服务和容器贴个“标签”\n\n`labels` 字段允许你给服务和由该服务创建的容器添加任意的元数据（metadata），也就是键值对形式的标签。这些标签本身不会影响容器的运行，但可以被 Docker 或第三方工具用于过滤、组织、监控、自动化等。\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    image: my-web-app\n    # labels: 给服务和容器添加标签\n    labels:\n      # 格式： 标签名: 标签值\n      com.example.department: \"marketing\" # 可以用反向域名格式避免冲突\n      version: \"1.2.0\" # 标明应用版本\n      monitoring.enabled: \"true\" # 告诉监控系统这个服务需要被监控\n      traefik.enable: \"true\" # 告诉 Traefik 这个服务需要被暴露 (Traefik 是一款流行的反向代理，常用标签来发现服务)\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：为服务和容器附加自定义的元数据，方便管理和自动化。\n*   **使用场景**：\n    *   **组织和分类**：按部门、环境、项目等对服务进行分类。\n    *   **自动化和发现**：让像 Traefik (反向代理)、Prometheus (监控) 等工具通过标签来发现和配置服务。\n    *   **过滤**：使用 `docker ps --filter label=key=value` 来查找特定标签的容器。\n    *   **版本管理**：在标签中标明服务版本。\n\n---\n\n## 🪵 4. `logging`：控制你的容器日志去哪儿？\n\n容器的标准输出 (stdout) 和标准错误 (stderr) 会被 Docker 捕获，并默认使用 `json-file` 驱动存储在宿主机上。`logging` 字段可以让你改变这种行为，选择不同的日志驱动 (Logging Driver) 并配置驱动的选项。\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-app\n    # logging: 配置日志行为\n    logging:\n      # driver: 指定日志驱动，默认是 json-file\n      driver: \"json-file\" # 默认驱动，日志存储为 JSON 文件在宿主机\n\n      # driver: \"none\" # 不记录日志，所有日志输出会被丢弃 (除非你手动进入容器查看)\n      # driver: \"syslog\" # 将日志发送到宿主机的 syslog 服务\n      # driver: \"journald\" # 将日志发送到宿主机的 systemd-journald 服务\n      # driver: \"fluentd\" # 将日志发送到 Fluentd 日志收集器\n\n      # options: 配置日志驱动的选项\n      options:\n        # json-file 驱动的选项：限制日志文件大小和数量\n        max-size: \"10m\" # 每个日志文件最大 10MB\n        max-file: \"5\" # 最多保留 5 个日志文件 (总共最多 50MB 日志)\n\n        # 其他驱动有不同的选项，比如 syslog 可以指定地址和 Facility\n        # syslog-address: \"tcp://192.168.1.5:514\"\n        # syslog-facility: \"daemon\"\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：控制容器日志的存储方式、发送目的地以及相关的参数（如文件大小限制）。\n*   **常用的日志驱动**：\n    *   `json-file` (默认)：简单方便，日志保存在宿主机本地，适合开发和简单部署。但如果日志量大，需要注意文件大小和数量限制，防止磁盘空间耗尽。\n    *   `none`：禁用日志记录，适合不需要日志的场景。\n    *   `syslog`, `journald`, `fluentd`, `splunk`, `awslogs` 等：这些是专业的日志收集驱动，用于将日志发送到集中的日志管理系统，方便统一收集、分析和存储，适合生产环境。\n*   **使用场景**：\n    *   在开发环境中，使用默认 `json-file` 驱动并设置 `max-size` 和 `max-file` 防止日志文件过大。\n    *   在生产环境中，配置 `logging` 驱动将日志发送到公司统一的日志收集平台。\n    *   对于某些输出大量日志但不需要保留的服务，可以使用 `driver: \"none\"`。\n\n---\n\n## 🧐 其他一些可能有用的服务字段\n\n除了上面详细介绍的，还有一些字段在特定场景下也会用到，这里简要提及：\n\n*   **`privileged: true`**：赋予容器几乎所有宿主机的权限。非常危险！只有在极少数需要直接操作宿主机硬件或内核的特殊容器时才使用，比如 Docker In Docker (DIND) 容器。\n*   **`cap_add`, `cap_drop`**：更细粒度地控制容器的 Linux 能力 (Capabilities)。比 `privileged` 安全得多，可以只赋予容器所需的特定权限（比如 `NET_ADMIN` 用于配置网络接口，`SYS_TIME` 用于修改系统时间）。\n*   **`read_only: true`**：将容器的根文件系统设置为只读。提高了安全性，强制应用将需要写入的数据保存到数据卷或 `/tmp`。\n*   **`tmpfs`**：挂载一个临时的文件系统到容器内，数据只存在于宿主机内存中，容器停止后数据会丢失。适合存放敏感或临时的非持久化数据，提高性能并减少对存储的 I/O。\n*   **`sysctls`**：在容器内部设置内核参数 (sysctls)。比如调优网络参数，或者设置共享内存限制等。\n\n```yaml\nservices:\n  special_app:\n    image: my-special-app\n    privileged: true # 非常危险，慎用！\n    # 或者更安全的做法：\n    # cap_add:\n    #   - NET_ADMIN\n    #   - SYS_TIME\n    read_only: true # 使容器文件系统只读\n\n  temp_data_processor:\n    image: my-processor\n    # tmpfs: 挂载一个临时文件系统到容器的 /app/temp 目录\n    tmpfs: /app/temp\n\n  high_perf_network_app:\n    image: my-network-app\n    # sysctls: 在容器内设置内核参数\n    sysctls:\n      net.core.somaxconn: 1024 # 增大网络连接队列长度\n      net.ipv4.tcp_syncookies: 0 # 关闭 SYN cookies\n\n    # ... 其他配置 ...\n```\n这些字段相对更高级，通常在遇到特定需求或问题时才会用到。对于初学者，重点掌握 `container_name`, 资源限制 (`mem_limit`, `deploy.resources`), `labels`, `logging` 就足够了。\n\n---\n\n## ✨ 综合示例：结合一些高级字段\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    image: myapp:latest\n    container_name: my_web_app # 指定容器名字\n\n    ports:\n      - \"80:3000\"\n\n    volumes:\n      - .:/app\n      - app_logs:/app/logs # 日志卷\n\n    environment:\n      - NODE_ENV=production\n      - API_KEY=${API_KEY}\n\n    # 资源限制：限制 CPU 和内存\n    deploy:\n      resources:\n        limits:\n          cpus: '0.75' # 限制最多使用 0.75 个 CPU 核\n          memory: 768M # 限制最大内存 768MB\n        reservations:\n          cpus: '0.25' # 预留 0.25 个 CPU 核\n          memory: 256M # 预留 256MB 内存\n\n    labels: # 添加标签\n      com.example.service: \"web\"\n      com.example.version: \"1.5\"\n      env: \"production\"\n\n    logging: # 配置日志，限制文件大小和数量\n      driver: \"json-file\"\n      options:\n        max-size: \"5m\"\n        max-file: \"3\"\n\n    depends_on:\n      db:\n        condition: service_healthy\n\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n    networks:\n      - app_network\n\n  db:\n    image: mysql:5.7\n    container_name: my_app_db # 指定容器名字\n\n    volumes:\n      - db_data:/var/lib/mysql\n\n    environment:\n      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}\n      - MYSQL_DATABASE=mydatabase\n\n    # 资源限制：数据库可能需要更多资源\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0' # 限制最多使用 1 个 CPU 核\n          memory: 1.5G # 限制最大内存 1.5GB\n        reservations:\n          cpus: '0.5' # 预留 0.5 个 CPU 核\n          memory: 512M # 预留 512MB 内存\n\n    labels: # 添加标签\n      com.example.service: \"database\"\n      db_type: \"mysql\"\n      env: \"production\"\n\n    logging: # 配置日志，也可以发送到其他地方\n      driver: \"json-file\"\n      options:\n        max-size: \"20m\" # 数据库日志可能更大\n        max-file: \"5\"\n\n\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n    networks:\n      - app_network\n\nvolumes:\n  db_data:\n  app_logs: # 声明日志卷\n\nnetworks:\n  app_network:\n```\n这个例子展示了如何在同一个文件里组合使用我们之前学过的核心字段和本章介绍的资源限制、命名、标签和日志配置。\n\n---\n\n**本章小结**\n\n我们学习了一些 Docker Compose 中用于精细控制服务行为的字段：\n*   `container_name`：给容器指定固定名称（方便操作，但有唯一性限制）。\n*   资源限制 (`mem_limit`, `memswap_limit`, `cpu_shares`, `cpu_quota`, `cpuset`) 以及推荐的 `deploy.resources` 语法：控制容器对 CPU 和内存的占用。\n*   `labels`：给服务和容器添加元数据标签，用于组织、过滤和自动化。\n*   `logging`：配置容器日志的驱动和选项，控制日志的去向和管理方式。\n*   简要了解了 `privileged`, `cap_add/drop`, `read_only`, `tmpfs`, `sysctls` 等高级字段。\n\n掌握这些字段，你可以更好地管理容器的资源使用，提高系统的稳定性和安全性，并方便地集成到现有的运维体系中。\n\n至此，我们已经覆盖了 Docker Compose 中大部分重要和常用的服务配置字段、顶层结构以及基本操作命令。在下一章，我们将把这些知识串联起来，通过一个**完整的实际应用栈示例**来回顾和实践，并讨论一些使用 Docker Compose 的**最佳实践**！敬请期待！\n","source":"_posts/Docker/Docker Compose 深入服务配置篇（六）：资源限制与其他字段.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 深入服务配置篇（六）：资源限制与其他字段\"\ndate: '2025-06-07 14:00'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 37214\n---\n\n# 🐳 精细控制你的容器：资源限制、命名与日志配置！\n\n你好呀！欢迎来到 Docker Compose 教程的第六章！我们已经一起走过了 Docker Compose 的基础构建（服务配置）、整体结构（顶层定义）、操作命令、服务依赖与健康检查，以及灵活的多环境配置。你的 Docker Compose “功力”正在显著提升！\n\n现在，是时候看看一些更进阶的服务配置字段了。这些字段虽然不像 `image`、`ports`、`volumes` 那样常用，但在特定的场景下却非常重要，比如控制容器对服务器资源的占用、给容器起个好记的名字，或者调整容器的日志行为。\n\n掌握这些字段，能让你对容器的控制更加精细，构建出更稳定、更易于管理的 Docker 化应用。\n\n---\n\n## 🏷️ 1. `container_name`：给你的容器起个专属名字\n\n默认情况下，Docker Compose 会给容器起一个由项目名、服务名和序号组成的冗长名字（比如 `myapp_web_1`）。虽然可以通过服务名在 Docker 网络中互相访问，但有时候你可能希望给特定的容器起一个更简单、更固定、更容易记住的名字。\n\n`container_name` 字段就是用来干这个的！\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    image: my-web-app\n    # container_name: 给这个服务创建的容器指定一个固定的名字\n    container_name: my_awesome_web_container # 我想让 web 服务的容器名字就叫这个\n\n  db:\n    image: mysql:5.7\n    # container_name:\n    container_name: my_project_mysql # 数据库容器名字\n\n# ... 其他配置 ...\n```\n\n*   **作用**：为服务创建的容器指定一个固定的、用户友好的名称。\n*   **优点**：\n    *   **易于识别**：在 `docker ps` 命令输出中一眼就能认出容器。\n    *   **方便操作**：可以直接使用这个固定名字来执行 `docker stop`, `docker rm`, `docker exec` 等 Docker 命令，而不用找那个长长的自动生成的名字。\n*   **缺点和注意事项**：\n    *   **唯一性**：Docker 容器的名字在宿主机上必须是唯一的。如果你的 `docker-compose.yml` 文件会部署多次（比如在不同的服务器上），或者同一个服务需要运行多个副本（`replicas > 1`，这在 Docker Compose V3 配合 Swarm/Kubernetes 时才会用到），就不能使用 `container_name`，因为这样会导致名字冲突。\n    *   **不适用于 Scale Up**：因为名字是固定的，如果你通过 `docker-compose up --scale web=3` 运行 `web` 服务创建多个副本，只有第一个容器能成功使用 `container_name`，后面的会因为名字冲突而失败。\n*   **适合场景**：\n    *   开发环境，容器数量少且固定，方便调试和手动操作。\n    *   单实例运行的服务（不打算 Scale Up）。\n\n---\n\n## 🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！\n\n容器虽然提供了隔离，但默认情况下，容器里的应用可以使用宿主机几乎全部的 CPU 和内存资源。如果你的应用出现 Bug 导致内存泄漏或者 CPU 占用 100%，它可能会影响甚至拖垮宿主机上运行的其他服务或进程。\n\n为了避免这种情况，在生产环境或者资源有限的环境中，强烈建议给你的容器设置**资源限制 (Resource Limits)**。Docker Compose 提供了字段来让你限制容器可以使用的 CPU 和内存。\n\n### 内存限制\n\n*   **`mem_limit`**：设置容器可以使用的**最大内存量**（包括 RAM 和 Swap）。\n*   **`memswap_limit`**：设置容器可以使用的总内存（RAM + Swap）。如果 `memswap_limit` 大于 `mem_limit`，差值就是容器可以使用 Swap 的最大量。如果 `memswap_limit` 和 `mem_limit` 相等，则禁用 Swap。如果 `memswap_limit` 不设置且 `mem_limit` 设置了，则容器可以使用 Swap 的量是 `mem_limit` 的两倍。\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-memory-hungry-app\n    # mem_limit: 限制容器最大内存使用，例如 512MB\n    mem_limit: 512m # 支持 b, k, m, g (bytes, kilobytes, megabytes, gigabytes) 单位\n\n    # memswap_limit: 限制总内存 (RAM + Swap)。这里设置为 1g，表示可以额外使用 512m 的 Swap (1g - 512m)\n    memswap_limit: 1g\n\n    # 如果只想限制 RAM 且禁用 Swap，可以这样：\n    # mem_limit: 512m\n    # memswap_limit: 512m # RAM 和 Swap 上限相等，禁用 Swap\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：防止单个容器耗尽宿主机的内存资源，提高系统的稳定性。\n*   **流程**：当容器尝试使用的内存超过 `mem_limit` 时，Docker 会尝试终止该容器中的进程。\n\n### CPU 限制\n\nCPU 限制有几种方式，可以提供不同粒度的控制：\n\n*   **`cpu_shares` (或 `cpu_weight`)**：设置 CPU “份额”或“权重”。这是一个相对值。如果两个容器，一个 `cpu_shares` 是 1024 (默认值)，另一个是 512，当 CPU 资源紧张时，第一个容器可能会获得两倍于第二个容器的 CPU 时间。这是一个软限制。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        cpu_shares: 512 # 分配的 CPU 份额较低，在 CPU 竞争时优先级低\n\n      worker:\n        image: my-background-worker\n        cpu_shares: 1024 # 默认值\n      # ...\n    ```\n    *   **作用**：在 CPU 资源紧张时，按比例分配 CPU 时间给容器。\n    *   **适合场景**：区分服务的优先级，重要的服务给更高的份额。\n\n*   **`cpu_quota` 和 `cpu_period`**：更精确的 CPU 硬限制。`cpu_period` 设置一个周期（默认 100ms），`cpu_quota` 设置在这个周期内容器最多可以使用多少 CPU 时间（微秒，1ms = 1000us）。\n    *   例如，`cpu_period: 100ms` (或 `100000`)，`cpu_quota: 50000`，表示在每 100ms 内，容器最多使用 50ms 的 CPU 时间，相当于限制为 0.5 个 CPU 核。\n    *   如果宿主机有 4 个 CPU 核，设置 `cpu_quota: 200000` 相当于限制为 2 个 CPU 核 (`200000 / 100000 = 2`)。\n    *   通常只设置 `cpu_quota`，`cpu_period` 使用默认值即可。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        # cpu_quota: 限制在每个周期内最多使用 50000 微秒的 CPU 时间 (相当于 0.5 个 CPU 核)\n        cpu_quota: 50000\n        # cpu_period: 周期，默认 100000 微秒 (100ms)\n        # cpu_period: 100000 # 通常不用写\n\n      # ...\n    ```\n    *   **作用**：将容器的 CPU 使用限制在固定的上限，即使宿主机资源富余，也不会超过这个限制。\n    *   **适合场景**：严格控制服务占用的 CPU 资源，避免其影响其他关键服务，或者根据服务需求分配固定的 CPU 核数。\n\n*   **`cpuset`**：将容器绑定到特定的 CPU 核。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        cpuset: \"0,1\" # 将容器限定在宿主机的 CPU 核 0 和 1 上运行\n\n      worker:\n        image: my-worker\n        cpuset: \"2\" # 将容器限定在宿主机的 CPU 核 2 上运行\n      # ...\n    ```\n    *   **作用**：将容器的 CPU 使用锁定在特定的 CPU 核，可以用于性能调优或隔离。\n    *   **适合场景**：需要隔离高性能应用，或者在 NUMA 架构下优化性能。\n\n### 新的 `resources` 语法 (Compose V3.8+)\n\n在 Docker Compose V3.8 及更高版本中，推荐使用 `resources` 字段来组织资源限制，结构更清晰。\n\n```yaml\nversion: '3.8' # 确保版本 >= 3.8\n\nservices:\n  app:\n    image: my-app\n    deploy: # 资源限制通常是部署相关的配置，放在 deploy 下 (Swarm Mode 语法，但在 Compose V3+ 中也常用于普通模式)\n      resources:\n        limits: # 硬限制 (不能超过)\n          cpus: '0.5' # 限制为 0.5 个 CPU 核 (相当于 cpu_quota / cpu_period)\n          memory: 512M # 限制最大内存 512MB (相当于 mem_limit)\n        reservations: # 预留资源 (保证至少拥有)\n          cpus: '0.25' # 预留 0.25 个 CPU 核\n          memory: 256M # 预留 256MB 内存\n    # ... 其他配置 ...\n```\n*注意：`deploy` 字段最初是用于 Docker Swarm 模式的部署配置，但在 Docker Compose V3.8+ 中，`deploy.resources` 也被用于普通模式下的资源限制。同时，旧的顶层 `cpus`, `mem_limit`, `memswap_limit` 等字段仍然可用，但推荐使用 `deploy.resources`。`cpu_shares` 和 `cpuset` 不在 `deploy.resources` 下，仍是服务顶层字段。*\n\n*   **`deploy.resources.limits`**：定义容器可以使用的资源上限（硬限制）。\n*   **`deploy.resources.reservations`**：定义为容器预留的资源量。当宿主机资源不足时，Docker 会优先保证预留了资源的容器。这是一个软保证，但有助于调度。\n\n*   **资源限制总结**：\n    *   **内存**：`mem_limit` 是最重要的，通常和 `memswap_limit` 一起用。\n    *   **CPU**：\n        *   软限制：`cpu_shares` (按比例分配 CPU 时间)\n        *   硬限制：`cpu_quota` / `cpu_period` (限制绝对 CPU 使用上限) 或 `deploy.resources.limits.cpus` (推荐 V3.8+)。\n        *   绑定核心：`cpuset` (将容器绑定到特定核)。\n    *   **推荐**：在生产环境，至少设置 `mem_limit` 和 `deploy.resources.limits.cpus` 或 `cpu_quota`。\n\n---\n\n## 🔖 3. `labels`：给你的服务和容器贴个“标签”\n\n`labels` 字段允许你给服务和由该服务创建的容器添加任意的元数据（metadata），也就是键值对形式的标签。这些标签本身不会影响容器的运行，但可以被 Docker 或第三方工具用于过滤、组织、监控、自动化等。\n\n```yaml\nversion: '3.8'\n\nservices:\n  web:\n    image: my-web-app\n    # labels: 给服务和容器添加标签\n    labels:\n      # 格式： 标签名: 标签值\n      com.example.department: \"marketing\" # 可以用反向域名格式避免冲突\n      version: \"1.2.0\" # 标明应用版本\n      monitoring.enabled: \"true\" # 告诉监控系统这个服务需要被监控\n      traefik.enable: \"true\" # 告诉 Traefik 这个服务需要被暴露 (Traefik 是一款流行的反向代理，常用标签来发现服务)\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：为服务和容器附加自定义的元数据，方便管理和自动化。\n*   **使用场景**：\n    *   **组织和分类**：按部门、环境、项目等对服务进行分类。\n    *   **自动化和发现**：让像 Traefik (反向代理)、Prometheus (监控) 等工具通过标签来发现和配置服务。\n    *   **过滤**：使用 `docker ps --filter label=key=value` 来查找特定标签的容器。\n    *   **版本管理**：在标签中标明服务版本。\n\n---\n\n## 🪵 4. `logging`：控制你的容器日志去哪儿？\n\n容器的标准输出 (stdout) 和标准错误 (stderr) 会被 Docker 捕获，并默认使用 `json-file` 驱动存储在宿主机上。`logging` 字段可以让你改变这种行为，选择不同的日志驱动 (Logging Driver) 并配置驱动的选项。\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-app\n    # logging: 配置日志行为\n    logging:\n      # driver: 指定日志驱动，默认是 json-file\n      driver: \"json-file\" # 默认驱动，日志存储为 JSON 文件在宿主机\n\n      # driver: \"none\" # 不记录日志，所有日志输出会被丢弃 (除非你手动进入容器查看)\n      # driver: \"syslog\" # 将日志发送到宿主机的 syslog 服务\n      # driver: \"journald\" # 将日志发送到宿主机的 systemd-journald 服务\n      # driver: \"fluentd\" # 将日志发送到 Fluentd 日志收集器\n\n      # options: 配置日志驱动的选项\n      options:\n        # json-file 驱动的选项：限制日志文件大小和数量\n        max-size: \"10m\" # 每个日志文件最大 10MB\n        max-file: \"5\" # 最多保留 5 个日志文件 (总共最多 50MB 日志)\n\n        # 其他驱动有不同的选项，比如 syslog 可以指定地址和 Facility\n        # syslog-address: \"tcp://192.168.1.5:514\"\n        # syslog-facility: \"daemon\"\n\n    # ... 其他配置 ...\n```\n\n*   **作用**：控制容器日志的存储方式、发送目的地以及相关的参数（如文件大小限制）。\n*   **常用的日志驱动**：\n    *   `json-file` (默认)：简单方便，日志保存在宿主机本地，适合开发和简单部署。但如果日志量大，需要注意文件大小和数量限制，防止磁盘空间耗尽。\n    *   `none`：禁用日志记录，适合不需要日志的场景。\n    *   `syslog`, `journald`, `fluentd`, `splunk`, `awslogs` 等：这些是专业的日志收集驱动，用于将日志发送到集中的日志管理系统，方便统一收集、分析和存储，适合生产环境。\n*   **使用场景**：\n    *   在开发环境中，使用默认 `json-file` 驱动并设置 `max-size` 和 `max-file` 防止日志文件过大。\n    *   在生产环境中，配置 `logging` 驱动将日志发送到公司统一的日志收集平台。\n    *   对于某些输出大量日志但不需要保留的服务，可以使用 `driver: \"none\"`。\n\n---\n\n## 🧐 其他一些可能有用的服务字段\n\n除了上面详细介绍的，还有一些字段在特定场景下也会用到，这里简要提及：\n\n*   **`privileged: true`**：赋予容器几乎所有宿主机的权限。非常危险！只有在极少数需要直接操作宿主机硬件或内核的特殊容器时才使用，比如 Docker In Docker (DIND) 容器。\n*   **`cap_add`, `cap_drop`**：更细粒度地控制容器的 Linux 能力 (Capabilities)。比 `privileged` 安全得多，可以只赋予容器所需的特定权限（比如 `NET_ADMIN` 用于配置网络接口，`SYS_TIME` 用于修改系统时间）。\n*   **`read_only: true`**：将容器的根文件系统设置为只读。提高了安全性，强制应用将需要写入的数据保存到数据卷或 `/tmp`。\n*   **`tmpfs`**：挂载一个临时的文件系统到容器内，数据只存在于宿主机内存中，容器停止后数据会丢失。适合存放敏感或临时的非持久化数据，提高性能并减少对存储的 I/O。\n*   **`sysctls`**：在容器内部设置内核参数 (sysctls)。比如调优网络参数，或者设置共享内存限制等。\n\n```yaml\nservices:\n  special_app:\n    image: my-special-app\n    privileged: true # 非常危险，慎用！\n    # 或者更安全的做法：\n    # cap_add:\n    #   - NET_ADMIN\n    #   - SYS_TIME\n    read_only: true # 使容器文件系统只读\n\n  temp_data_processor:\n    image: my-processor\n    # tmpfs: 挂载一个临时文件系统到容器的 /app/temp 目录\n    tmpfs: /app/temp\n\n  high_perf_network_app:\n    image: my-network-app\n    # sysctls: 在容器内设置内核参数\n    sysctls:\n      net.core.somaxconn: 1024 # 增大网络连接队列长度\n      net.ipv4.tcp_syncookies: 0 # 关闭 SYN cookies\n\n    # ... 其他配置 ...\n```\n这些字段相对更高级，通常在遇到特定需求或问题时才会用到。对于初学者，重点掌握 `container_name`, 资源限制 (`mem_limit`, `deploy.resources`), `labels`, `logging` 就足够了。\n\n---\n\n## ✨ 综合示例：结合一些高级字段\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    image: myapp:latest\n    container_name: my_web_app # 指定容器名字\n\n    ports:\n      - \"80:3000\"\n\n    volumes:\n      - .:/app\n      - app_logs:/app/logs # 日志卷\n\n    environment:\n      - NODE_ENV=production\n      - API_KEY=${API_KEY}\n\n    # 资源限制：限制 CPU 和内存\n    deploy:\n      resources:\n        limits:\n          cpus: '0.75' # 限制最多使用 0.75 个 CPU 核\n          memory: 768M # 限制最大内存 768MB\n        reservations:\n          cpus: '0.25' # 预留 0.25 个 CPU 核\n          memory: 256M # 预留 256MB 内存\n\n    labels: # 添加标签\n      com.example.service: \"web\"\n      com.example.version: \"1.5\"\n      env: \"production\"\n\n    logging: # 配置日志，限制文件大小和数量\n      driver: \"json-file\"\n      options:\n        max-size: \"5m\"\n        max-file: \"3\"\n\n    depends_on:\n      db:\n        condition: service_healthy\n\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n    networks:\n      - app_network\n\n  db:\n    image: mysql:5.7\n    container_name: my_app_db # 指定容器名字\n\n    volumes:\n      - db_data:/var/lib/mysql\n\n    environment:\n      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}\n      - MYSQL_DATABASE=mydatabase\n\n    # 资源限制：数据库可能需要更多资源\n    deploy:\n      resources:\n        limits:\n          cpus: '1.0' # 限制最多使用 1 个 CPU 核\n          memory: 1.5G # 限制最大内存 1.5GB\n        reservations:\n          cpus: '0.5' # 预留 0.5 个 CPU 核\n          memory: 512M # 预留 512MB 内存\n\n    labels: # 添加标签\n      com.example.service: \"database\"\n      db_type: \"mysql\"\n      env: \"production\"\n\n    logging: # 配置日志，也可以发送到其他地方\n      driver: \"json-file\"\n      options:\n        max-size: \"20m\" # 数据库日志可能更大\n        max-file: \"5\"\n\n\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n    networks:\n      - app_network\n\nvolumes:\n  db_data:\n  app_logs: # 声明日志卷\n\nnetworks:\n  app_network:\n```\n这个例子展示了如何在同一个文件里组合使用我们之前学过的核心字段和本章介绍的资源限制、命名、标签和日志配置。\n\n---\n\n**本章小结**\n\n我们学习了一些 Docker Compose 中用于精细控制服务行为的字段：\n*   `container_name`：给容器指定固定名称（方便操作，但有唯一性限制）。\n*   资源限制 (`mem_limit`, `memswap_limit`, `cpu_shares`, `cpu_quota`, `cpuset`) 以及推荐的 `deploy.resources` 语法：控制容器对 CPU 和内存的占用。\n*   `labels`：给服务和容器添加元数据标签，用于组织、过滤和自动化。\n*   `logging`：配置容器日志的驱动和选项，控制日志的去向和管理方式。\n*   简要了解了 `privileged`, `cap_add/drop`, `read_only`, `tmpfs`, `sysctls` 等高级字段。\n\n掌握这些字段，你可以更好地管理容器的资源使用，提高系统的稳定性和安全性，并方便地集成到现有的运维体系中。\n\n至此，我们已经覆盖了 Docker Compose 中大部分重要和常用的服务配置字段、顶层结构以及基本操作命令。在下一章，我们将把这些知识串联起来，通过一个**完整的实际应用栈示例**来回顾和实践，并讨论一些使用 Docker Compose 的**最佳实践**！敬请期待！\n","slug":"Docker/Docker Compose 深入服务配置篇（六）：资源限制与其他字段","published":1,"updated":"2025-06-07T15:58:53.664Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzww8000mpkrc6ra5fuu2","content":"<h1 id=\"🐳-精细控制你的容器：资源限制、命名与日志配置！\"><a href=\"#🐳-精细控制你的容器：资源限制、命名与日志配置！\" class=\"headerlink\" title=\"🐳 精细控制你的容器：资源限制、命名与日志配置！\"></a>🐳 精细控制你的容器：资源限制、命名与日志配置！</h1><p>你好呀！欢迎来到 Docker Compose 教程的第六章！我们已经一起走过了 Docker Compose 的基础构建（服务配置）、整体结构（顶层定义）、操作命令、服务依赖与健康检查，以及灵活的多环境配置。你的 Docker Compose “功力”正在显著提升！</p>\n<p>现在，是时候看看一些更进阶的服务配置字段了。这些字段虽然不像 <code>image</code>、<code>ports</code>、<code>volumes</code> 那样常用，但在特定的场景下却非常重要，比如控制容器对服务器资源的占用、给容器起个好记的名字，或者调整容器的日志行为。</p>\n<p>掌握这些字段，能让你对容器的控制更加精细，构建出更稳定、更易于管理的 Docker 化应用。</p>\n<hr>\n<h2 id=\"🏷️-1-container-name：给你的容器起个专属名字\"><a href=\"#🏷️-1-container-name：给你的容器起个专属名字\" class=\"headerlink\" title=\"🏷️ 1. container_name：给你的容器起个专属名字\"></a>🏷️ 1. <code>container_name</code>：给你的容器起个专属名字</h2><p>默认情况下，Docker Compose 会给容器起一个由项目名、服务名和序号组成的冗长名字（比如 <code>myapp_web_1</code>）。虽然可以通过服务名在 Docker 网络中互相访问，但有时候你可能希望给特定的容器起一个更简单、更固定、更容易记住的名字。</p>\n<p><code>container_name</code> 字段就是用来干这个的！</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给这个服务创建的容器指定一个固定的名字</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_awesome_web_container</span> <span class=\"comment\"># 我想让 web 服务的容器名字就叫这个</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name:</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_project_mysql</span> <span class=\"comment\"># 数据库容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：为服务创建的容器指定一个固定的、用户友好的名称。</li>\n<li><strong>优点</strong>：<ul>\n<li><strong>易于识别</strong>：在 <code>docker ps</code> 命令输出中一眼就能认出容器。</li>\n<li><strong>方便操作</strong>：可以直接使用这个固定名字来执行 <code>docker stop</code>, <code>docker rm</code>, <code>docker exec</code> 等 Docker 命令，而不用找那个长长的自动生成的名字。</li>\n</ul>\n</li>\n<li><strong>缺点和注意事项</strong>：<ul>\n<li><strong>唯一性</strong>：Docker 容器的名字在宿主机上必须是唯一的。如果你的 <code>docker-compose.yml</code> 文件会部署多次（比如在不同的服务器上），或者同一个服务需要运行多个副本（<code>replicas &gt; 1</code>，这在 Docker Compose V3 配合 Swarm&#x2F;Kubernetes 时才会用到），就不能使用 <code>container_name</code>，因为这样会导致名字冲突。</li>\n<li><strong>不适用于 Scale Up</strong>：因为名字是固定的，如果你通过 <code>docker-compose up --scale web=3</code> 运行 <code>web</code> 服务创建多个副本，只有第一个容器能成功使用 <code>container_name</code>，后面的会因为名字冲突而失败。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>开发环境，容器数量少且固定，方便调试和手动操作。</li>\n<li>单实例运行的服务（不打算 Scale Up）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🏋️-2-资源限制：控制你的容器不要“吃光”服务器资源！\"><a href=\"#🏋️-2-资源限制：控制你的容器不要“吃光”服务器资源！\" class=\"headerlink\" title=\"🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！\"></a>🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！</h2><p>容器虽然提供了隔离，但默认情况下，容器里的应用可以使用宿主机几乎全部的 CPU 和内存资源。如果你的应用出现 Bug 导致内存泄漏或者 CPU 占用 100%，它可能会影响甚至拖垮宿主机上运行的其他服务或进程。</p>\n<p>为了避免这种情况，在生产环境或者资源有限的环境中，强烈建议给你的容器设置<strong>资源限制 (Resource Limits)</strong>。Docker Compose 提供了字段来让你限制容器可以使用的 CPU 和内存。</p>\n<h3 id=\"内存限制\"><a href=\"#内存限制\" class=\"headerlink\" title=\"内存限制\"></a>内存限制</h3><ul>\n<li><strong><code>mem_limit</code></strong>：设置容器可以使用的<strong>最大内存量</strong>（包括 RAM 和 Swap）。</li>\n<li><strong><code>memswap_limit</code></strong>：设置容器可以使用的总内存（RAM + Swap）。如果 <code>memswap_limit</code> 大于 <code>mem_limit</code>，差值就是容器可以使用 Swap 的最大量。如果 <code>memswap_limit</code> 和 <code>mem_limit</code> 相等，则禁用 Swap。如果 <code>memswap_limit</code> 不设置且 <code>mem_limit</code> 设置了，则容器可以使用 Swap 的量是 <code>mem_limit</code> 的两倍。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-memory-hungry-app</span></span><br><span class=\"line\">    <span class=\"comment\"># mem_limit: 限制容器最大内存使用，例如 512MB</span></span><br><span class=\"line\">    <span class=\"attr\">mem_limit:</span> <span class=\"string\">512m</span> <span class=\"comment\"># 支持 b, k, m, g (bytes, kilobytes, megabytes, gigabytes) 单位</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># memswap_limit: 限制总内存 (RAM + Swap)。这里设置为 1g，表示可以额外使用 512m 的 Swap (1g - 512m)</span></span><br><span class=\"line\">    <span class=\"attr\">memswap_limit:</span> <span class=\"string\">1g</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果只想限制 RAM 且禁用 Swap，可以这样：</span></span><br><span class=\"line\">    <span class=\"comment\"># mem_limit: 512m</span></span><br><span class=\"line\">    <span class=\"comment\"># memswap_limit: 512m # RAM 和 Swap 上限相等，禁用 Swap</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：防止单个容器耗尽宿主机的内存资源，提高系统的稳定性。</li>\n<li><strong>流程</strong>：当容器尝试使用的内存超过 <code>mem_limit</code> 时，Docker 会尝试终止该容器中的进程。</li>\n</ul>\n<h3 id=\"CPU-限制\"><a href=\"#CPU-限制\" class=\"headerlink\" title=\"CPU 限制\"></a>CPU 限制</h3><p>CPU 限制有几种方式，可以提供不同粒度的控制：</p>\n<ul>\n<li><p><strong><code>cpu_shares</code> (或 <code>cpu_weight</code>)</strong>：设置 CPU “份额”或“权重”。这是一个相对值。如果两个容器，一个 <code>cpu_shares</code> 是 1024 (默认值)，另一个是 512，当 CPU 资源紧张时，第一个容器可能会获得两倍于第二个容器的 CPU 时间。这是一个软限制。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_shares:</span> <span class=\"number\">512</span> <span class=\"comment\"># 分配的 CPU 份额较低，在 CPU 竞争时优先级低</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-background-worker</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_shares:</span> <span class=\"number\">1024</span> <span class=\"comment\"># 默认值</span></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：在 CPU 资源紧张时，按比例分配 CPU 时间给容器。</li>\n<li><strong>适合场景</strong>：区分服务的优先级，重要的服务给更高的份额。</li>\n</ul>\n</li>\n<li><p><strong><code>cpu_quota</code> 和 <code>cpu_period</code></strong>：更精确的 CPU 硬限制。<code>cpu_period</code> 设置一个周期（默认 100ms），<code>cpu_quota</code> 设置在这个周期内容器最多可以使用多少 CPU 时间（微秒，1ms &#x3D; 1000us）。</p>\n<ul>\n<li>例如，<code>cpu_period: 100ms</code> (或 <code>100000</code>)，<code>cpu_quota: 50000</code>，表示在每 100ms 内，容器最多使用 50ms 的 CPU 时间，相当于限制为 0.5 个 CPU 核。</li>\n<li>如果宿主机有 4 个 CPU 核，设置 <code>cpu_quota: 200000</code> 相当于限制为 2 个 CPU 核 (<code>200000 / 100000 = 2</code>)。</li>\n<li>通常只设置 <code>cpu_quota</code>，<code>cpu_period</code> 使用默认值即可。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_quota: 限制在每个周期内最多使用 50000 微秒的 CPU 时间 (相当于 0.5 个 CPU 核)</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_quota:</span> <span class=\"number\">50000</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_period: 周期，默认 100000 微秒 (100ms)</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_period: 100000 # 通常不用写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：将容器的 CPU 使用限制在固定的上限，即使宿主机资源富余，也不会超过这个限制。</li>\n<li><strong>适合场景</strong>：严格控制服务占用的 CPU 资源，避免其影响其他关键服务，或者根据服务需求分配固定的 CPU 核数。</li>\n</ul>\n</li>\n<li><p><strong><code>cpuset</code></strong>：将容器绑定到特定的 CPU 核。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">cpuset:</span> <span class=\"string\">&quot;0,1&quot;</span> <span class=\"comment\"># 将容器限定在宿主机的 CPU 核 0 和 1 上运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-worker</span></span><br><span class=\"line\">    <span class=\"attr\">cpuset:</span> <span class=\"string\">&quot;2&quot;</span> <span class=\"comment\"># 将容器限定在宿主机的 CPU 核 2 上运行</span></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：将容器的 CPU 使用锁定在特定的 CPU 核，可以用于性能调优或隔离。</li>\n<li><strong>适合场景</strong>：需要隔离高性能应用，或者在 NUMA 架构下优化性能。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"新的-resources-语法-Compose-V3-8\"><a href=\"#新的-resources-语法-Compose-V3-8\" class=\"headerlink\" title=\"新的 resources 语法 (Compose V3.8+)\"></a>新的 <code>resources</code> 语法 (Compose V3.8+)</h3><p>在 Docker Compose V3.8 及更高版本中，推荐使用 <code>resources</code> 字段来组织资源限制，结构更清晰。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 确保版本 &gt;= 3.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span> <span class=\"comment\"># 资源限制通常是部署相关的配置，放在 deploy 下 (Swarm Mode 语法，但在 Compose V3+ 中也常用于普通模式)</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span> <span class=\"comment\"># 硬限制 (不能超过)</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.5&#x27;</span> <span class=\"comment\"># 限制为 0.5 个 CPU 核 (相当于 cpu_quota / cpu_period)</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">512M</span> <span class=\"comment\"># 限制最大内存 512MB (相当于 mem_limit)</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span> <span class=\"comment\"># 预留资源 (保证至少拥有)</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.25&#x27;</span> <span class=\"comment\"># 预留 0.25 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">256M</span> <span class=\"comment\"># 预留 256MB 内存</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：<code>deploy</code> 字段最初是用于 Docker Swarm 模式的部署配置，但在 Docker Compose V3.8+ 中，<code>deploy.resources</code> 也被用于普通模式下的资源限制。同时，旧的顶层 <code>cpus</code>, <code>mem_limit</code>, <code>memswap_limit</code> 等字段仍然可用，但推荐使用 <code>deploy.resources</code>。<code>cpu_shares</code> 和 <code>cpuset</code> 不在 <code>deploy.resources</code> 下，仍是服务顶层字段。</em></p>\n<ul>\n<li><p><strong><code>deploy.resources.limits</code></strong>：定义容器可以使用的资源上限（硬限制）。</p>\n</li>\n<li><p><strong><code>deploy.resources.reservations</code></strong>：定义为容器预留的资源量。当宿主机资源不足时，Docker 会优先保证预留了资源的容器。这是一个软保证，但有助于调度。</p>\n</li>\n<li><p><strong>资源限制总结</strong>：</p>\n<ul>\n<li><strong>内存</strong>：<code>mem_limit</code> 是最重要的，通常和 <code>memswap_limit</code> 一起用。</li>\n<li><strong>CPU</strong>：<ul>\n<li>软限制：<code>cpu_shares</code> (按比例分配 CPU 时间)</li>\n<li>硬限制：<code>cpu_quota</code> &#x2F; <code>cpu_period</code> (限制绝对 CPU 使用上限) 或 <code>deploy.resources.limits.cpus</code> (推荐 V3.8+)。</li>\n<li>绑定核心：<code>cpuset</code> (将容器绑定到特定核)。</li>\n</ul>\n</li>\n<li><strong>推荐</strong>：在生产环境，至少设置 <code>mem_limit</code> 和 <code>deploy.resources.limits.cpus</code> 或 <code>cpu_quota</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🔖-3-labels：给你的服务和容器贴个“标签”\"><a href=\"#🔖-3-labels：给你的服务和容器贴个“标签”\" class=\"headerlink\" title=\"🔖 3. labels：给你的服务和容器贴个“标签”\"></a>🔖 3. <code>labels</code>：给你的服务和容器贴个“标签”</h2><p><code>labels</code> 字段允许你给服务和由该服务创建的容器添加任意的元数据（metadata），也就是键值对形式的标签。这些标签本身不会影响容器的运行，但可以被 Docker 或第三方工具用于过滤、组织、监控、自动化等。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># labels: 给服务和容器添加标签</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式： 标签名: 标签值</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;marketing&quot;</span> <span class=\"comment\"># 可以用反向域名格式避免冲突</span></span><br><span class=\"line\">      <span class=\"attr\">version:</span> <span class=\"string\">&quot;1.2.0&quot;</span> <span class=\"comment\"># 标明应用版本</span></span><br><span class=\"line\">      <span class=\"attr\">monitoring.enabled:</span> <span class=\"string\">&quot;true&quot;</span> <span class=\"comment\"># 告诉监控系统这个服务需要被监控</span></span><br><span class=\"line\">      <span class=\"attr\">traefik.enable:</span> <span class=\"string\">&quot;true&quot;</span> <span class=\"comment\"># 告诉 Traefik 这个服务需要被暴露 (Traefik 是一款流行的反向代理，常用标签来发现服务)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：为服务和容器附加自定义的元数据，方便管理和自动化。</li>\n<li><strong>使用场景</strong>：<ul>\n<li><strong>组织和分类</strong>：按部门、环境、项目等对服务进行分类。</li>\n<li><strong>自动化和发现</strong>：让像 Traefik (反向代理)、Prometheus (监控) 等工具通过标签来发现和配置服务。</li>\n<li><strong>过滤</strong>：使用 <code>docker ps --filter label=key=value</code> 来查找特定标签的容器。</li>\n<li><strong>版本管理</strong>：在标签中标明服务版本。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🪵-4-logging：控制你的容器日志去哪儿？\"><a href=\"#🪵-4-logging：控制你的容器日志去哪儿？\" class=\"headerlink\" title=\"🪵 4. logging：控制你的容器日志去哪儿？\"></a>🪵 4. <code>logging</code>：控制你的容器日志去哪儿？</h2><p>容器的标准输出 (stdout) 和标准错误 (stderr) 会被 Docker 捕获，并默认使用 <code>json-file</code> 驱动存储在宿主机上。<code>logging</code> 字段可以让你改变这种行为，选择不同的日志驱动 (Logging Driver) 并配置驱动的选项。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"comment\"># logging: 配置日志行为</span></span><br><span class=\"line\">    <span class=\"attr\">logging:</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: 指定日志驱动，默认是 json-file</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span> <span class=\"comment\"># 默认驱动，日志存储为 JSON 文件在宿主机</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;none&quot; # 不记录日志，所有日志输出会被丢弃 (除非你手动进入容器查看)</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;syslog&quot; # 将日志发送到宿主机的 syslog 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;journald&quot; # 将日志发送到宿主机的 systemd-journald 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;fluentd&quot; # 将日志发送到 Fluentd 日志收集器</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># options: 配置日志驱动的选项</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"comment\"># json-file 驱动的选项：限制日志文件大小和数量</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;10m&quot;</span> <span class=\"comment\"># 每个日志文件最大 10MB</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;5&quot;</span> <span class=\"comment\"># 最多保留 5 个日志文件 (总共最多 50MB 日志)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 其他驱动有不同的选项，比如 syslog 可以指定地址和 Facility</span></span><br><span class=\"line\">        <span class=\"comment\"># syslog-address: &quot;tcp://192.168.1.5:514&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># syslog-facility: &quot;daemon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：控制容器日志的存储方式、发送目的地以及相关的参数（如文件大小限制）。</li>\n<li><strong>常用的日志驱动</strong>：<ul>\n<li><code>json-file</code> (默认)：简单方便，日志保存在宿主机本地，适合开发和简单部署。但如果日志量大，需要注意文件大小和数量限制，防止磁盘空间耗尽。</li>\n<li><code>none</code>：禁用日志记录，适合不需要日志的场景。</li>\n<li><code>syslog</code>, <code>journald</code>, <code>fluentd</code>, <code>splunk</code>, <code>awslogs</code> 等：这些是专业的日志收集驱动，用于将日志发送到集中的日志管理系统，方便统一收集、分析和存储，适合生产环境。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>在开发环境中，使用默认 <code>json-file</code> 驱动并设置 <code>max-size</code> 和 <code>max-file</code> 防止日志文件过大。</li>\n<li>在生产环境中，配置 <code>logging</code> 驱动将日志发送到公司统一的日志收集平台。</li>\n<li>对于某些输出大量日志但不需要保留的服务，可以使用 <code>driver: &quot;none&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧐-其他一些可能有用的服务字段\"><a href=\"#🧐-其他一些可能有用的服务字段\" class=\"headerlink\" title=\"🧐 其他一些可能有用的服务字段\"></a>🧐 其他一些可能有用的服务字段</h2><p>除了上面详细介绍的，还有一些字段在特定场景下也会用到，这里简要提及：</p>\n<ul>\n<li><strong><code>privileged: true</code></strong>：赋予容器几乎所有宿主机的权限。非常危险！只有在极少数需要直接操作宿主机硬件或内核的特殊容器时才使用，比如 Docker In Docker (DIND) 容器。</li>\n<li><strong><code>cap_add</code>, <code>cap_drop</code></strong>：更细粒度地控制容器的 Linux 能力 (Capabilities)。比 <code>privileged</code> 安全得多，可以只赋予容器所需的特定权限（比如 <code>NET_ADMIN</code> 用于配置网络接口，<code>SYS_TIME</code> 用于修改系统时间）。</li>\n<li><strong><code>read_only: true</code></strong>：将容器的根文件系统设置为只读。提高了安全性，强制应用将需要写入的数据保存到数据卷或 <code>/tmp</code>。</li>\n<li><strong><code>tmpfs</code></strong>：挂载一个临时的文件系统到容器内，数据只存在于宿主机内存中，容器停止后数据会丢失。适合存放敏感或临时的非持久化数据，提高性能并减少对存储的 I&#x2F;O。</li>\n<li><strong><code>sysctls</code></strong>：在容器内部设置内核参数 (sysctls)。比如调优网络参数，或者设置共享内存限制等。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">special_app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-special-app</span></span><br><span class=\"line\">    <span class=\"attr\">privileged:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 非常危险，慎用！</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者更安全的做法：</span></span><br><span class=\"line\">    <span class=\"comment\"># cap_add:</span></span><br><span class=\"line\">    <span class=\"comment\">#   - NET_ADMIN</span></span><br><span class=\"line\">    <span class=\"comment\">#   - SYS_TIME</span></span><br><span class=\"line\">    <span class=\"attr\">read_only:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 使容器文件系统只读</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">temp_data_processor:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-processor</span></span><br><span class=\"line\">    <span class=\"comment\"># tmpfs: 挂载一个临时文件系统到容器的 /app/temp 目录</span></span><br><span class=\"line\">    <span class=\"attr\">tmpfs:</span> <span class=\"string\">/app/temp</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">high_perf_network_app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-network-app</span></span><br><span class=\"line\">    <span class=\"comment\"># sysctls: 在容器内设置内核参数</span></span><br><span class=\"line\">    <span class=\"attr\">sysctls:</span></span><br><span class=\"line\">      <span class=\"attr\">net.core.somaxconn:</span> <span class=\"number\">1024</span> <span class=\"comment\"># 增大网络连接队列长度</span></span><br><span class=\"line\">      <span class=\"attr\">net.ipv4.tcp_syncookies:</span> <span class=\"number\">0</span> <span class=\"comment\"># 关闭 SYN cookies</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n<p>这些字段相对更高级，通常在遇到特定需求或问题时才会用到。对于初学者，重点掌握 <code>container_name</code>, 资源限制 (<code>mem_limit</code>, <code>deploy.resources</code>), <code>labels</code>, <code>logging</code> 就足够了。</p>\n<hr>\n<h2 id=\"✨-综合示例：结合一些高级字段\"><a href=\"#✨-综合示例：结合一些高级字段\" class=\"headerlink\" title=\"✨ 综合示例：结合一些高级字段\"></a>✨ 综合示例：结合一些高级字段</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_web_app</span> <span class=\"comment\"># 指定容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_logs:/app/logs</span> <span class=\"comment\"># 日志卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">API_KEY=$&#123;API_KEY&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 资源限制：限制 CPU 和内存</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.75&#x27;</span> <span class=\"comment\"># 限制最多使用 0.75 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">768M</span> <span class=\"comment\"># 限制最大内存 768MB</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.25&#x27;</span> <span class=\"comment\"># 预留 0.25 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">256M</span> <span class=\"comment\"># 预留 256MB 内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">labels:</span> <span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.service:</span> <span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.version:</span> <span class=\"string\">&quot;1.5&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span> <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">logging:</span> <span class=\"comment\"># 配置日志，限制文件大小和数量</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;5m&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_db</span> <span class=\"comment\"># 指定容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_ROOT_PASSWORD&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 资源限制：数据库可能需要更多资源</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;1.0&#x27;</span> <span class=\"comment\"># 限制最多使用 1 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"number\">1.</span><span class=\"string\">5G</span> <span class=\"comment\"># 限制最大内存 1.5GB</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.5&#x27;</span> <span class=\"comment\"># 预留 0.5 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">512M</span> <span class=\"comment\"># 预留 512MB 内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">labels:</span> <span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.service:</span> <span class=\"string\">&quot;database&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">db_type:</span> <span class=\"string\">&quot;mysql&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span> <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">logging:</span> <span class=\"comment\"># 配置日志，也可以发送到其他地方</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;20m&quot;</span> <span class=\"comment\"># 数据库日志可能更大</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br><span class=\"line\">  <span class=\"attr\">app_logs:</span> <span class=\"comment\"># 声明日志卷</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br></pre></td></tr></table></figure>\n<p>这个例子展示了如何在同一个文件里组合使用我们之前学过的核心字段和本章介绍的资源限制、命名、标签和日志配置。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了一些 Docker Compose 中用于精细控制服务行为的字段：</p>\n<ul>\n<li><code>container_name</code>：给容器指定固定名称（方便操作，但有唯一性限制）。</li>\n<li>资源限制 (<code>mem_limit</code>, <code>memswap_limit</code>, <code>cpu_shares</code>, <code>cpu_quota</code>, <code>cpuset</code>) 以及推荐的 <code>deploy.resources</code> 语法：控制容器对 CPU 和内存的占用。</li>\n<li><code>labels</code>：给服务和容器添加元数据标签，用于组织、过滤和自动化。</li>\n<li><code>logging</code>：配置容器日志的驱动和选项，控制日志的去向和管理方式。</li>\n<li>简要了解了 <code>privileged</code>, <code>cap_add/drop</code>, <code>read_only</code>, <code>tmpfs</code>, <code>sysctls</code> 等高级字段。</li>\n</ul>\n<p>掌握这些字段，你可以更好地管理容器的资源使用，提高系统的稳定性和安全性，并方便地集成到现有的运维体系中。</p>\n<p>至此，我们已经覆盖了 Docker Compose 中大部分重要和常用的服务配置字段、顶层结构以及基本操作命令。在下一章，我们将把这些知识串联起来，通过一个<strong>完整的实际应用栈示例</strong>来回顾和实践，并讨论一些使用 Docker Compose 的<strong>最佳实践</strong>！敬请期待！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-精细控制你的容器：资源限制、命名与日志配置！\"><a href=\"#🐳-精细控制你的容器：资源限制、命名与日志配置！\" class=\"headerlink\" title=\"🐳 精细控制你的容器：资源限制、命名与日志配置！\"></a>🐳 精细控制你的容器：资源限制、命名与日志配置！</h1><p>你好呀！欢迎来到 Docker Compose 教程的第六章！我们已经一起走过了 Docker Compose 的基础构建（服务配置）、整体结构（顶层定义）、操作命令、服务依赖与健康检查，以及灵活的多环境配置。你的 Docker Compose “功力”正在显著提升！</p>\n<p>现在，是时候看看一些更进阶的服务配置字段了。这些字段虽然不像 <code>image</code>、<code>ports</code>、<code>volumes</code> 那样常用，但在特定的场景下却非常重要，比如控制容器对服务器资源的占用、给容器起个好记的名字，或者调整容器的日志行为。</p>\n<p>掌握这些字段，能让你对容器的控制更加精细，构建出更稳定、更易于管理的 Docker 化应用。</p>\n<hr>\n<h2 id=\"🏷️-1-container-name：给你的容器起个专属名字\"><a href=\"#🏷️-1-container-name：给你的容器起个专属名字\" class=\"headerlink\" title=\"🏷️ 1. container_name：给你的容器起个专属名字\"></a>🏷️ 1. <code>container_name</code>：给你的容器起个专属名字</h2><p>默认情况下，Docker Compose 会给容器起一个由项目名、服务名和序号组成的冗长名字（比如 <code>myapp_web_1</code>）。虽然可以通过服务名在 Docker 网络中互相访问，但有时候你可能希望给特定的容器起一个更简单、更固定、更容易记住的名字。</p>\n<p><code>container_name</code> 字段就是用来干这个的！</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name: 给这个服务创建的容器指定一个固定的名字</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_awesome_web_container</span> <span class=\"comment\"># 我想让 web 服务的容器名字就叫这个</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># container_name:</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_project_mysql</span> <span class=\"comment\"># 数据库容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：为服务创建的容器指定一个固定的、用户友好的名称。</li>\n<li><strong>优点</strong>：<ul>\n<li><strong>易于识别</strong>：在 <code>docker ps</code> 命令输出中一眼就能认出容器。</li>\n<li><strong>方便操作</strong>：可以直接使用这个固定名字来执行 <code>docker stop</code>, <code>docker rm</code>, <code>docker exec</code> 等 Docker 命令，而不用找那个长长的自动生成的名字。</li>\n</ul>\n</li>\n<li><strong>缺点和注意事项</strong>：<ul>\n<li><strong>唯一性</strong>：Docker 容器的名字在宿主机上必须是唯一的。如果你的 <code>docker-compose.yml</code> 文件会部署多次（比如在不同的服务器上），或者同一个服务需要运行多个副本（<code>replicas &gt; 1</code>，这在 Docker Compose V3 配合 Swarm&#x2F;Kubernetes 时才会用到），就不能使用 <code>container_name</code>，因为这样会导致名字冲突。</li>\n<li><strong>不适用于 Scale Up</strong>：因为名字是固定的，如果你通过 <code>docker-compose up --scale web=3</code> 运行 <code>web</code> 服务创建多个副本，只有第一个容器能成功使用 <code>container_name</code>，后面的会因为名字冲突而失败。</li>\n</ul>\n</li>\n<li><strong>适合场景</strong>：<ul>\n<li>开发环境，容器数量少且固定，方便调试和手动操作。</li>\n<li>单实例运行的服务（不打算 Scale Up）。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🏋️-2-资源限制：控制你的容器不要“吃光”服务器资源！\"><a href=\"#🏋️-2-资源限制：控制你的容器不要“吃光”服务器资源！\" class=\"headerlink\" title=\"🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！\"></a>🏋️ 2. 资源限制：控制你的容器不要“吃光”服务器资源！</h2><p>容器虽然提供了隔离，但默认情况下，容器里的应用可以使用宿主机几乎全部的 CPU 和内存资源。如果你的应用出现 Bug 导致内存泄漏或者 CPU 占用 100%，它可能会影响甚至拖垮宿主机上运行的其他服务或进程。</p>\n<p>为了避免这种情况，在生产环境或者资源有限的环境中，强烈建议给你的容器设置<strong>资源限制 (Resource Limits)</strong>。Docker Compose 提供了字段来让你限制容器可以使用的 CPU 和内存。</p>\n<h3 id=\"内存限制\"><a href=\"#内存限制\" class=\"headerlink\" title=\"内存限制\"></a>内存限制</h3><ul>\n<li><strong><code>mem_limit</code></strong>：设置容器可以使用的<strong>最大内存量</strong>（包括 RAM 和 Swap）。</li>\n<li><strong><code>memswap_limit</code></strong>：设置容器可以使用的总内存（RAM + Swap）。如果 <code>memswap_limit</code> 大于 <code>mem_limit</code>，差值就是容器可以使用 Swap 的最大量。如果 <code>memswap_limit</code> 和 <code>mem_limit</code> 相等，则禁用 Swap。如果 <code>memswap_limit</code> 不设置且 <code>mem_limit</code> 设置了，则容器可以使用 Swap 的量是 <code>mem_limit</code> 的两倍。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-memory-hungry-app</span></span><br><span class=\"line\">    <span class=\"comment\"># mem_limit: 限制容器最大内存使用，例如 512MB</span></span><br><span class=\"line\">    <span class=\"attr\">mem_limit:</span> <span class=\"string\">512m</span> <span class=\"comment\"># 支持 b, k, m, g (bytes, kilobytes, megabytes, gigabytes) 单位</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># memswap_limit: 限制总内存 (RAM + Swap)。这里设置为 1g，表示可以额外使用 512m 的 Swap (1g - 512m)</span></span><br><span class=\"line\">    <span class=\"attr\">memswap_limit:</span> <span class=\"string\">1g</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果只想限制 RAM 且禁用 Swap，可以这样：</span></span><br><span class=\"line\">    <span class=\"comment\"># mem_limit: 512m</span></span><br><span class=\"line\">    <span class=\"comment\"># memswap_limit: 512m # RAM 和 Swap 上限相等，禁用 Swap</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：防止单个容器耗尽宿主机的内存资源，提高系统的稳定性。</li>\n<li><strong>流程</strong>：当容器尝试使用的内存超过 <code>mem_limit</code> 时，Docker 会尝试终止该容器中的进程。</li>\n</ul>\n<h3 id=\"CPU-限制\"><a href=\"#CPU-限制\" class=\"headerlink\" title=\"CPU 限制\"></a>CPU 限制</h3><p>CPU 限制有几种方式，可以提供不同粒度的控制：</p>\n<ul>\n<li><p><strong><code>cpu_shares</code> (或 <code>cpu_weight</code>)</strong>：设置 CPU “份额”或“权重”。这是一个相对值。如果两个容器，一个 <code>cpu_shares</code> 是 1024 (默认值)，另一个是 512，当 CPU 资源紧张时，第一个容器可能会获得两倍于第二个容器的 CPU 时间。这是一个软限制。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_shares:</span> <span class=\"number\">512</span> <span class=\"comment\"># 分配的 CPU 份额较低，在 CPU 竞争时优先级低</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-background-worker</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_shares:</span> <span class=\"number\">1024</span> <span class=\"comment\"># 默认值</span></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：在 CPU 资源紧张时，按比例分配 CPU 时间给容器。</li>\n<li><strong>适合场景</strong>：区分服务的优先级，重要的服务给更高的份额。</li>\n</ul>\n</li>\n<li><p><strong><code>cpu_quota</code> 和 <code>cpu_period</code></strong>：更精确的 CPU 硬限制。<code>cpu_period</code> 设置一个周期（默认 100ms），<code>cpu_quota</code> 设置在这个周期内容器最多可以使用多少 CPU 时间（微秒，1ms &#x3D; 1000us）。</p>\n<ul>\n<li>例如，<code>cpu_period: 100ms</code> (或 <code>100000</code>)，<code>cpu_quota: 50000</code>，表示在每 100ms 内，容器最多使用 50ms 的 CPU 时间，相当于限制为 0.5 个 CPU 核。</li>\n<li>如果宿主机有 4 个 CPU 核，设置 <code>cpu_quota: 200000</code> 相当于限制为 2 个 CPU 核 (<code>200000 / 100000 = 2</code>)。</li>\n<li>通常只设置 <code>cpu_quota</code>，<code>cpu_period</code> 使用默认值即可。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_quota: 限制在每个周期内最多使用 50000 微秒的 CPU 时间 (相当于 0.5 个 CPU 核)</span></span><br><span class=\"line\">    <span class=\"attr\">cpu_quota:</span> <span class=\"number\">50000</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_period: 周期，默认 100000 微秒 (100ms)</span></span><br><span class=\"line\">    <span class=\"comment\"># cpu_period: 100000 # 通常不用写</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：将容器的 CPU 使用限制在固定的上限，即使宿主机资源富余，也不会超过这个限制。</li>\n<li><strong>适合场景</strong>：严格控制服务占用的 CPU 资源，避免其影响其他关键服务，或者根据服务需求分配固定的 CPU 核数。</li>\n</ul>\n</li>\n<li><p><strong><code>cpuset</code></strong>：将容器绑定到特定的 CPU 核。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">cpuset:</span> <span class=\"string\">&quot;0,1&quot;</span> <span class=\"comment\"># 将容器限定在宿主机的 CPU 核 0 和 1 上运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">worker:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-worker</span></span><br><span class=\"line\">    <span class=\"attr\">cpuset:</span> <span class=\"string\">&quot;2&quot;</span> <span class=\"comment\"># 将容器限定在宿主机的 CPU 核 2 上运行</span></span><br><span class=\"line\">  <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>作用</strong>：将容器的 CPU 使用锁定在特定的 CPU 核，可以用于性能调优或隔离。</li>\n<li><strong>适合场景</strong>：需要隔离高性能应用，或者在 NUMA 架构下优化性能。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"新的-resources-语法-Compose-V3-8\"><a href=\"#新的-resources-语法-Compose-V3-8\" class=\"headerlink\" title=\"新的 resources 语法 (Compose V3.8+)\"></a>新的 <code>resources</code> 语法 (Compose V3.8+)</h3><p>在 Docker Compose V3.8 及更高版本中，推荐使用 <code>resources</code> 字段来组织资源限制，结构更清晰。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 确保版本 &gt;= 3.8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span> <span class=\"comment\"># 资源限制通常是部署相关的配置，放在 deploy 下 (Swarm Mode 语法，但在 Compose V3+ 中也常用于普通模式)</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span> <span class=\"comment\"># 硬限制 (不能超过)</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.5&#x27;</span> <span class=\"comment\"># 限制为 0.5 个 CPU 核 (相当于 cpu_quota / cpu_period)</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">512M</span> <span class=\"comment\"># 限制最大内存 512MB (相当于 mem_limit)</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span> <span class=\"comment\"># 预留资源 (保证至少拥有)</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.25&#x27;</span> <span class=\"comment\"># 预留 0.25 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">256M</span> <span class=\"comment\"># 预留 256MB 内存</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：<code>deploy</code> 字段最初是用于 Docker Swarm 模式的部署配置，但在 Docker Compose V3.8+ 中，<code>deploy.resources</code> 也被用于普通模式下的资源限制。同时，旧的顶层 <code>cpus</code>, <code>mem_limit</code>, <code>memswap_limit</code> 等字段仍然可用，但推荐使用 <code>deploy.resources</code>。<code>cpu_shares</code> 和 <code>cpuset</code> 不在 <code>deploy.resources</code> 下，仍是服务顶层字段。</em></p>\n<ul>\n<li><p><strong><code>deploy.resources.limits</code></strong>：定义容器可以使用的资源上限（硬限制）。</p>\n</li>\n<li><p><strong><code>deploy.resources.reservations</code></strong>：定义为容器预留的资源量。当宿主机资源不足时，Docker 会优先保证预留了资源的容器。这是一个软保证，但有助于调度。</p>\n</li>\n<li><p><strong>资源限制总结</strong>：</p>\n<ul>\n<li><strong>内存</strong>：<code>mem_limit</code> 是最重要的，通常和 <code>memswap_limit</code> 一起用。</li>\n<li><strong>CPU</strong>：<ul>\n<li>软限制：<code>cpu_shares</code> (按比例分配 CPU 时间)</li>\n<li>硬限制：<code>cpu_quota</code> &#x2F; <code>cpu_period</code> (限制绝对 CPU 使用上限) 或 <code>deploy.resources.limits.cpus</code> (推荐 V3.8+)。</li>\n<li>绑定核心：<code>cpuset</code> (将容器绑定到特定核)。</li>\n</ul>\n</li>\n<li><strong>推荐</strong>：在生产环境，至少设置 <code>mem_limit</code> 和 <code>deploy.resources.limits.cpus</code> 或 <code>cpu_quota</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🔖-3-labels：给你的服务和容器贴个“标签”\"><a href=\"#🔖-3-labels：给你的服务和容器贴个“标签”\" class=\"headerlink\" title=\"🔖 3. labels：给你的服务和容器贴个“标签”\"></a>🔖 3. <code>labels</code>：给你的服务和容器贴个“标签”</h2><p><code>labels</code> 字段允许你给服务和由该服务创建的容器添加任意的元数据（metadata），也就是键值对形式的标签。这些标签本身不会影响容器的运行，但可以被 Docker 或第三方工具用于过滤、组织、监控、自动化等。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-web-app</span></span><br><span class=\"line\">    <span class=\"comment\"># labels: 给服务和容器添加标签</span></span><br><span class=\"line\">    <span class=\"attr\">labels:</span></span><br><span class=\"line\">      <span class=\"comment\"># 格式： 标签名: 标签值</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.department:</span> <span class=\"string\">&quot;marketing&quot;</span> <span class=\"comment\"># 可以用反向域名格式避免冲突</span></span><br><span class=\"line\">      <span class=\"attr\">version:</span> <span class=\"string\">&quot;1.2.0&quot;</span> <span class=\"comment\"># 标明应用版本</span></span><br><span class=\"line\">      <span class=\"attr\">monitoring.enabled:</span> <span class=\"string\">&quot;true&quot;</span> <span class=\"comment\"># 告诉监控系统这个服务需要被监控</span></span><br><span class=\"line\">      <span class=\"attr\">traefik.enable:</span> <span class=\"string\">&quot;true&quot;</span> <span class=\"comment\"># 告诉 Traefik 这个服务需要被暴露 (Traefik 是一款流行的反向代理，常用标签来发现服务)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：为服务和容器附加自定义的元数据，方便管理和自动化。</li>\n<li><strong>使用场景</strong>：<ul>\n<li><strong>组织和分类</strong>：按部门、环境、项目等对服务进行分类。</li>\n<li><strong>自动化和发现</strong>：让像 Traefik (反向代理)、Prometheus (监控) 等工具通过标签来发现和配置服务。</li>\n<li><strong>过滤</strong>：使用 <code>docker ps --filter label=key=value</code> 来查找特定标签的容器。</li>\n<li><strong>版本管理</strong>：在标签中标明服务版本。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🪵-4-logging：控制你的容器日志去哪儿？\"><a href=\"#🪵-4-logging：控制你的容器日志去哪儿？\" class=\"headerlink\" title=\"🪵 4. logging：控制你的容器日志去哪儿？\"></a>🪵 4. <code>logging</code>：控制你的容器日志去哪儿？</h2><p>容器的标准输出 (stdout) 和标准错误 (stderr) 会被 Docker 捕获，并默认使用 <code>json-file</code> 驱动存储在宿主机上。<code>logging</code> 字段可以让你改变这种行为，选择不同的日志驱动 (Logging Driver) 并配置驱动的选项。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"comment\"># logging: 配置日志行为</span></span><br><span class=\"line\">    <span class=\"attr\">logging:</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: 指定日志驱动，默认是 json-file</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span> <span class=\"comment\"># 默认驱动，日志存储为 JSON 文件在宿主机</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;none&quot; # 不记录日志，所有日志输出会被丢弃 (除非你手动进入容器查看)</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;syslog&quot; # 将日志发送到宿主机的 syslog 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;journald&quot; # 将日志发送到宿主机的 systemd-journald 服务</span></span><br><span class=\"line\">      <span class=\"comment\"># driver: &quot;fluentd&quot; # 将日志发送到 Fluentd 日志收集器</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\"># options: 配置日志驱动的选项</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"comment\"># json-file 驱动的选项：限制日志文件大小和数量</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;10m&quot;</span> <span class=\"comment\"># 每个日志文件最大 10MB</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;5&quot;</span> <span class=\"comment\"># 最多保留 5 个日志文件 (总共最多 50MB 日志)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 其他驱动有不同的选项，比如 syslog 可以指定地址和 Facility</span></span><br><span class=\"line\">        <span class=\"comment\"># syslog-address: &quot;tcp://192.168.1.5:514&quot;</span></span><br><span class=\"line\">        <span class=\"comment\"># syslog-facility: &quot;daemon&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>作用</strong>：控制容器日志的存储方式、发送目的地以及相关的参数（如文件大小限制）。</li>\n<li><strong>常用的日志驱动</strong>：<ul>\n<li><code>json-file</code> (默认)：简单方便，日志保存在宿主机本地，适合开发和简单部署。但如果日志量大，需要注意文件大小和数量限制，防止磁盘空间耗尽。</li>\n<li><code>none</code>：禁用日志记录，适合不需要日志的场景。</li>\n<li><code>syslog</code>, <code>journald</code>, <code>fluentd</code>, <code>splunk</code>, <code>awslogs</code> 等：这些是专业的日志收集驱动，用于将日志发送到集中的日志管理系统，方便统一收集、分析和存储，适合生产环境。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>：<ul>\n<li>在开发环境中，使用默认 <code>json-file</code> 驱动并设置 <code>max-size</code> 和 <code>max-file</code> 防止日志文件过大。</li>\n<li>在生产环境中，配置 <code>logging</code> 驱动将日志发送到公司统一的日志收集平台。</li>\n<li>对于某些输出大量日志但不需要保留的服务，可以使用 <code>driver: &quot;none&quot;</code>。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🧐-其他一些可能有用的服务字段\"><a href=\"#🧐-其他一些可能有用的服务字段\" class=\"headerlink\" title=\"🧐 其他一些可能有用的服务字段\"></a>🧐 其他一些可能有用的服务字段</h2><p>除了上面详细介绍的，还有一些字段在特定场景下也会用到，这里简要提及：</p>\n<ul>\n<li><strong><code>privileged: true</code></strong>：赋予容器几乎所有宿主机的权限。非常危险！只有在极少数需要直接操作宿主机硬件或内核的特殊容器时才使用，比如 Docker In Docker (DIND) 容器。</li>\n<li><strong><code>cap_add</code>, <code>cap_drop</code></strong>：更细粒度地控制容器的 Linux 能力 (Capabilities)。比 <code>privileged</code> 安全得多，可以只赋予容器所需的特定权限（比如 <code>NET_ADMIN</code> 用于配置网络接口，<code>SYS_TIME</code> 用于修改系统时间）。</li>\n<li><strong><code>read_only: true</code></strong>：将容器的根文件系统设置为只读。提高了安全性，强制应用将需要写入的数据保存到数据卷或 <code>/tmp</code>。</li>\n<li><strong><code>tmpfs</code></strong>：挂载一个临时的文件系统到容器内，数据只存在于宿主机内存中，容器停止后数据会丢失。适合存放敏感或临时的非持久化数据，提高性能并减少对存储的 I&#x2F;O。</li>\n<li><strong><code>sysctls</code></strong>：在容器内部设置内核参数 (sysctls)。比如调优网络参数，或者设置共享内存限制等。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">special_app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-special-app</span></span><br><span class=\"line\">    <span class=\"attr\">privileged:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 非常危险，慎用！</span></span><br><span class=\"line\">    <span class=\"comment\"># 或者更安全的做法：</span></span><br><span class=\"line\">    <span class=\"comment\"># cap_add:</span></span><br><span class=\"line\">    <span class=\"comment\">#   - NET_ADMIN</span></span><br><span class=\"line\">    <span class=\"comment\">#   - SYS_TIME</span></span><br><span class=\"line\">    <span class=\"attr\">read_only:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 使容器文件系统只读</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">temp_data_processor:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-processor</span></span><br><span class=\"line\">    <span class=\"comment\"># tmpfs: 挂载一个临时文件系统到容器的 /app/temp 目录</span></span><br><span class=\"line\">    <span class=\"attr\">tmpfs:</span> <span class=\"string\">/app/temp</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">high_perf_network_app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-network-app</span></span><br><span class=\"line\">    <span class=\"comment\"># sysctls: 在容器内设置内核参数</span></span><br><span class=\"line\">    <span class=\"attr\">sysctls:</span></span><br><span class=\"line\">      <span class=\"attr\">net.core.somaxconn:</span> <span class=\"number\">1024</span> <span class=\"comment\"># 增大网络连接队列长度</span></span><br><span class=\"line\">      <span class=\"attr\">net.ipv4.tcp_syncookies:</span> <span class=\"number\">0</span> <span class=\"comment\"># 关闭 SYN cookies</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他配置 ...</span></span><br></pre></td></tr></table></figure>\n<p>这些字段相对更高级，通常在遇到特定需求或问题时才会用到。对于初学者，重点掌握 <code>container_name</code>, 资源限制 (<code>mem_limit</code>, <code>deploy.resources</code>), <code>labels</code>, <code>logging</code> 就足够了。</p>\n<hr>\n<h2 id=\"✨-综合示例：结合一些高级字段\"><a href=\"#✨-综合示例：结合一些高级字段\" class=\"headerlink\" title=\"✨ 综合示例：结合一些高级字段\"></a>✨ 综合示例：结合一些高级字段</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_web_app</span> <span class=\"comment\"># 指定容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_logs:/app/logs</span> <span class=\"comment\"># 日志卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">API_KEY=$&#123;API_KEY&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 资源限制：限制 CPU 和内存</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.75&#x27;</span> <span class=\"comment\"># 限制最多使用 0.75 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">768M</span> <span class=\"comment\"># 限制最大内存 768MB</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.25&#x27;</span> <span class=\"comment\"># 预留 0.25 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">256M</span> <span class=\"comment\"># 预留 256MB 内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">labels:</span> <span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.service:</span> <span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.version:</span> <span class=\"string\">&quot;1.5&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span> <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">logging:</span> <span class=\"comment\"># 配置日志，限制文件大小和数量</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;5m&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">my_app_db</span> <span class=\"comment\"># 指定容器名字</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_ROOT_PASSWORD&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 资源限制：数据库可能需要更多资源</span></span><br><span class=\"line\">    <span class=\"attr\">deploy:</span></span><br><span class=\"line\">      <span class=\"attr\">resources:</span></span><br><span class=\"line\">        <span class=\"attr\">limits:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;1.0&#x27;</span> <span class=\"comment\"># 限制最多使用 1 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"number\">1.</span><span class=\"string\">5G</span> <span class=\"comment\"># 限制最大内存 1.5GB</span></span><br><span class=\"line\">        <span class=\"attr\">reservations:</span></span><br><span class=\"line\">          <span class=\"attr\">cpus:</span> <span class=\"string\">&#x27;0.5&#x27;</span> <span class=\"comment\"># 预留 0.5 个 CPU 核</span></span><br><span class=\"line\">          <span class=\"attr\">memory:</span> <span class=\"string\">512M</span> <span class=\"comment\"># 预留 512MB 内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">labels:</span> <span class=\"comment\"># 添加标签</span></span><br><span class=\"line\">      <span class=\"attr\">com.example.service:</span> <span class=\"string\">&quot;database&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">db_type:</span> <span class=\"string\">&quot;mysql&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">env:</span> <span class=\"string\">&quot;production&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">logging:</span> <span class=\"comment\"># 配置日志，也可以发送到其他地方</span></span><br><span class=\"line\">      <span class=\"attr\">driver:</span> <span class=\"string\">&quot;json-file&quot;</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"attr\">max-size:</span> <span class=\"string\">&quot;20m&quot;</span> <span class=\"comment\"># 数据库日志可能更大</span></span><br><span class=\"line\">        <span class=\"attr\">max-file:</span> <span class=\"string\">&quot;5&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br><span class=\"line\">  <span class=\"attr\">app_logs:</span> <span class=\"comment\"># 声明日志卷</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br></pre></td></tr></table></figure>\n<p>这个例子展示了如何在同一个文件里组合使用我们之前学过的核心字段和本章介绍的资源限制、命名、标签和日志配置。</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了一些 Docker Compose 中用于精细控制服务行为的字段：</p>\n<ul>\n<li><code>container_name</code>：给容器指定固定名称（方便操作，但有唯一性限制）。</li>\n<li>资源限制 (<code>mem_limit</code>, <code>memswap_limit</code>, <code>cpu_shares</code>, <code>cpu_quota</code>, <code>cpuset</code>) 以及推荐的 <code>deploy.resources</code> 语法：控制容器对 CPU 和内存的占用。</li>\n<li><code>labels</code>：给服务和容器添加元数据标签，用于组织、过滤和自动化。</li>\n<li><code>logging</code>：配置容器日志的驱动和选项，控制日志的去向和管理方式。</li>\n<li>简要了解了 <code>privileged</code>, <code>cap_add/drop</code>, <code>read_only</code>, <code>tmpfs</code>, <code>sysctls</code> 等高级字段。</li>\n</ul>\n<p>掌握这些字段，你可以更好地管理容器的资源使用，提高系统的稳定性和安全性，并方便地集成到现有的运维体系中。</p>\n<p>至此，我们已经覆盖了 Docker Compose 中大部分重要和常用的服务配置字段、顶层结构以及基本操作命令。在下一章，我们将把这些知识串联起来，通过一个<strong>完整的实际应用栈示例</strong>来回顾和实践，并讨论一些使用 Docker Compose 的<strong>最佳实践</strong>！敬请期待！</p>\n"},{"title":"🐳 Docker Compose 灵活配置篇（五）：环境变量与多环境管理","date":"2025-06-07T05:00:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":58030,"_content":"\n# 🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！\n\n哈喽！我们又见面啦！通过前几章的学习，你已经掌握了如何描述单个服务、定义项目结构以及操作 Docker Compose。你甚至能搞定服务之间的复杂依赖和健康检查了，非常棒！\n\n现在，让我们面对一个更实际的问题：你的应用在**开发环境**可能连接的是本地的数据库，使用调试模式；在**生产环境**可能连接的是云端的数据库，需要更高的性能配置，使用生产模式。这些“随环境变化”的配置信息怎么管理呢？\n\n硬生生地在 `docker-compose.yml` 文件里改来改去显然不是个好主意，容易出错，也不方便。幸运的是，Docker Compose 提供了非常灵活的方式来处理这些问题，主要就是通过**环境变量**和**多文件组合**来实现！\n\n今天，我们就来深入学习如何让你的 Docker Compose 配置“活”起来，根据不同的环境加载不同的设置。\n\n---\n\n## 🌳 环境变量：配置信息的“活水”\n\n在第一章我们就提到了 `environment` 和 `env_file` 字段，它们是把配置信息作为环境变量传递给容器。为什么环境变量这么重要呢？\n\n1.  **灵活**：你可以在不修改镜像或 Docker Compose 文件本身的情况下，改变容器的行为。\n2.  **安全**：相较于直接在代码里硬编码，环境变量更适合传递一些非敏感或敏感程度较低的配置。\n3.  **标准**：这是云原生应用和微服务常用的配置方式，符合“十二要素应用”（The Twelve-Factor App）的原则。\n\n### 复习：两种传递环境变量的方式\n\n*   **`environment`**：直接在服务配置里列出变量名和值。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        environment:\n          - NODE_ENV=development\n          - PORT=3000\n    ```\n    *   **适合场景**：变量少，或者变量值比较固定且不敏感。\n\n*   **`env_file`**：从一个或多个文件中读取变量。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        env_file:\n          - .env # 加载当前目录下的 .env 文件\n          - ./config/app.env # 也可以加载其他文件\n    ```\n    *   **适合场景**：变量多，或者想把配置和 `docker-compose.yml` 文件分开，让文件更整洁。\n\n### `.env` 文件：Docker Compose 的“默认配置包”\n\n当你在项目根目录下创建一个名为 `.env` 的文件时，**Docker Compose 在运行任何命令（如 `up`, `down`, `build` 等）时，会默认自动加载这个文件中的环境变量**。\n\n```env\n# 文件名：.env\n# 格式：变量名=值 （注意等号两边通常没有空格，值如果有空格或特殊字符需要用引号包起来）\n\nDB_HOST=localhost\nDB_PORT=3306\nDB_USER=root\nDB_PASSWORD=mysecretpassword\n\nAPI_KEY=abcdef123456\nDEBUG=true\n```\n\n然后在 `docker-compose.yml` 文件中，你可以使用 `${变量名}` 的语法来引用这些变量：\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-app\n    environment:\n      # 直接引用 .env 文件里或者宿主机环境中的变量\n      - DB_HOST=${DB_HOST}\n      - DB_PORT=${DB_PORT}\n      - API_KEY=${API_KEY}\n      - DEBUG=${DEBUG}\n      # 你也可以同时设置一些没有在 .env 文件里的变量\n      - APP_MODE=web\n\n    # 或者使用 env_file 加载 .env 文件，效果一样，但这种方式更显式\n    # env_file:\n    #   - .env\n\n  db:\n    image: mysql:5.7\n    environment:\n      # 同样引用变量\n      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}\n      - MYSQL_DATABASE=mydatabase\n    volumes:\n      - db_data:/var/lib/mysql\n\nvolumes:\n  db_data:\n```\n\n当你运行 `docker-compose up` 时，Docker Compose 会：\n1.  读取当前目录下的 `.env` 文件，将里面的 `DB_HOST`, `DB_PORT` 等变量加载到内存中。\n2.  解析 `docker-compose.yml` 文件。\n3.  遇到 `${DB_HOST}` 等占位符时，用从 `.env` 或宿主机环境中加载到的实际值替换它们。\n4.  用替换后的完整配置来创建和启动容器，并将这些变量传递给容器。\n\n*   **变量加载顺序 (优先级从高到低)**：\n    1.  在命令行中传递的环境变量（例如 `DB_HOST=192.168.1.1 docker-compose up`）。\n    2.  宿主机/Shell 环境中已经存在的环境变量。\n    3.  `.env` 文件中的变量。\n    4.  `docker-compose.yml` 中 `environment` 字段直接设置的值。\n    *理解这个顺序很重要，你可以通过设置宿主机环境变量来覆盖 `.env` 文件中的值！*\n\n*   **`.env` 文件适合场景**：\n    *   存储开发环境的默认配置。\n    *   存储一些非敏感的应用参数。\n    *   方便团队成员共享基础配置。\n\n*   **`.env` 文件**不适合**场景**：\n    *   存储真正的**生产环境敏感密钥**（如生产数据库密码、第三方服务 API Key）。虽然 `.env` 文件本身可能不提交到 Git，但这种方式不够安全和健壮。生产环境推荐使用 Docker Secrets 或 Kubernetes Secrets 等更专业的密钥管理方案。\n\n---\n\n## 🔄 多环境管理：用 `-f` 组合不同的配置文件！\n\n`.env` 文件方便了环境变量的管理，但如果不同环境（dev/prod）的配置差异很大，比如：\n\n*   开发环境：使用本地构建的镜像 (`build`)，端口映射到 `3000`，挂载本地代码目录 (`volumes: .:/app`)，连接 Docker 网络内的数据库 (`DB_HOST=db`)。\n*   生产环境：使用预构建的镜像 (`image: my-app:latest`)，端口映射到 `80`，不挂载本地代码，连接外部的云数据库 (`DB_HOST=prod.database.com`)。\n\n这些差异涉及到 `build`, `image`, `ports`, `volumes`, `environment` 等多个字段，只靠 `.env` 文件就很难管理了。\n\n这时，最佳实践是使用 **多个 `docker-compose.yml` 文件**，并通过 `docker-compose` 命令的 `-f` 参数来组合和覆盖配置！\n\n基本思想是：\n1.  创建一个 **基础文件** (`docker-compose.yml`)：包含所有环境共用的配置（比如服务名称、网络定义、卷定义、一些通用的环境变量、重启策略等）。\n2.  创建 **环境特定覆盖文件** (`docker-compose.dev.yml`, `docker-compose.prod.yml` 等)：只包含特定环境的配置**差异**或**覆盖项**。\n\n当使用 `docker-compose -f docker-compose.yml -f docker-compose.dev.yml up` 时，Docker Compose 会**合并**这两个文件。后面文件的配置会覆盖前面文件的相同部分。\n\n### 示例：开发环境 vs 生产环境\n\n假设你有以下需求：\n\n*   **基础配置 (`docker-compose.yml`)**：\n    *   定义 `app` 和 `db` 服务。\n    *   定义一个共同的网络 `app_network`。\n    *   `db` 服务使用 `mysql:5.7` 镜像，持久化到命名卷 `db_data`。\n    *   `app` 服务连接到 `app_network`，依赖 `db`。\n    *   通用环境变量如 `API_KEY`，从 `.env` 加载。\n    *   `restart` 策略为 `unless-stopped`。\n\n*   **开发环境覆盖 (`docker-compose.dev.yml`)**：\n    *   `app` 服务使用 `build: .` 构建本地镜像。\n    *   `app` 服务端口映射 `3000:3000`。\n    *   `app` 服务挂载本地代码卷 `. : /app`。\n    *   `app` 服务设置 `NODE_ENV=development`。\n    *   `db` 服务使用默认端口和内部网络名连接 (`DB_HOST=db`)。\n    *   使用 `.env.dev` 文件加载开发环境特有变量。\n\n*   **生产环境覆盖 (`docker-compose.prod.yml`)**：\n    *   `app` 服务使用 `image: myapp:latest` 镜像。\n    *   `app` 服务端口映射 `80:3000`。\n    *   `app` 服务不挂载本地代码卷。\n    *   `app` 服务设置 `NODE_ENV=production`。\n    *   `db` 服务连接外部数据库 (`DB_HOST=prod.database.com`)。\n    *   使用 `.env.prod` 文件加载生产环境特有变量。\n\n**第一步：创建 `.env.dev` 和 `.env.prod` 文件**\n\n```env\n# 文件名：.env.dev\n# 开发环境特有的变量\nDB_HOST=db # 在 docker 网络里，数据库服务名叫 db\nDB_PORT=3306\nDEBUG=true\n```\n\n```env\n# 文件名：.env.prod\n# 生产环境特有的变量\nDB_HOST=prod.database.com # 外部数据库地址\nDB_PORT=3306\nDEBUG=false\n```\n*(注意：`.env` 文件如果存在，也会被默认加载，然后 `.env.dev` 或 `.env.prod` 如果被 env_file 指定，其中的变量会覆盖 `.env` 中同名的变量。)*\n\n**第二步：创建基础文件 (`docker-compose.yml`)**\n\n```yaml\n# 文件名: docker-compose.yml\nversion: '3.8'\n\nservices:\n  app:\n    # build 或 image 在覆盖文件里指定\n    # ports 在覆盖文件里指定\n    # volumes (代码挂载) 在覆盖文件里指定\n    # environment (NODE_ENV, DB_HOST等) 在覆盖文件里指定\n    # env_file 在覆盖文件里指定\n\n    restart: unless-stopped # 重启策略是通用的\n\n    depends_on:\n      # app 依赖 db 处于健康状态 (需要 db 服务配置 healthcheck)\n      db:\n        condition: service_healthy\n\n    networks:\n      - app_network # app 和 db 都在同一个网络里通信\n\n    # 通用健康检查 (如果健康检查方式不同，可以在覆盖文件里重写)\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  db:\n    image: mysql:5.7\n    # environment (密码, DB_NAME) 可以在 .env 或者覆盖文件里指定\n    # volumes (数据卷) 在这里指定结构，或者在覆盖文件里指定不同类型\n    volumes:\n      - db_data:/var/lib/mysql # 默认使用命名卷\n\n    restart: unless-stopped # 重启策略是通用的\n\n    networks:\n      - app_network # app 和 db 在同一个网络里通信\n\n    # 数据库健康检查 (通用)\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n\n# 顶层声明命名卷 (通用)\nvolumes:\n  db_data:\n\n# 顶层声明网络 (通用)\nnetworks:\n  app_network:\n```\n\n**第三步：创建开发环境覆盖文件 (`docker-compose.dev.yml`)**\n\n```yaml\n# 文件名: docker-compose.dev.yml\n# 这个文件会覆盖 docker-compose.yml 中的一些设置\n\nversion: '3.8' # 版本号需要和基础文件一致\n\nservices:\n  app:\n    # 覆盖或添加 app 服务的配置\n    build:\n      context: . # 开发环境从本地构建\n      dockerfile: Dockerfile.dev # 可能使用不同的 Dockerfile\n\n    ports:\n      - \"3000:3000\" # 开发环境映射到 3000\n\n    volumes:\n      # 覆盖 volumes，添加本地代码挂载（注意：列表是合并，如果基础文件有命名卷，这里需要重写整个 volumes 列表）\n      # Docker Compose V3+ 合并规则是：列表类型的字段会**合并**，映射类型的字段会**覆盖**。\n      # 为了清晰，通常在覆盖文件里写全需要的所有 volumes。\n      - .:/app # 添加本地代码挂载\n      - db_data:/var/lib/mysql # 也要保留数据库的数据卷挂载\n\n    environment:\n      # 覆盖或添加环境变量\n      NODE_ENV: development\n\n    env_file:\n      - .env.dev # 加载开发环境特有的变量文件\n\n  db:\n    # 覆盖或添加 db 服务的配置\n    # 在开发环境，db 的健康检查可能更宽松\n    healthcheck:\n      interval: 5s # 检查频率高一点\n      timeout: 3s\n      retries: 3\n      start_period: 10s\n\n    # db 在 dev 环境可能也需要一些特定的环境变量，比如创建测试数据库\n    environment:\n      MYSQL_DATABASE: myapp_dev # 覆盖或添加环境变量\n```\n*注意：`volumes` 字段是列表，Docker Compose 合并时会把所有列表项加在一起。如果你想**替换**某个卷而不是**添加**，或者想在覆盖文件中明确卷的类型（如本地路径 vs 命名卷），你需要写完整的 `volumes` 配置，它会覆盖基础文件中的同名字段。上面的例子中，`volumes` 列表被完整替换了，包含了基础文件中的命名卷和开发环境特有的绑定挂载。`environment` 是映射，同名变量会覆盖。*\n\n**第四步：创建生产环境覆盖文件 (`docker-compose.prod.yml`)**\n\n```yaml\n# 文件名: docker-compose.prod.yml\n# 这个文件会覆盖 docker-compose.yml 中的一些设置\n\nversion: '3.8' # 版本号需要和基础文件一致\n\nservices:\n  app:\n    # 覆盖或添加 app 服务的配置\n    image: myapp:latest # 生产环境使用预构建的镜像\n    # build: # 生产环境不需要 build，所以这里不写 build 字段，或者设置为 null/[]\n\n    ports:\n      - \"80:3000\" # 生产环境映射到 80\n\n    volumes:\n      # 生产环境不挂载本地代码，只保留数据卷挂载\n      - db_data:/var/lib/mysql # 保留数据库的数据卷挂载\n\n    environment:\n      # 覆盖或添加环境变量\n      NODE_ENV: production\n\n    env_file:\n      - .env.prod # 加载生产环境特有的变量文件\n\n  db:\n    # 生产环境 db 可能不需要特定的覆盖，使用基础文件和 .env.prod 中的配置即可\n    # 如果需要，可以在这里添加覆盖配置\n    environment:\n      MYSQL_DATABASE: myapp_prod # 生产环境数据库名不同\n```\n*同样注意 `volumes` 的合并规则，这里只保留了 `db_data` 的挂载。*\n\n### 运行不同环境的应用\n\n现在，你可以使用 `-f` 参数来指定要加载哪些配置文件。\n\n*   **运行开发环境：**\n    ```bash\n    # 默认 docker-compose.yml 是第一个加载的文件\n    # 然后 docker-compose.dev.yml 会覆盖其中的配置\n    # -d 参数表示以后台模式运行\n    docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build\n    # --build 是为了确保开发环境总是使用最新的本地代码构建\n    ```\n\n*   **运行生产环境：**\n    ```bash\n    # 默认 docker-compose.yml 是第一个加载的文件\n    # 然后 docker-compose.prod.yml 会覆盖其中的配置\n    docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d\n    # 生产环境通常使用 image，所以这里不需要 --build\n    ```\n\n*   **停止和清理特定环境：**\n    ```bash\n    # 停止开发环境\n    docker-compose -f docker-compose.yml -f docker-compose.dev.yml down\n\n    # 停止生产环境 (注意 -v 慎用，它会删除数据卷)\n    docker-compose -f docker-compose.yml -f docker-compose.prod.yml down\n    ```\n\n**文件合并规则总结 (V3.x)**：\n*   **映射 (Map)**：例如 `environment`, `labels`, `healthcheck` 等，会**完全覆盖**基础文件中的对应映射。\n*   **列表 (List)**：例如 `ports`, `volumes`, `networks` (服务内部的)，会**合并**基础文件和覆盖文件中的列表项。同名卷或端口映射可能会有复杂的行为，通常建议在覆盖文件里写全希望的最终列表项。\n*   **顶层 `volumes` 和 `networks`**：会合并，同名项被覆盖。\n\n使用 `-f` 参数组合文件是管理多环境配置最灵活和常用的方法。\n\n---\n\n## ♻️ `extends` 关键字：让配置更 DRY (Don't Repeat Yourself)\n\n除了 `-f` 组合文件，Docker Compose 还提供了 `extends` 关键字，用于在不同服务之间**共享通用的配置片段**，或者在一个文件里引用另一个文件中的服务定义。这是一种**复用配置**的机制。\n\n虽然 `extends` 也可以间接用于多环境（通过继承不同基础配置），但它更主要的用途是抽象和复用。\n\n```yaml\n# 文件名: common.yml # 存放通用配置片段\nversion: '3.8'\n\nservices:\n  _base_app: &base_app # 使用 YAML 锚点 & 定义一个可复用的配置块\n    restart: unless-stopped\n    networks:\n      - app_network\n    healthcheck: # 通用健康检查配置\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n\n  _base_db: &base_db\n    image: mysql:5.7\n    restart: unless-stopped\n    networks:\n      - app_network\n    healthcheck: # 通用数据库健康检查\n      test: [\"CMD\", \"mysqladmin\", \"ping -h localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nnetworks:\n  app_network: # 通用网络定义\n```\n\n```yaml\n# 文件名: docker-compose.yml # 主文件，使用 extends 或引用通用片段\nversion: '3.8'\n\n# 直接引用 common.yml 中的网络定义\nnetworks:\n  app_network:\n\nservices:\n  # 使用 extends 继承 common.yml 中的 _base_app 配置\n  app:\n    # extends:\n    #   file: common.yml # 指定从哪个文件继承\n    #   service: _base_app # 指定继承哪个服务定义\n\n    # 或者使用 YAML 锚点引用 (更简洁，但只能在同一个或被引用的文件中使用)\n    <<: *base_app # 引用 common.yml 中定义的 _base_app 锚点\n\n    # 然后在这里添加或覆盖特定配置\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n      - db_data:/var/lib/mysql\n    environment:\n      - NODE_ENV=development\n      - DB_HOST=db\n\n    depends_on:\n      db:\n        condition: service_healthy\n\n  db:\n    # 使用 extends 继承 common.yml 中的 _base_db 配置\n    # extends:\n    #   file: common.yml\n    #   service: _base_db\n\n    # 或者使用 YAML 锚点引用\n    <<: *base_db\n\n    # 然后在这里添加或覆盖特定配置\n    volumes:\n      - db_data:/var/lib/mysql\n    environment:\n      - MYSQL_ROOT_PASSWORD=mysecretpassword\n      - MYSQL_DATABASE=mydatabase\n\nvolumes:\n  db_data: # 在主文件或通用文件里声明卷\n```\n*注意：上面的例子结合使用了 `extends` 和 YAML 锚点。`extends` 用于引用**另一个文件**中的完整服务定义，YAML 锚点则用于在一个文件内部或被引用的文件中定义和复用配置块。在 V3+ 版本中，YAML 锚点配合 `-f` 多文件组合是实现 DRY 和多环境管理的一种常见且灵活的方式。*\n\n*   **`extends` 适合场景**：\n    *   多个服务有大量重复配置（如 logging, restart, common labels）。\n    *   在大型项目中，将一些基础服务定义（如一个标准的 Web 服务模板）放在单独的文件中供其他项目复用。\n\n*   **`extends` vs `-f` 组合**：\n    *   `-f` 组合：更侧重于**合并和覆盖**配置，是实现**不同环境**配置切换的标准方式。\n    *   `extends`：更侧重于**继承和复用**配置片段或服务定义，是实现 DRY 的一种方式。它们可以结合使用。\n\n---\n\n## ✅ 多环境管理的最佳实践\n\n1.  **一个基础 `docker-compose.yml`**：包含项目共有的、不随环境变化的配置。\n2.  **多个环境覆盖文件** (`docker-compose.dev.yml`, `docker-compose.prod.yml` 等)：只包含特定环境的**差异**和对基础配置的**覆盖**。\n3.  **使用 `-f` 参数**：通过 `docker-compose -f docker-compose.yml -f docker-compose.[env].yml up -d` 命令来启动特定环境。\n4.  **`.env` 文件用于加载变量**：每个环境可以有自己的 `.env.[env]` 文件，并通过 `env_file` 加载。对于简单变量，项目根目录的 `.env` 文件也可以作为默认值加载。\n5.  **敏感信息处理**：开发环境可以使用 `.env` 并加入 `.gitignore`。生产环境**不推荐**将敏感信息放入 `.env` 或直接写在 yml 里，应考虑使用 Docker Secrets 或其他秘密管理工具。\n6.  **配置合并理解**：牢记 Docker Compose 的配置合并规则（映射覆盖，列表合并），编写覆盖文件时要小心。\n\n通过将通用配置放在基础文件，环境特定的差异放在覆盖文件，并结合环境变量的使用，你的 Docker Compose 配置将变得非常灵活、易于管理，并且能够轻松适应不同的部署环境！\n\n---\n\n**本章小结**\n\n我们学习了 Docker Compose 中环境变量的高级用法和多环境配置管理：\n*   复习了 `environment` 和 `env_file` 的作用。\n*   深入了解了 `.env` 文件自动加载和变量覆盖的机制。\n*   掌握了使用 `-f` 参数组合多个 `docker-compose.yml` 文件来实现不同环境配置切换的核心方法。\n*   了解了 `extends` 关键字用于配置复用的功能。\n*   总结了多环境管理的最佳实践。\n\n现在，你不仅能定义服务，还能根据不同的需求轻松调整它们的配置了！接下来，我们将探索 Docker Compose 中用于限制容器资源使用、命名容器以及配置日志等方面的高级字段。这将在下一章“深入服务配置：资源限制与其他字段”中讲解！敬请期待！","source":"_posts/Docker/Docker Compose 灵活配置篇（五）：环境变量与多环境管理.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 灵活配置篇（五）：环境变量与多环境管理\"\ndate: '2025-06-07 13:00'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 58030\n---\n\n# 🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！\n\n哈喽！我们又见面啦！通过前几章的学习，你已经掌握了如何描述单个服务、定义项目结构以及操作 Docker Compose。你甚至能搞定服务之间的复杂依赖和健康检查了，非常棒！\n\n现在，让我们面对一个更实际的问题：你的应用在**开发环境**可能连接的是本地的数据库，使用调试模式；在**生产环境**可能连接的是云端的数据库，需要更高的性能配置，使用生产模式。这些“随环境变化”的配置信息怎么管理呢？\n\n硬生生地在 `docker-compose.yml` 文件里改来改去显然不是个好主意，容易出错，也不方便。幸运的是，Docker Compose 提供了非常灵活的方式来处理这些问题，主要就是通过**环境变量**和**多文件组合**来实现！\n\n今天，我们就来深入学习如何让你的 Docker Compose 配置“活”起来，根据不同的环境加载不同的设置。\n\n---\n\n## 🌳 环境变量：配置信息的“活水”\n\n在第一章我们就提到了 `environment` 和 `env_file` 字段，它们是把配置信息作为环境变量传递给容器。为什么环境变量这么重要呢？\n\n1.  **灵活**：你可以在不修改镜像或 Docker Compose 文件本身的情况下，改变容器的行为。\n2.  **安全**：相较于直接在代码里硬编码，环境变量更适合传递一些非敏感或敏感程度较低的配置。\n3.  **标准**：这是云原生应用和微服务常用的配置方式，符合“十二要素应用”（The Twelve-Factor App）的原则。\n\n### 复习：两种传递环境变量的方式\n\n*   **`environment`**：直接在服务配置里列出变量名和值。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        environment:\n          - NODE_ENV=development\n          - PORT=3000\n    ```\n    *   **适合场景**：变量少，或者变量值比较固定且不敏感。\n\n*   **`env_file`**：从一个或多个文件中读取变量。\n    ```yaml\n    services:\n      app:\n        image: my-app\n        env_file:\n          - .env # 加载当前目录下的 .env 文件\n          - ./config/app.env # 也可以加载其他文件\n    ```\n    *   **适合场景**：变量多，或者想把配置和 `docker-compose.yml` 文件分开，让文件更整洁。\n\n### `.env` 文件：Docker Compose 的“默认配置包”\n\n当你在项目根目录下创建一个名为 `.env` 的文件时，**Docker Compose 在运行任何命令（如 `up`, `down`, `build` 等）时，会默认自动加载这个文件中的环境变量**。\n\n```env\n# 文件名：.env\n# 格式：变量名=值 （注意等号两边通常没有空格，值如果有空格或特殊字符需要用引号包起来）\n\nDB_HOST=localhost\nDB_PORT=3306\nDB_USER=root\nDB_PASSWORD=mysecretpassword\n\nAPI_KEY=abcdef123456\nDEBUG=true\n```\n\n然后在 `docker-compose.yml` 文件中，你可以使用 `${变量名}` 的语法来引用这些变量：\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    image: my-app\n    environment:\n      # 直接引用 .env 文件里或者宿主机环境中的变量\n      - DB_HOST=${DB_HOST}\n      - DB_PORT=${DB_PORT}\n      - API_KEY=${API_KEY}\n      - DEBUG=${DEBUG}\n      # 你也可以同时设置一些没有在 .env 文件里的变量\n      - APP_MODE=web\n\n    # 或者使用 env_file 加载 .env 文件，效果一样，但这种方式更显式\n    # env_file:\n    #   - .env\n\n  db:\n    image: mysql:5.7\n    environment:\n      # 同样引用变量\n      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}\n      - MYSQL_DATABASE=mydatabase\n    volumes:\n      - db_data:/var/lib/mysql\n\nvolumes:\n  db_data:\n```\n\n当你运行 `docker-compose up` 时，Docker Compose 会：\n1.  读取当前目录下的 `.env` 文件，将里面的 `DB_HOST`, `DB_PORT` 等变量加载到内存中。\n2.  解析 `docker-compose.yml` 文件。\n3.  遇到 `${DB_HOST}` 等占位符时，用从 `.env` 或宿主机环境中加载到的实际值替换它们。\n4.  用替换后的完整配置来创建和启动容器，并将这些变量传递给容器。\n\n*   **变量加载顺序 (优先级从高到低)**：\n    1.  在命令行中传递的环境变量（例如 `DB_HOST=192.168.1.1 docker-compose up`）。\n    2.  宿主机/Shell 环境中已经存在的环境变量。\n    3.  `.env` 文件中的变量。\n    4.  `docker-compose.yml` 中 `environment` 字段直接设置的值。\n    *理解这个顺序很重要，你可以通过设置宿主机环境变量来覆盖 `.env` 文件中的值！*\n\n*   **`.env` 文件适合场景**：\n    *   存储开发环境的默认配置。\n    *   存储一些非敏感的应用参数。\n    *   方便团队成员共享基础配置。\n\n*   **`.env` 文件**不适合**场景**：\n    *   存储真正的**生产环境敏感密钥**（如生产数据库密码、第三方服务 API Key）。虽然 `.env` 文件本身可能不提交到 Git，但这种方式不够安全和健壮。生产环境推荐使用 Docker Secrets 或 Kubernetes Secrets 等更专业的密钥管理方案。\n\n---\n\n## 🔄 多环境管理：用 `-f` 组合不同的配置文件！\n\n`.env` 文件方便了环境变量的管理，但如果不同环境（dev/prod）的配置差异很大，比如：\n\n*   开发环境：使用本地构建的镜像 (`build`)，端口映射到 `3000`，挂载本地代码目录 (`volumes: .:/app`)，连接 Docker 网络内的数据库 (`DB_HOST=db`)。\n*   生产环境：使用预构建的镜像 (`image: my-app:latest`)，端口映射到 `80`，不挂载本地代码，连接外部的云数据库 (`DB_HOST=prod.database.com`)。\n\n这些差异涉及到 `build`, `image`, `ports`, `volumes`, `environment` 等多个字段，只靠 `.env` 文件就很难管理了。\n\n这时，最佳实践是使用 **多个 `docker-compose.yml` 文件**，并通过 `docker-compose` 命令的 `-f` 参数来组合和覆盖配置！\n\n基本思想是：\n1.  创建一个 **基础文件** (`docker-compose.yml`)：包含所有环境共用的配置（比如服务名称、网络定义、卷定义、一些通用的环境变量、重启策略等）。\n2.  创建 **环境特定覆盖文件** (`docker-compose.dev.yml`, `docker-compose.prod.yml` 等)：只包含特定环境的配置**差异**或**覆盖项**。\n\n当使用 `docker-compose -f docker-compose.yml -f docker-compose.dev.yml up` 时，Docker Compose 会**合并**这两个文件。后面文件的配置会覆盖前面文件的相同部分。\n\n### 示例：开发环境 vs 生产环境\n\n假设你有以下需求：\n\n*   **基础配置 (`docker-compose.yml`)**：\n    *   定义 `app` 和 `db` 服务。\n    *   定义一个共同的网络 `app_network`。\n    *   `db` 服务使用 `mysql:5.7` 镜像，持久化到命名卷 `db_data`。\n    *   `app` 服务连接到 `app_network`，依赖 `db`。\n    *   通用环境变量如 `API_KEY`，从 `.env` 加载。\n    *   `restart` 策略为 `unless-stopped`。\n\n*   **开发环境覆盖 (`docker-compose.dev.yml`)**：\n    *   `app` 服务使用 `build: .` 构建本地镜像。\n    *   `app` 服务端口映射 `3000:3000`。\n    *   `app` 服务挂载本地代码卷 `. : /app`。\n    *   `app` 服务设置 `NODE_ENV=development`。\n    *   `db` 服务使用默认端口和内部网络名连接 (`DB_HOST=db`)。\n    *   使用 `.env.dev` 文件加载开发环境特有变量。\n\n*   **生产环境覆盖 (`docker-compose.prod.yml`)**：\n    *   `app` 服务使用 `image: myapp:latest` 镜像。\n    *   `app` 服务端口映射 `80:3000`。\n    *   `app` 服务不挂载本地代码卷。\n    *   `app` 服务设置 `NODE_ENV=production`。\n    *   `db` 服务连接外部数据库 (`DB_HOST=prod.database.com`)。\n    *   使用 `.env.prod` 文件加载生产环境特有变量。\n\n**第一步：创建 `.env.dev` 和 `.env.prod` 文件**\n\n```env\n# 文件名：.env.dev\n# 开发环境特有的变量\nDB_HOST=db # 在 docker 网络里，数据库服务名叫 db\nDB_PORT=3306\nDEBUG=true\n```\n\n```env\n# 文件名：.env.prod\n# 生产环境特有的变量\nDB_HOST=prod.database.com # 外部数据库地址\nDB_PORT=3306\nDEBUG=false\n```\n*(注意：`.env` 文件如果存在，也会被默认加载，然后 `.env.dev` 或 `.env.prod` 如果被 env_file 指定，其中的变量会覆盖 `.env` 中同名的变量。)*\n\n**第二步：创建基础文件 (`docker-compose.yml`)**\n\n```yaml\n# 文件名: docker-compose.yml\nversion: '3.8'\n\nservices:\n  app:\n    # build 或 image 在覆盖文件里指定\n    # ports 在覆盖文件里指定\n    # volumes (代码挂载) 在覆盖文件里指定\n    # environment (NODE_ENV, DB_HOST等) 在覆盖文件里指定\n    # env_file 在覆盖文件里指定\n\n    restart: unless-stopped # 重启策略是通用的\n\n    depends_on:\n      # app 依赖 db 处于健康状态 (需要 db 服务配置 healthcheck)\n      db:\n        condition: service_healthy\n\n    networks:\n      - app_network # app 和 db 都在同一个网络里通信\n\n    # 通用健康检查 (如果健康检查方式不同，可以在覆盖文件里重写)\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  db:\n    image: mysql:5.7\n    # environment (密码, DB_NAME) 可以在 .env 或者覆盖文件里指定\n    # volumes (数据卷) 在这里指定结构，或者在覆盖文件里指定不同类型\n    volumes:\n      - db_data:/var/lib/mysql # 默认使用命名卷\n\n    restart: unless-stopped # 重启策略是通用的\n\n    networks:\n      - app_network # app 和 db 在同一个网络里通信\n\n    # 数据库健康检查 (通用)\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n\n# 顶层声明命名卷 (通用)\nvolumes:\n  db_data:\n\n# 顶层声明网络 (通用)\nnetworks:\n  app_network:\n```\n\n**第三步：创建开发环境覆盖文件 (`docker-compose.dev.yml`)**\n\n```yaml\n# 文件名: docker-compose.dev.yml\n# 这个文件会覆盖 docker-compose.yml 中的一些设置\n\nversion: '3.8' # 版本号需要和基础文件一致\n\nservices:\n  app:\n    # 覆盖或添加 app 服务的配置\n    build:\n      context: . # 开发环境从本地构建\n      dockerfile: Dockerfile.dev # 可能使用不同的 Dockerfile\n\n    ports:\n      - \"3000:3000\" # 开发环境映射到 3000\n\n    volumes:\n      # 覆盖 volumes，添加本地代码挂载（注意：列表是合并，如果基础文件有命名卷，这里需要重写整个 volumes 列表）\n      # Docker Compose V3+ 合并规则是：列表类型的字段会**合并**，映射类型的字段会**覆盖**。\n      # 为了清晰，通常在覆盖文件里写全需要的所有 volumes。\n      - .:/app # 添加本地代码挂载\n      - db_data:/var/lib/mysql # 也要保留数据库的数据卷挂载\n\n    environment:\n      # 覆盖或添加环境变量\n      NODE_ENV: development\n\n    env_file:\n      - .env.dev # 加载开发环境特有的变量文件\n\n  db:\n    # 覆盖或添加 db 服务的配置\n    # 在开发环境，db 的健康检查可能更宽松\n    healthcheck:\n      interval: 5s # 检查频率高一点\n      timeout: 3s\n      retries: 3\n      start_period: 10s\n\n    # db 在 dev 环境可能也需要一些特定的环境变量，比如创建测试数据库\n    environment:\n      MYSQL_DATABASE: myapp_dev # 覆盖或添加环境变量\n```\n*注意：`volumes` 字段是列表，Docker Compose 合并时会把所有列表项加在一起。如果你想**替换**某个卷而不是**添加**，或者想在覆盖文件中明确卷的类型（如本地路径 vs 命名卷），你需要写完整的 `volumes` 配置，它会覆盖基础文件中的同名字段。上面的例子中，`volumes` 列表被完整替换了，包含了基础文件中的命名卷和开发环境特有的绑定挂载。`environment` 是映射，同名变量会覆盖。*\n\n**第四步：创建生产环境覆盖文件 (`docker-compose.prod.yml`)**\n\n```yaml\n# 文件名: docker-compose.prod.yml\n# 这个文件会覆盖 docker-compose.yml 中的一些设置\n\nversion: '3.8' # 版本号需要和基础文件一致\n\nservices:\n  app:\n    # 覆盖或添加 app 服务的配置\n    image: myapp:latest # 生产环境使用预构建的镜像\n    # build: # 生产环境不需要 build，所以这里不写 build 字段，或者设置为 null/[]\n\n    ports:\n      - \"80:3000\" # 生产环境映射到 80\n\n    volumes:\n      # 生产环境不挂载本地代码，只保留数据卷挂载\n      - db_data:/var/lib/mysql # 保留数据库的数据卷挂载\n\n    environment:\n      # 覆盖或添加环境变量\n      NODE_ENV: production\n\n    env_file:\n      - .env.prod # 加载生产环境特有的变量文件\n\n  db:\n    # 生产环境 db 可能不需要特定的覆盖，使用基础文件和 .env.prod 中的配置即可\n    # 如果需要，可以在这里添加覆盖配置\n    environment:\n      MYSQL_DATABASE: myapp_prod # 生产环境数据库名不同\n```\n*同样注意 `volumes` 的合并规则，这里只保留了 `db_data` 的挂载。*\n\n### 运行不同环境的应用\n\n现在，你可以使用 `-f` 参数来指定要加载哪些配置文件。\n\n*   **运行开发环境：**\n    ```bash\n    # 默认 docker-compose.yml 是第一个加载的文件\n    # 然后 docker-compose.dev.yml 会覆盖其中的配置\n    # -d 参数表示以后台模式运行\n    docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build\n    # --build 是为了确保开发环境总是使用最新的本地代码构建\n    ```\n\n*   **运行生产环境：**\n    ```bash\n    # 默认 docker-compose.yml 是第一个加载的文件\n    # 然后 docker-compose.prod.yml 会覆盖其中的配置\n    docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d\n    # 生产环境通常使用 image，所以这里不需要 --build\n    ```\n\n*   **停止和清理特定环境：**\n    ```bash\n    # 停止开发环境\n    docker-compose -f docker-compose.yml -f docker-compose.dev.yml down\n\n    # 停止生产环境 (注意 -v 慎用，它会删除数据卷)\n    docker-compose -f docker-compose.yml -f docker-compose.prod.yml down\n    ```\n\n**文件合并规则总结 (V3.x)**：\n*   **映射 (Map)**：例如 `environment`, `labels`, `healthcheck` 等，会**完全覆盖**基础文件中的对应映射。\n*   **列表 (List)**：例如 `ports`, `volumes`, `networks` (服务内部的)，会**合并**基础文件和覆盖文件中的列表项。同名卷或端口映射可能会有复杂的行为，通常建议在覆盖文件里写全希望的最终列表项。\n*   **顶层 `volumes` 和 `networks`**：会合并，同名项被覆盖。\n\n使用 `-f` 参数组合文件是管理多环境配置最灵活和常用的方法。\n\n---\n\n## ♻️ `extends` 关键字：让配置更 DRY (Don't Repeat Yourself)\n\n除了 `-f` 组合文件，Docker Compose 还提供了 `extends` 关键字，用于在不同服务之间**共享通用的配置片段**，或者在一个文件里引用另一个文件中的服务定义。这是一种**复用配置**的机制。\n\n虽然 `extends` 也可以间接用于多环境（通过继承不同基础配置），但它更主要的用途是抽象和复用。\n\n```yaml\n# 文件名: common.yml # 存放通用配置片段\nversion: '3.8'\n\nservices:\n  _base_app: &base_app # 使用 YAML 锚点 & 定义一个可复用的配置块\n    restart: unless-stopped\n    networks:\n      - app_network\n    healthcheck: # 通用健康检查配置\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 60s\n\n  _base_db: &base_db\n    image: mysql:5.7\n    restart: unless-stopped\n    networks:\n      - app_network\n    healthcheck: # 通用数据库健康检查\n      test: [\"CMD\", \"mysqladmin\", \"ping -h localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\nnetworks:\n  app_network: # 通用网络定义\n```\n\n```yaml\n# 文件名: docker-compose.yml # 主文件，使用 extends 或引用通用片段\nversion: '3.8'\n\n# 直接引用 common.yml 中的网络定义\nnetworks:\n  app_network:\n\nservices:\n  # 使用 extends 继承 common.yml 中的 _base_app 配置\n  app:\n    # extends:\n    #   file: common.yml # 指定从哪个文件继承\n    #   service: _base_app # 指定继承哪个服务定义\n\n    # 或者使用 YAML 锚点引用 (更简洁，但只能在同一个或被引用的文件中使用)\n    <<: *base_app # 引用 common.yml 中定义的 _base_app 锚点\n\n    # 然后在这里添加或覆盖特定配置\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n      - db_data:/var/lib/mysql\n    environment:\n      - NODE_ENV=development\n      - DB_HOST=db\n\n    depends_on:\n      db:\n        condition: service_healthy\n\n  db:\n    # 使用 extends 继承 common.yml 中的 _base_db 配置\n    # extends:\n    #   file: common.yml\n    #   service: _base_db\n\n    # 或者使用 YAML 锚点引用\n    <<: *base_db\n\n    # 然后在这里添加或覆盖特定配置\n    volumes:\n      - db_data:/var/lib/mysql\n    environment:\n      - MYSQL_ROOT_PASSWORD=mysecretpassword\n      - MYSQL_DATABASE=mydatabase\n\nvolumes:\n  db_data: # 在主文件或通用文件里声明卷\n```\n*注意：上面的例子结合使用了 `extends` 和 YAML 锚点。`extends` 用于引用**另一个文件**中的完整服务定义，YAML 锚点则用于在一个文件内部或被引用的文件中定义和复用配置块。在 V3+ 版本中，YAML 锚点配合 `-f` 多文件组合是实现 DRY 和多环境管理的一种常见且灵活的方式。*\n\n*   **`extends` 适合场景**：\n    *   多个服务有大量重复配置（如 logging, restart, common labels）。\n    *   在大型项目中，将一些基础服务定义（如一个标准的 Web 服务模板）放在单独的文件中供其他项目复用。\n\n*   **`extends` vs `-f` 组合**：\n    *   `-f` 组合：更侧重于**合并和覆盖**配置，是实现**不同环境**配置切换的标准方式。\n    *   `extends`：更侧重于**继承和复用**配置片段或服务定义，是实现 DRY 的一种方式。它们可以结合使用。\n\n---\n\n## ✅ 多环境管理的最佳实践\n\n1.  **一个基础 `docker-compose.yml`**：包含项目共有的、不随环境变化的配置。\n2.  **多个环境覆盖文件** (`docker-compose.dev.yml`, `docker-compose.prod.yml` 等)：只包含特定环境的**差异**和对基础配置的**覆盖**。\n3.  **使用 `-f` 参数**：通过 `docker-compose -f docker-compose.yml -f docker-compose.[env].yml up -d` 命令来启动特定环境。\n4.  **`.env` 文件用于加载变量**：每个环境可以有自己的 `.env.[env]` 文件，并通过 `env_file` 加载。对于简单变量，项目根目录的 `.env` 文件也可以作为默认值加载。\n5.  **敏感信息处理**：开发环境可以使用 `.env` 并加入 `.gitignore`。生产环境**不推荐**将敏感信息放入 `.env` 或直接写在 yml 里，应考虑使用 Docker Secrets 或其他秘密管理工具。\n6.  **配置合并理解**：牢记 Docker Compose 的配置合并规则（映射覆盖，列表合并），编写覆盖文件时要小心。\n\n通过将通用配置放在基础文件，环境特定的差异放在覆盖文件，并结合环境变量的使用，你的 Docker Compose 配置将变得非常灵活、易于管理，并且能够轻松适应不同的部署环境！\n\n---\n\n**本章小结**\n\n我们学习了 Docker Compose 中环境变量的高级用法和多环境配置管理：\n*   复习了 `environment` 和 `env_file` 的作用。\n*   深入了解了 `.env` 文件自动加载和变量覆盖的机制。\n*   掌握了使用 `-f` 参数组合多个 `docker-compose.yml` 文件来实现不同环境配置切换的核心方法。\n*   了解了 `extends` 关键字用于配置复用的功能。\n*   总结了多环境管理的最佳实践。\n\n现在，你不仅能定义服务，还能根据不同的需求轻松调整它们的配置了！接下来，我们将探索 Docker Compose 中用于限制容器资源使用、命名容器以及配置日志等方面的高级字段。这将在下一章“深入服务配置：资源限制与其他字段”中讲解！敬请期待！","slug":"Docker/Docker Compose 灵活配置篇（五）：环境变量与多环境管理","published":1,"updated":"2025-06-07T15:58:53.664Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzwwc001opkrcdrmz14li","content":"<h1 id=\"🐳-配置随环境而变：环境变量与多环境-Docker-Compose-实战！\"><a href=\"#🐳-配置随环境而变：环境变量与多环境-Docker-Compose-实战！\" class=\"headerlink\" title=\"🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！\"></a>🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！</h1><p>哈喽！我们又见面啦！通过前几章的学习，你已经掌握了如何描述单个服务、定义项目结构以及操作 Docker Compose。你甚至能搞定服务之间的复杂依赖和健康检查了，非常棒！</p>\n<p>现在，让我们面对一个更实际的问题：你的应用在<strong>开发环境</strong>可能连接的是本地的数据库，使用调试模式；在<strong>生产环境</strong>可能连接的是云端的数据库，需要更高的性能配置，使用生产模式。这些“随环境变化”的配置信息怎么管理呢？</p>\n<p>硬生生地在 <code>docker-compose.yml</code> 文件里改来改去显然不是个好主意，容易出错，也不方便。幸运的是，Docker Compose 提供了非常灵活的方式来处理这些问题，主要就是通过<strong>环境变量</strong>和<strong>多文件组合</strong>来实现！</p>\n<p>今天，我们就来深入学习如何让你的 Docker Compose 配置“活”起来，根据不同的环境加载不同的设置。</p>\n<hr>\n<h2 id=\"🌳-环境变量：配置信息的“活水”\"><a href=\"#🌳-环境变量：配置信息的“活水”\" class=\"headerlink\" title=\"🌳 环境变量：配置信息的“活水”\"></a>🌳 环境变量：配置信息的“活水”</h2><p>在第一章我们就提到了 <code>environment</code> 和 <code>env_file</code> 字段，它们是把配置信息作为环境变量传递给容器。为什么环境变量这么重要呢？</p>\n<ol>\n<li><strong>灵活</strong>：你可以在不修改镜像或 Docker Compose 文件本身的情况下，改变容器的行为。</li>\n<li><strong>安全</strong>：相较于直接在代码里硬编码，环境变量更适合传递一些非敏感或敏感程度较低的配置。</li>\n<li><strong>标准</strong>：这是云原生应用和微服务常用的配置方式，符合“十二要素应用”（The Twelve-Factor App）的原则。</li>\n</ol>\n<h3 id=\"复习：两种传递环境变量的方式\"><a href=\"#复习：两种传递环境变量的方式\" class=\"headerlink\" title=\"复习：两种传递环境变量的方式\"></a>复习：两种传递环境变量的方式</h3><ul>\n<li><p><strong><code>environment</code></strong>：直接在服务配置里列出变量名和值。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">PORT=3000</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>适合场景</strong>：变量少，或者变量值比较固定且不敏感。</li>\n</ul>\n</li>\n<li><p><strong><code>env_file</code></strong>：从一个或多个文件中读取变量。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env</span> <span class=\"comment\"># 加载当前目录下的 .env 文件</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./config/app.env</span> <span class=\"comment\"># 也可以加载其他文件</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>适合场景</strong>：变量多，或者想把配置和 <code>docker-compose.yml</code> 文件分开，让文件更整洁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"env-文件：Docker-Compose-的“默认配置包”\"><a href=\"#env-文件：Docker-Compose-的“默认配置包”\" class=\"headerlink\" title=\".env 文件：Docker Compose 的“默认配置包”\"></a><code>.env</code> 文件：Docker Compose 的“默认配置包”</h3><p>当你在项目根目录下创建一个名为 <code>.env</code> 的文件时，<strong>Docker Compose 在运行任何命令（如 <code>up</code>, <code>down</code>, <code>build</code> 等）时，会默认自动加载这个文件中的环境变量</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env</span><br><span class=\"line\"># 格式：变量名=值 （注意等号两边通常没有空格，值如果有空格或特殊字符需要用引号包起来）</span><br><span class=\"line\"></span><br><span class=\"line\">DB_HOST=localhost</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DB_USER=root</span><br><span class=\"line\">DB_PASSWORD=mysecretpassword</span><br><span class=\"line\"></span><br><span class=\"line\">API_KEY=abcdef123456</span><br><span class=\"line\">DEBUG=true</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>docker-compose.yml</code> 文件中，你可以使用 <code>$&#123;变量名&#125;</code> 的语法来引用这些变量：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 直接引用 .env 文件里或者宿主机环境中的变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=$&#123;DB_HOST&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PORT=$&#123;DB_PORT&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">API_KEY=$&#123;API_KEY&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DEBUG=$&#123;DEBUG&#125;</span></span><br><span class=\"line\">      <span class=\"comment\"># 你也可以同时设置一些没有在 .env 文件里的变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">APP_MODE=web</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 env_file 加载 .env 文件，效果一样，但这种方式更显式</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file:</span></span><br><span class=\"line\">    <span class=\"comment\">#   - .env</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 同样引用变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_PASSWORD&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br></pre></td></tr></table></figure>\n\n<p>当你运行 <code>docker-compose up</code> 时，Docker Compose 会：</p>\n<ol>\n<li>读取当前目录下的 <code>.env</code> 文件，将里面的 <code>DB_HOST</code>, <code>DB_PORT</code> 等变量加载到内存中。</li>\n<li>解析 <code>docker-compose.yml</code> 文件。</li>\n<li>遇到 <code>$&#123;DB_HOST&#125;</code> 等占位符时，用从 <code>.env</code> 或宿主机环境中加载到的实际值替换它们。</li>\n<li>用替换后的完整配置来创建和启动容器，并将这些变量传递给容器。</li>\n</ol>\n<ul>\n<li><p><strong>变量加载顺序 (优先级从高到低)</strong>：</p>\n<ol>\n<li>在命令行中传递的环境变量（例如 <code>DB_HOST=192.168.1.1 docker-compose up</code>）。</li>\n<li>宿主机&#x2F;Shell 环境中已经存在的环境变量。</li>\n<li><code>.env</code> 文件中的变量。</li>\n<li><code>docker-compose.yml</code> 中 <code>environment</code> 字段直接设置的值。<br><em>理解这个顺序很重要，你可以通过设置宿主机环境变量来覆盖 <code>.env</code> 文件中的值！</em></li>\n</ol>\n</li>\n<li><p><strong><code>.env</code> 文件适合场景</strong>：</p>\n<ul>\n<li>存储开发环境的默认配置。</li>\n<li>存储一些非敏感的应用参数。</li>\n<li>方便团队成员共享基础配置。</li>\n</ul>\n</li>\n<li><p><strong><code>.env</code> 文件</strong>不适合<strong>场景</strong>：</p>\n<ul>\n<li>存储真正的<strong>生产环境敏感密钥</strong>（如生产数据库密码、第三方服务 API Key）。虽然 <code>.env</code> 文件本身可能不提交到 Git，但这种方式不够安全和健壮。生产环境推荐使用 Docker Secrets 或 Kubernetes Secrets 等更专业的密钥管理方案。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🔄-多环境管理：用-f-组合不同的配置文件！\"><a href=\"#🔄-多环境管理：用-f-组合不同的配置文件！\" class=\"headerlink\" title=\"🔄 多环境管理：用 -f 组合不同的配置文件！\"></a>🔄 多环境管理：用 <code>-f</code> 组合不同的配置文件！</h2><p><code>.env</code> 文件方便了环境变量的管理，但如果不同环境（dev&#x2F;prod）的配置差异很大，比如：</p>\n<ul>\n<li>开发环境：使用本地构建的镜像 (<code>build</code>)，端口映射到 <code>3000</code>，挂载本地代码目录 (<code>volumes: .:/app</code>)，连接 Docker 网络内的数据库 (<code>DB_HOST=db</code>)。</li>\n<li>生产环境：使用预构建的镜像 (<code>image: my-app:latest</code>)，端口映射到 <code>80</code>，不挂载本地代码，连接外部的云数据库 (<code>DB_HOST=prod.database.com</code>)。</li>\n</ul>\n<p>这些差异涉及到 <code>build</code>, <code>image</code>, <code>ports</code>, <code>volumes</code>, <code>environment</code> 等多个字段，只靠 <code>.env</code> 文件就很难管理了。</p>\n<p>这时，最佳实践是使用 <strong>多个 <code>docker-compose.yml</code> 文件</strong>，并通过 <code>docker-compose</code> 命令的 <code>-f</code> 参数来组合和覆盖配置！</p>\n<p>基本思想是：</p>\n<ol>\n<li>创建一个 <strong>基础文件</strong> (<code>docker-compose.yml</code>)：包含所有环境共用的配置（比如服务名称、网络定义、卷定义、一些通用的环境变量、重启策略等）。</li>\n<li>创建 <strong>环境特定覆盖文件</strong> (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code> 等)：只包含特定环境的配置<strong>差异</strong>或<strong>覆盖项</strong>。</li>\n</ol>\n<p>当使用 <code>docker-compose -f docker-compose.yml -f docker-compose.dev.yml up</code> 时，Docker Compose 会<strong>合并</strong>这两个文件。后面文件的配置会覆盖前面文件的相同部分。</p>\n<h3 id=\"示例：开发环境-vs-生产环境\"><a href=\"#示例：开发环境-vs-生产环境\" class=\"headerlink\" title=\"示例：开发环境 vs 生产环境\"></a>示例：开发环境 vs 生产环境</h3><p>假设你有以下需求：</p>\n<ul>\n<li><p><strong>基础配置 (<code>docker-compose.yml</code>)</strong>：</p>\n<ul>\n<li>定义 <code>app</code> 和 <code>db</code> 服务。</li>\n<li>定义一个共同的网络 <code>app_network</code>。</li>\n<li><code>db</code> 服务使用 <code>mysql:5.7</code> 镜像，持久化到命名卷 <code>db_data</code>。</li>\n<li><code>app</code> 服务连接到 <code>app_network</code>，依赖 <code>db</code>。</li>\n<li>通用环境变量如 <code>API_KEY</code>，从 <code>.env</code> 加载。</li>\n<li><code>restart</code> 策略为 <code>unless-stopped</code>。</li>\n</ul>\n</li>\n<li><p><strong>开发环境覆盖 (<code>docker-compose.dev.yml</code>)</strong>：</p>\n<ul>\n<li><code>app</code> 服务使用 <code>build: .</code> 构建本地镜像。</li>\n<li><code>app</code> 服务端口映射 <code>3000:3000</code>。</li>\n<li><code>app</code> 服务挂载本地代码卷 <code>. : /app</code>。</li>\n<li><code>app</code> 服务设置 <code>NODE_ENV=development</code>。</li>\n<li><code>db</code> 服务使用默认端口和内部网络名连接 (<code>DB_HOST=db</code>)。</li>\n<li>使用 <code>.env.dev</code> 文件加载开发环境特有变量。</li>\n</ul>\n</li>\n<li><p><strong>生产环境覆盖 (<code>docker-compose.prod.yml</code>)</strong>：</p>\n<ul>\n<li><code>app</code> 服务使用 <code>image: myapp:latest</code> 镜像。</li>\n<li><code>app</code> 服务端口映射 <code>80:3000</code>。</li>\n<li><code>app</code> 服务不挂载本地代码卷。</li>\n<li><code>app</code> 服务设置 <code>NODE_ENV=production</code>。</li>\n<li><code>db</code> 服务连接外部数据库 (<code>DB_HOST=prod.database.com</code>)。</li>\n<li>使用 <code>.env.prod</code> 文件加载生产环境特有变量。</li>\n</ul>\n</li>\n</ul>\n<p><strong>第一步：创建 <code>.env.dev</code> 和 <code>.env.prod</code> 文件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env.dev</span><br><span class=\"line\"># 开发环境特有的变量</span><br><span class=\"line\">DB_HOST=db # 在 docker 网络里，数据库服务名叫 db</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DEBUG=true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env.prod</span><br><span class=\"line\"># 生产环境特有的变量</span><br><span class=\"line\">DB_HOST=prod.database.com # 外部数据库地址</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DEBUG=false</span><br></pre></td></tr></table></figure>\n<p><em>(注意：<code>.env</code> 文件如果存在，也会被默认加载，然后 <code>.env.dev</code> 或 <code>.env.prod</code> 如果被 env_file 指定，其中的变量会覆盖 <code>.env</code> 中同名的变量。)</em></p>\n<p><strong>第二步：创建基础文件 (<code>docker-compose.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># build 或 image 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># ports 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes (代码挂载) 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># environment (NODE_ENV, DB_HOST等) 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file 在覆盖文件里指定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 重启策略是通用的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># app 依赖 db 处于健康状态 (需要 db 服务配置 healthcheck)</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># app 和 db 都在同一个网络里通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 通用健康检查 (如果健康检查方式不同，可以在覆盖文件里重写)</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># environment (密码, DB_NAME) 可以在 .env 或者覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes (数据卷) 在这里指定结构，或者在覆盖文件里指定不同类型</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 默认使用命名卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 重启策略是通用的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># app 和 db 在同一个网络里通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 数据库健康检查 (通用)</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 顶层声明命名卷 (通用)</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 顶层声明网络 (通用)</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第三步：创建开发环境覆盖文件 (<code>docker-compose.dev.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.dev.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这个文件会覆盖 docker-compose.yml 中的一些设置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 版本号需要和基础文件一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 app 服务的配置</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span> <span class=\"comment\"># 开发环境从本地构建</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 可能使用不同的 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span> <span class=\"comment\"># 开发环境映射到 3000</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖 volumes，添加本地代码挂载（注意：列表是合并，如果基础文件有命名卷，这里需要重写整个 volumes 列表）</span></span><br><span class=\"line\">      <span class=\"comment\"># Docker Compose V3+ 合并规则是：列表类型的字段会**合并**，映射类型的字段会**覆盖**。</span></span><br><span class=\"line\">      <span class=\"comment\"># 为了清晰，通常在覆盖文件里写全需要的所有 volumes。</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span> <span class=\"comment\"># 添加本地代码挂载</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 也要保留数据库的数据卷挂载</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖或添加环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env.dev</span> <span class=\"comment\"># 加载开发环境特有的变量文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 db 服务的配置</span></span><br><span class=\"line\">    <span class=\"comment\"># 在开发环境，db 的健康检查可能更宽松</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 检查频率高一点</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">10s</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># db 在 dev 环境可能也需要一些特定的环境变量，比如创建测试数据库</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_dev</span> <span class=\"comment\"># 覆盖或添加环境变量</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：<code>volumes</code> 字段是列表，Docker Compose 合并时会把所有列表项加在一起。如果你想<strong>替换</strong>某个卷而不是*<em>添加</em></em>，或者想在覆盖文件中明确卷的类型（如本地路径 vs 命名卷），你需要写完整的 <code>volumes</code> 配置，它会覆盖基础文件中的同名字段。上面的例子中，<code>volumes</code> 列表被完整替换了，包含了基础文件中的命名卷和开发环境特有的绑定挂载。<code>environment</code> 是映射，同名变量会覆盖。*</p>\n<p><strong>第四步：创建生产环境覆盖文件 (<code>docker-compose.prod.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.prod.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这个文件会覆盖 docker-compose.yml 中的一些设置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 版本号需要和基础文件一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 app 服务的配置</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span> <span class=\"comment\"># 生产环境使用预构建的镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># build: # 生产环境不需要 build，所以这里不写 build 字段，或者设置为 null/[]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span> <span class=\"comment\"># 生产环境映射到 80</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 生产环境不挂载本地代码，只保留数据卷挂载</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 保留数据库的数据卷挂载</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖或添加环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">production</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env.prod</span> <span class=\"comment\"># 加载生产环境特有的变量文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 生产环境 db 可能不需要特定的覆盖，使用基础文件和 .env.prod 中的配置即可</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果需要，可以在这里添加覆盖配置</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_prod</span> <span class=\"comment\"># 生产环境数据库名不同</span></span><br></pre></td></tr></table></figure>\n<p><em>同样注意 <code>volumes</code> 的合并规则，这里只保留了 <code>db_data</code> 的挂载。</em></p>\n<h3 id=\"运行不同环境的应用\"><a href=\"#运行不同环境的应用\" class=\"headerlink\" title=\"运行不同环境的应用\"></a>运行不同环境的应用</h3><p>现在，你可以使用 <code>-f</code> 参数来指定要加载哪些配置文件。</p>\n<ul>\n<li><p><strong>运行开发环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认 docker-compose.yml 是第一个加载的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 然后 docker-compose.dev.yml 会覆盖其中的配置</span></span><br><span class=\"line\"><span class=\"comment\"># -d 参数表示以后台模式运行</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build</span><br><span class=\"line\"><span class=\"comment\"># --build 是为了确保开发环境总是使用最新的本地代码构建</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>运行生产环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认 docker-compose.yml 是第一个加载的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 然后 docker-compose.prod.yml 会覆盖其中的配置</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d</span><br><span class=\"line\"><span class=\"comment\"># 生产环境通常使用 image，所以这里不需要 --build</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>停止和清理特定环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止开发环境</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.dev.yml down</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止生产环境 (注意 -v 慎用，它会删除数据卷)</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.prod.yml down</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>文件合并规则总结 (V3.x)</strong>：</p>\n<ul>\n<li><strong>映射 (Map)</strong>：例如 <code>environment</code>, <code>labels</code>, <code>healthcheck</code> 等，会<strong>完全覆盖</strong>基础文件中的对应映射。</li>\n<li><strong>列表 (List)</strong>：例如 <code>ports</code>, <code>volumes</code>, <code>networks</code> (服务内部的)，会<strong>合并</strong>基础文件和覆盖文件中的列表项。同名卷或端口映射可能会有复杂的行为，通常建议在覆盖文件里写全希望的最终列表项。</li>\n<li><strong>顶层 <code>volumes</code> 和 <code>networks</code></strong>：会合并，同名项被覆盖。</li>\n</ul>\n<p>使用 <code>-f</code> 参数组合文件是管理多环境配置最灵活和常用的方法。</p>\n<hr>\n<h2 id=\"♻️-extends-关键字：让配置更-DRY-Don’t-Repeat-Yourself\"><a href=\"#♻️-extends-关键字：让配置更-DRY-Don’t-Repeat-Yourself\" class=\"headerlink\" title=\"♻️ extends 关键字：让配置更 DRY (Don’t Repeat Yourself)\"></a>♻️ <code>extends</code> 关键字：让配置更 DRY (Don’t Repeat Yourself)</h2><p>除了 <code>-f</code> 组合文件，Docker Compose 还提供了 <code>extends</code> 关键字，用于在不同服务之间<strong>共享通用的配置片段</strong>，或者在一个文件里引用另一个文件中的服务定义。这是一种<strong>复用配置</strong>的机制。</p>\n<p>虽然 <code>extends</code> 也可以间接用于多环境（通过继承不同基础配置），但它更主要的用途是抽象和复用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: common.yml # 存放通用配置片段</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">_base_app:</span> <span class=\"string\">&amp;base_app</span> <span class=\"comment\"># 使用 YAML 锚点 &amp; 定义一个可复用的配置块</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 通用健康检查配置</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">60s</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">_base_db:</span> <span class=\"meta\">&amp;base_db</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 通用数据库健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping -h localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 通用网络定义</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml # 主文件，使用 extends 或引用通用片段</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 直接引用 common.yml 中的网络定义</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 使用 extends 继承 common.yml 中的 _base_app 配置</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># extends:</span></span><br><span class=\"line\">    <span class=\"comment\">#   file: common.yml # 指定从哪个文件继承</span></span><br><span class=\"line\">    <span class=\"comment\">#   service: _base_app # 指定继承哪个服务定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 YAML 锚点引用 (更简洁，但只能在同一个或被引用的文件中使用)</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"string\">*base_app</span> <span class=\"comment\"># 引用 common.yml 中定义的 _base_app 锚点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 然后在这里添加或覆盖特定配置</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 extends 继承 common.yml 中的 _base_db 配置</span></span><br><span class=\"line\">    <span class=\"comment\"># extends:</span></span><br><span class=\"line\">    <span class=\"comment\">#   file: common.yml</span></span><br><span class=\"line\">    <span class=\"comment\">#   service: _base_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 YAML 锚点引用</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*base_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 然后在这里添加或覆盖特定配置</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=mysecretpassword</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># 在主文件或通用文件里声明卷</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：上面的例子结合使用了 <code>extends</code> 和 YAML 锚点。<code>extends</code> 用于引用<strong>另一个文件</strong>中的完整服务定义，YAML 锚点则用于在一个文件内部或被引用的文件中定义和复用配置块。在 V3+ 版本中，YAML 锚点配合 <code>-f</code> 多文件组合是实现 DRY 和多环境管理的一种常见且灵活的方式。</em></p>\n<ul>\n<li><p><strong><code>extends</code> 适合场景</strong>：</p>\n<ul>\n<li>多个服务有大量重复配置（如 logging, restart, common labels）。</li>\n<li>在大型项目中，将一些基础服务定义（如一个标准的 Web 服务模板）放在单独的文件中供其他项目复用。</li>\n</ul>\n</li>\n<li><p><strong><code>extends</code> vs <code>-f</code> 组合</strong>：</p>\n<ul>\n<li><code>-f</code> 组合：更侧重于<strong>合并和覆盖</strong>配置，是实现<strong>不同环境</strong>配置切换的标准方式。</li>\n<li><code>extends</code>：更侧重于<strong>继承和复用</strong>配置片段或服务定义，是实现 DRY 的一种方式。它们可以结合使用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"✅-多环境管理的最佳实践\"><a href=\"#✅-多环境管理的最佳实践\" class=\"headerlink\" title=\"✅ 多环境管理的最佳实践\"></a>✅ 多环境管理的最佳实践</h2><ol>\n<li><strong>一个基础 <code>docker-compose.yml</code></strong>：包含项目共有的、不随环境变化的配置。</li>\n<li><strong>多个环境覆盖文件</strong> (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code> 等)：只包含特定环境的<strong>差异</strong>和对基础配置的<strong>覆盖</strong>。</li>\n<li><strong>使用 <code>-f</code> 参数</strong>：通过 <code>docker-compose -f docker-compose.yml -f docker-compose.[env].yml up -d</code> 命令来启动特定环境。</li>\n<li><strong><code>.env</code> 文件用于加载变量</strong>：每个环境可以有自己的 <code>.env.[env]</code> 文件，并通过 <code>env_file</code> 加载。对于简单变量，项目根目录的 <code>.env</code> 文件也可以作为默认值加载。</li>\n<li><strong>敏感信息处理</strong>：开发环境可以使用 <code>.env</code> 并加入 <code>.gitignore</code>。生产环境<strong>不推荐</strong>将敏感信息放入 <code>.env</code> 或直接写在 yml 里，应考虑使用 Docker Secrets 或其他秘密管理工具。</li>\n<li><strong>配置合并理解</strong>：牢记 Docker Compose 的配置合并规则（映射覆盖，列表合并），编写覆盖文件时要小心。</li>\n</ol>\n<p>通过将通用配置放在基础文件，环境特定的差异放在覆盖文件，并结合环境变量的使用，你的 Docker Compose 配置将变得非常灵活、易于管理，并且能够轻松适应不同的部署环境！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了 Docker Compose 中环境变量的高级用法和多环境配置管理：</p>\n<ul>\n<li>复习了 <code>environment</code> 和 <code>env_file</code> 的作用。</li>\n<li>深入了解了 <code>.env</code> 文件自动加载和变量覆盖的机制。</li>\n<li>掌握了使用 <code>-f</code> 参数组合多个 <code>docker-compose.yml</code> 文件来实现不同环境配置切换的核心方法。</li>\n<li>了解了 <code>extends</code> 关键字用于配置复用的功能。</li>\n<li>总结了多环境管理的最佳实践。</li>\n</ul>\n<p>现在，你不仅能定义服务，还能根据不同的需求轻松调整它们的配置了！接下来，我们将探索 Docker Compose 中用于限制容器资源使用、命名容器以及配置日志等方面的高级字段。这将在下一章“深入服务配置：资源限制与其他字段”中讲解！敬请期待！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-配置随环境而变：环境变量与多环境-Docker-Compose-实战！\"><a href=\"#🐳-配置随环境而变：环境变量与多环境-Docker-Compose-实战！\" class=\"headerlink\" title=\"🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！\"></a>🐳 配置随环境而变：环境变量与多环境 Docker Compose 实战！</h1><p>哈喽！我们又见面啦！通过前几章的学习，你已经掌握了如何描述单个服务、定义项目结构以及操作 Docker Compose。你甚至能搞定服务之间的复杂依赖和健康检查了，非常棒！</p>\n<p>现在，让我们面对一个更实际的问题：你的应用在<strong>开发环境</strong>可能连接的是本地的数据库，使用调试模式；在<strong>生产环境</strong>可能连接的是云端的数据库，需要更高的性能配置，使用生产模式。这些“随环境变化”的配置信息怎么管理呢？</p>\n<p>硬生生地在 <code>docker-compose.yml</code> 文件里改来改去显然不是个好主意，容易出错，也不方便。幸运的是，Docker Compose 提供了非常灵活的方式来处理这些问题，主要就是通过<strong>环境变量</strong>和<strong>多文件组合</strong>来实现！</p>\n<p>今天，我们就来深入学习如何让你的 Docker Compose 配置“活”起来，根据不同的环境加载不同的设置。</p>\n<hr>\n<h2 id=\"🌳-环境变量：配置信息的“活水”\"><a href=\"#🌳-环境变量：配置信息的“活水”\" class=\"headerlink\" title=\"🌳 环境变量：配置信息的“活水”\"></a>🌳 环境变量：配置信息的“活水”</h2><p>在第一章我们就提到了 <code>environment</code> 和 <code>env_file</code> 字段，它们是把配置信息作为环境变量传递给容器。为什么环境变量这么重要呢？</p>\n<ol>\n<li><strong>灵活</strong>：你可以在不修改镜像或 Docker Compose 文件本身的情况下，改变容器的行为。</li>\n<li><strong>安全</strong>：相较于直接在代码里硬编码，环境变量更适合传递一些非敏感或敏感程度较低的配置。</li>\n<li><strong>标准</strong>：这是云原生应用和微服务常用的配置方式，符合“十二要素应用”（The Twelve-Factor App）的原则。</li>\n</ol>\n<h3 id=\"复习：两种传递环境变量的方式\"><a href=\"#复习：两种传递环境变量的方式\" class=\"headerlink\" title=\"复习：两种传递环境变量的方式\"></a>复习：两种传递环境变量的方式</h3><ul>\n<li><p><strong><code>environment</code></strong>：直接在服务配置里列出变量名和值。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">PORT=3000</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>适合场景</strong>：变量少，或者变量值比较固定且不敏感。</li>\n</ul>\n</li>\n<li><p><strong><code>env_file</code></strong>：从一个或多个文件中读取变量。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env</span> <span class=\"comment\"># 加载当前目录下的 .env 文件</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./config/app.env</span> <span class=\"comment\"># 也可以加载其他文件</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>适合场景</strong>：变量多，或者想把配置和 <code>docker-compose.yml</code> 文件分开，让文件更整洁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"env-文件：Docker-Compose-的“默认配置包”\"><a href=\"#env-文件：Docker-Compose-的“默认配置包”\" class=\"headerlink\" title=\".env 文件：Docker Compose 的“默认配置包”\"></a><code>.env</code> 文件：Docker Compose 的“默认配置包”</h3><p>当你在项目根目录下创建一个名为 <code>.env</code> 的文件时，<strong>Docker Compose 在运行任何命令（如 <code>up</code>, <code>down</code>, <code>build</code> 等）时，会默认自动加载这个文件中的环境变量</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env</span><br><span class=\"line\"># 格式：变量名=值 （注意等号两边通常没有空格，值如果有空格或特殊字符需要用引号包起来）</span><br><span class=\"line\"></span><br><span class=\"line\">DB_HOST=localhost</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DB_USER=root</span><br><span class=\"line\">DB_PASSWORD=mysecretpassword</span><br><span class=\"line\"></span><br><span class=\"line\">API_KEY=abcdef123456</span><br><span class=\"line\">DEBUG=true</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>docker-compose.yml</code> 文件中，你可以使用 <code>$&#123;变量名&#125;</code> 的语法来引用这些变量：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-app</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 直接引用 .env 文件里或者宿主机环境中的变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=$&#123;DB_HOST&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_PORT=$&#123;DB_PORT&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">API_KEY=$&#123;API_KEY&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DEBUG=$&#123;DEBUG&#125;</span></span><br><span class=\"line\">      <span class=\"comment\"># 你也可以同时设置一些没有在 .env 文件里的变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">APP_MODE=web</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 env_file 加载 .env 文件，效果一样，但这种方式更显式</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file:</span></span><br><span class=\"line\">    <span class=\"comment\">#   - .env</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 同样引用变量</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=$&#123;DB_PASSWORD&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br></pre></td></tr></table></figure>\n\n<p>当你运行 <code>docker-compose up</code> 时，Docker Compose 会：</p>\n<ol>\n<li>读取当前目录下的 <code>.env</code> 文件，将里面的 <code>DB_HOST</code>, <code>DB_PORT</code> 等变量加载到内存中。</li>\n<li>解析 <code>docker-compose.yml</code> 文件。</li>\n<li>遇到 <code>$&#123;DB_HOST&#125;</code> 等占位符时，用从 <code>.env</code> 或宿主机环境中加载到的实际值替换它们。</li>\n<li>用替换后的完整配置来创建和启动容器，并将这些变量传递给容器。</li>\n</ol>\n<ul>\n<li><p><strong>变量加载顺序 (优先级从高到低)</strong>：</p>\n<ol>\n<li>在命令行中传递的环境变量（例如 <code>DB_HOST=192.168.1.1 docker-compose up</code>）。</li>\n<li>宿主机&#x2F;Shell 环境中已经存在的环境变量。</li>\n<li><code>.env</code> 文件中的变量。</li>\n<li><code>docker-compose.yml</code> 中 <code>environment</code> 字段直接设置的值。<br><em>理解这个顺序很重要，你可以通过设置宿主机环境变量来覆盖 <code>.env</code> 文件中的值！</em></li>\n</ol>\n</li>\n<li><p><strong><code>.env</code> 文件适合场景</strong>：</p>\n<ul>\n<li>存储开发环境的默认配置。</li>\n<li>存储一些非敏感的应用参数。</li>\n<li>方便团队成员共享基础配置。</li>\n</ul>\n</li>\n<li><p><strong><code>.env</code> 文件</strong>不适合<strong>场景</strong>：</p>\n<ul>\n<li>存储真正的<strong>生产环境敏感密钥</strong>（如生产数据库密码、第三方服务 API Key）。虽然 <code>.env</code> 文件本身可能不提交到 Git，但这种方式不够安全和健壮。生产环境推荐使用 Docker Secrets 或 Kubernetes Secrets 等更专业的密钥管理方案。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"🔄-多环境管理：用-f-组合不同的配置文件！\"><a href=\"#🔄-多环境管理：用-f-组合不同的配置文件！\" class=\"headerlink\" title=\"🔄 多环境管理：用 -f 组合不同的配置文件！\"></a>🔄 多环境管理：用 <code>-f</code> 组合不同的配置文件！</h2><p><code>.env</code> 文件方便了环境变量的管理，但如果不同环境（dev&#x2F;prod）的配置差异很大，比如：</p>\n<ul>\n<li>开发环境：使用本地构建的镜像 (<code>build</code>)，端口映射到 <code>3000</code>，挂载本地代码目录 (<code>volumes: .:/app</code>)，连接 Docker 网络内的数据库 (<code>DB_HOST=db</code>)。</li>\n<li>生产环境：使用预构建的镜像 (<code>image: my-app:latest</code>)，端口映射到 <code>80</code>，不挂载本地代码，连接外部的云数据库 (<code>DB_HOST=prod.database.com</code>)。</li>\n</ul>\n<p>这些差异涉及到 <code>build</code>, <code>image</code>, <code>ports</code>, <code>volumes</code>, <code>environment</code> 等多个字段，只靠 <code>.env</code> 文件就很难管理了。</p>\n<p>这时，最佳实践是使用 <strong>多个 <code>docker-compose.yml</code> 文件</strong>，并通过 <code>docker-compose</code> 命令的 <code>-f</code> 参数来组合和覆盖配置！</p>\n<p>基本思想是：</p>\n<ol>\n<li>创建一个 <strong>基础文件</strong> (<code>docker-compose.yml</code>)：包含所有环境共用的配置（比如服务名称、网络定义、卷定义、一些通用的环境变量、重启策略等）。</li>\n<li>创建 <strong>环境特定覆盖文件</strong> (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code> 等)：只包含特定环境的配置<strong>差异</strong>或<strong>覆盖项</strong>。</li>\n</ol>\n<p>当使用 <code>docker-compose -f docker-compose.yml -f docker-compose.dev.yml up</code> 时，Docker Compose 会<strong>合并</strong>这两个文件。后面文件的配置会覆盖前面文件的相同部分。</p>\n<h3 id=\"示例：开发环境-vs-生产环境\"><a href=\"#示例：开发环境-vs-生产环境\" class=\"headerlink\" title=\"示例：开发环境 vs 生产环境\"></a>示例：开发环境 vs 生产环境</h3><p>假设你有以下需求：</p>\n<ul>\n<li><p><strong>基础配置 (<code>docker-compose.yml</code>)</strong>：</p>\n<ul>\n<li>定义 <code>app</code> 和 <code>db</code> 服务。</li>\n<li>定义一个共同的网络 <code>app_network</code>。</li>\n<li><code>db</code> 服务使用 <code>mysql:5.7</code> 镜像，持久化到命名卷 <code>db_data</code>。</li>\n<li><code>app</code> 服务连接到 <code>app_network</code>，依赖 <code>db</code>。</li>\n<li>通用环境变量如 <code>API_KEY</code>，从 <code>.env</code> 加载。</li>\n<li><code>restart</code> 策略为 <code>unless-stopped</code>。</li>\n</ul>\n</li>\n<li><p><strong>开发环境覆盖 (<code>docker-compose.dev.yml</code>)</strong>：</p>\n<ul>\n<li><code>app</code> 服务使用 <code>build: .</code> 构建本地镜像。</li>\n<li><code>app</code> 服务端口映射 <code>3000:3000</code>。</li>\n<li><code>app</code> 服务挂载本地代码卷 <code>. : /app</code>。</li>\n<li><code>app</code> 服务设置 <code>NODE_ENV=development</code>。</li>\n<li><code>db</code> 服务使用默认端口和内部网络名连接 (<code>DB_HOST=db</code>)。</li>\n<li>使用 <code>.env.dev</code> 文件加载开发环境特有变量。</li>\n</ul>\n</li>\n<li><p><strong>生产环境覆盖 (<code>docker-compose.prod.yml</code>)</strong>：</p>\n<ul>\n<li><code>app</code> 服务使用 <code>image: myapp:latest</code> 镜像。</li>\n<li><code>app</code> 服务端口映射 <code>80:3000</code>。</li>\n<li><code>app</code> 服务不挂载本地代码卷。</li>\n<li><code>app</code> 服务设置 <code>NODE_ENV=production</code>。</li>\n<li><code>db</code> 服务连接外部数据库 (<code>DB_HOST=prod.database.com</code>)。</li>\n<li>使用 <code>.env.prod</code> 文件加载生产环境特有变量。</li>\n</ul>\n</li>\n</ul>\n<p><strong>第一步：创建 <code>.env.dev</code> 和 <code>.env.prod</code> 文件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env.dev</span><br><span class=\"line\"># 开发环境特有的变量</span><br><span class=\"line\">DB_HOST=db # 在 docker 网络里，数据库服务名叫 db</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DEBUG=true</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 文件名：.env.prod</span><br><span class=\"line\"># 生产环境特有的变量</span><br><span class=\"line\">DB_HOST=prod.database.com # 外部数据库地址</span><br><span class=\"line\">DB_PORT=3306</span><br><span class=\"line\">DEBUG=false</span><br></pre></td></tr></table></figure>\n<p><em>(注意：<code>.env</code> 文件如果存在，也会被默认加载，然后 <code>.env.dev</code> 或 <code>.env.prod</code> 如果被 env_file 指定，其中的变量会覆盖 <code>.env</code> 中同名的变量。)</em></p>\n<p><strong>第二步：创建基础文件 (<code>docker-compose.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># build 或 image 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># ports 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes (代码挂载) 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># environment (NODE_ENV, DB_HOST等) 在覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># env_file 在覆盖文件里指定</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 重启策略是通用的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># app 依赖 db 处于健康状态 (需要 db 服务配置 healthcheck)</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># app 和 db 都在同一个网络里通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 通用健康检查 (如果健康检查方式不同，可以在覆盖文件里重写)</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># environment (密码, DB_NAME) 可以在 .env 或者覆盖文件里指定</span></span><br><span class=\"line\">    <span class=\"comment\"># volumes (数据卷) 在这里指定结构，或者在覆盖文件里指定不同类型</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 默认使用命名卷</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span> <span class=\"comment\"># 重启策略是通用的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span> <span class=\"comment\"># app 和 db 在同一个网络里通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 数据库健康检查 (通用)</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 顶层声明命名卷 (通用)</span></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 顶层声明网络 (通用)</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第三步：创建开发环境覆盖文件 (<code>docker-compose.dev.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.dev.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这个文件会覆盖 docker-compose.yml 中的一些设置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 版本号需要和基础文件一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 app 服务的配置</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span> <span class=\"comment\"># 开发环境从本地构建</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span> <span class=\"comment\"># 可能使用不同的 Dockerfile</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span> <span class=\"comment\"># 开发环境映射到 3000</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖 volumes，添加本地代码挂载（注意：列表是合并，如果基础文件有命名卷，这里需要重写整个 volumes 列表）</span></span><br><span class=\"line\">      <span class=\"comment\"># Docker Compose V3+ 合并规则是：列表类型的字段会**合并**，映射类型的字段会**覆盖**。</span></span><br><span class=\"line\">      <span class=\"comment\"># 为了清晰，通常在覆盖文件里写全需要的所有 volumes。</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span> <span class=\"comment\"># 添加本地代码挂载</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 也要保留数据库的数据卷挂载</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖或添加环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">development</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env.dev</span> <span class=\"comment\"># 加载开发环境特有的变量文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 db 服务的配置</span></span><br><span class=\"line\">    <span class=\"comment\"># 在开发环境，db 的健康检查可能更宽松</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">5s</span> <span class=\"comment\"># 检查频率高一点</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">10s</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># db 在 dev 环境可能也需要一些特定的环境变量，比如创建测试数据库</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_dev</span> <span class=\"comment\"># 覆盖或添加环境变量</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：<code>volumes</code> 字段是列表，Docker Compose 合并时会把所有列表项加在一起。如果你想<strong>替换</strong>某个卷而不是*<em>添加</em></em>，或者想在覆盖文件中明确卷的类型（如本地路径 vs 命名卷），你需要写完整的 <code>volumes</code> 配置，它会覆盖基础文件中的同名字段。上面的例子中，<code>volumes</code> 列表被完整替换了，包含了基础文件中的命名卷和开发环境特有的绑定挂载。<code>environment</code> 是映射，同名变量会覆盖。*</p>\n<p><strong>第四步：创建生产环境覆盖文件 (<code>docker-compose.prod.yml</code>)</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.prod.yml</span></span><br><span class=\"line\"><span class=\"comment\"># 这个文件会覆盖 docker-compose.yml 中的一些设置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 版本号需要和基础文件一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># 覆盖或添加 app 服务的配置</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">myapp:latest</span> <span class=\"comment\"># 生产环境使用预构建的镜像</span></span><br><span class=\"line\">    <span class=\"comment\"># build: # 生产环境不需要 build，所以这里不写 build 字段，或者设置为 null/[]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:3000&quot;</span> <span class=\"comment\"># 生产环境映射到 80</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"comment\"># 生产环境不挂载本地代码，只保留数据卷挂载</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span> <span class=\"comment\"># 保留数据库的数据卷挂载</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"comment\"># 覆盖或添加环境变量</span></span><br><span class=\"line\">      <span class=\"attr\">NODE_ENV:</span> <span class=\"string\">production</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">env_file:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.env.prod</span> <span class=\"comment\"># 加载生产环境特有的变量文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 生产环境 db 可能不需要特定的覆盖，使用基础文件和 .env.prod 中的配置即可</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果需要，可以在这里添加覆盖配置</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MYSQL_DATABASE:</span> <span class=\"string\">myapp_prod</span> <span class=\"comment\"># 生产环境数据库名不同</span></span><br></pre></td></tr></table></figure>\n<p><em>同样注意 <code>volumes</code> 的合并规则，这里只保留了 <code>db_data</code> 的挂载。</em></p>\n<h3 id=\"运行不同环境的应用\"><a href=\"#运行不同环境的应用\" class=\"headerlink\" title=\"运行不同环境的应用\"></a>运行不同环境的应用</h3><p>现在，你可以使用 <code>-f</code> 参数来指定要加载哪些配置文件。</p>\n<ul>\n<li><p><strong>运行开发环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认 docker-compose.yml 是第一个加载的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 然后 docker-compose.dev.yml 会覆盖其中的配置</span></span><br><span class=\"line\"><span class=\"comment\"># -d 参数表示以后台模式运行</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build</span><br><span class=\"line\"><span class=\"comment\"># --build 是为了确保开发环境总是使用最新的本地代码构建</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>运行生产环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 默认 docker-compose.yml 是第一个加载的文件</span></span><br><span class=\"line\"><span class=\"comment\"># 然后 docker-compose.prod.yml 会覆盖其中的配置</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d</span><br><span class=\"line\"><span class=\"comment\"># 生产环境通常使用 image，所以这里不需要 --build</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>停止和清理特定环境：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 停止开发环境</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.dev.yml down</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 停止生产环境 (注意 -v 慎用，它会删除数据卷)</span></span><br><span class=\"line\">docker-compose -f docker-compose.yml -f docker-compose.prod.yml down</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>文件合并规则总结 (V3.x)</strong>：</p>\n<ul>\n<li><strong>映射 (Map)</strong>：例如 <code>environment</code>, <code>labels</code>, <code>healthcheck</code> 等，会<strong>完全覆盖</strong>基础文件中的对应映射。</li>\n<li><strong>列表 (List)</strong>：例如 <code>ports</code>, <code>volumes</code>, <code>networks</code> (服务内部的)，会<strong>合并</strong>基础文件和覆盖文件中的列表项。同名卷或端口映射可能会有复杂的行为，通常建议在覆盖文件里写全希望的最终列表项。</li>\n<li><strong>顶层 <code>volumes</code> 和 <code>networks</code></strong>：会合并，同名项被覆盖。</li>\n</ul>\n<p>使用 <code>-f</code> 参数组合文件是管理多环境配置最灵活和常用的方法。</p>\n<hr>\n<h2 id=\"♻️-extends-关键字：让配置更-DRY-Don’t-Repeat-Yourself\"><a href=\"#♻️-extends-关键字：让配置更-DRY-Don’t-Repeat-Yourself\" class=\"headerlink\" title=\"♻️ extends 关键字：让配置更 DRY (Don’t Repeat Yourself)\"></a>♻️ <code>extends</code> 关键字：让配置更 DRY (Don’t Repeat Yourself)</h2><p>除了 <code>-f</code> 组合文件，Docker Compose 还提供了 <code>extends</code> 关键字，用于在不同服务之间<strong>共享通用的配置片段</strong>，或者在一个文件里引用另一个文件中的服务定义。这是一种<strong>复用配置</strong>的机制。</p>\n<p>虽然 <code>extends</code> 也可以间接用于多环境（通过继承不同基础配置），但它更主要的用途是抽象和复用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: common.yml # 存放通用配置片段</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">_base_app:</span> <span class=\"string\">&amp;base_app</span> <span class=\"comment\"># 使用 YAML 锚点 &amp; 定义一个可复用的配置块</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 通用健康检查配置</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:3000/health&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">60s</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">_base_db:</span> <span class=\"meta\">&amp;base_db</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">app_network</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span> <span class=\"comment\"># 通用数据库健康检查</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping -h localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span> <span class=\"comment\"># 通用网络定义</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 文件名: docker-compose.yml # 主文件，使用 extends 或引用通用片段</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 直接引用 common.yml 中的网络定义</span></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">app_network:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"comment\"># 使用 extends 继承 common.yml 中的 _base_app 配置</span></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"comment\"># extends:</span></span><br><span class=\"line\">    <span class=\"comment\">#   file: common.yml # 指定从哪个文件继承</span></span><br><span class=\"line\">    <span class=\"comment\">#   service: _base_app # 指定继承哪个服务定义</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 YAML 锚点引用 (更简洁，但只能在同一个或被引用的文件中使用)</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"string\">*base_app</span> <span class=\"comment\"># 引用 common.yml 中定义的 _base_app 锚点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 然后在这里添加或覆盖特定配置</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span></span><br><span class=\"line\">      <span class=\"attr\">context:</span> <span class=\"string\">.</span></span><br><span class=\"line\">      <span class=\"attr\">dockerfile:</span> <span class=\"string\">Dockerfile.dev</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=development</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">DB_HOST=db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 extends 继承 common.yml 中的 _base_db 配置</span></span><br><span class=\"line\">    <span class=\"comment\"># extends:</span></span><br><span class=\"line\">    <span class=\"comment\">#   file: common.yml</span></span><br><span class=\"line\">    <span class=\"comment\">#   service: _base_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 或者使用 YAML 锚点引用</span></span><br><span class=\"line\">    <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*base_db</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 然后在这里添加或覆盖特定配置</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db_data:/var/lib/mysql</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_ROOT_PASSWORD=mysecretpassword</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">MYSQL_DATABASE=mydatabase</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">db_data:</span> <span class=\"comment\"># 在主文件或通用文件里声明卷</span></span><br></pre></td></tr></table></figure>\n<p><em>注意：上面的例子结合使用了 <code>extends</code> 和 YAML 锚点。<code>extends</code> 用于引用<strong>另一个文件</strong>中的完整服务定义，YAML 锚点则用于在一个文件内部或被引用的文件中定义和复用配置块。在 V3+ 版本中，YAML 锚点配合 <code>-f</code> 多文件组合是实现 DRY 和多环境管理的一种常见且灵活的方式。</em></p>\n<ul>\n<li><p><strong><code>extends</code> 适合场景</strong>：</p>\n<ul>\n<li>多个服务有大量重复配置（如 logging, restart, common labels）。</li>\n<li>在大型项目中，将一些基础服务定义（如一个标准的 Web 服务模板）放在单独的文件中供其他项目复用。</li>\n</ul>\n</li>\n<li><p><strong><code>extends</code> vs <code>-f</code> 组合</strong>：</p>\n<ul>\n<li><code>-f</code> 组合：更侧重于<strong>合并和覆盖</strong>配置，是实现<strong>不同环境</strong>配置切换的标准方式。</li>\n<li><code>extends</code>：更侧重于<strong>继承和复用</strong>配置片段或服务定义，是实现 DRY 的一种方式。它们可以结合使用。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"✅-多环境管理的最佳实践\"><a href=\"#✅-多环境管理的最佳实践\" class=\"headerlink\" title=\"✅ 多环境管理的最佳实践\"></a>✅ 多环境管理的最佳实践</h2><ol>\n<li><strong>一个基础 <code>docker-compose.yml</code></strong>：包含项目共有的、不随环境变化的配置。</li>\n<li><strong>多个环境覆盖文件</strong> (<code>docker-compose.dev.yml</code>, <code>docker-compose.prod.yml</code> 等)：只包含特定环境的<strong>差异</strong>和对基础配置的<strong>覆盖</strong>。</li>\n<li><strong>使用 <code>-f</code> 参数</strong>：通过 <code>docker-compose -f docker-compose.yml -f docker-compose.[env].yml up -d</code> 命令来启动特定环境。</li>\n<li><strong><code>.env</code> 文件用于加载变量</strong>：每个环境可以有自己的 <code>.env.[env]</code> 文件，并通过 <code>env_file</code> 加载。对于简单变量，项目根目录的 <code>.env</code> 文件也可以作为默认值加载。</li>\n<li><strong>敏感信息处理</strong>：开发环境可以使用 <code>.env</code> 并加入 <code>.gitignore</code>。生产环境<strong>不推荐</strong>将敏感信息放入 <code>.env</code> 或直接写在 yml 里，应考虑使用 Docker Secrets 或其他秘密管理工具。</li>\n<li><strong>配置合并理解</strong>：牢记 Docker Compose 的配置合并规则（映射覆盖，列表合并），编写覆盖文件时要小心。</li>\n</ol>\n<p>通过将通用配置放在基础文件，环境特定的差异放在覆盖文件，并结合环境变量的使用，你的 Docker Compose 配置将变得非常灵活、易于管理，并且能够轻松适应不同的部署环境！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们学习了 Docker Compose 中环境变量的高级用法和多环境配置管理：</p>\n<ul>\n<li>复习了 <code>environment</code> 和 <code>env_file</code> 的作用。</li>\n<li>深入了解了 <code>.env</code> 文件自动加载和变量覆盖的机制。</li>\n<li>掌握了使用 <code>-f</code> 参数组合多个 <code>docker-compose.yml</code> 文件来实现不同环境配置切换的核心方法。</li>\n<li>了解了 <code>extends</code> 关键字用于配置复用的功能。</li>\n<li>总结了多环境管理的最佳实践。</li>\n</ul>\n<p>现在，你不仅能定义服务，还能根据不同的需求轻松调整它们的配置了！接下来，我们将探索 Docker Compose 中用于限制容器资源使用、命名容器以及配置日志等方面的高级字段。这将在下一章“深入服务配置：资源限制与其他字段”中讲解！敬请期待！</p>\n"},{"title":"Docker 从零开始入门教程（超详细）","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":3065,"date":"2025-06-05T16:00:00.000Z","_content":"\n# 🚢 Docker 从零开始入门教程（超详细）\n\nDocker 是现代开发中最常用的容器技术之一。本文将带你从 0 开始，逐步掌握 Docker 的安装、使用、构建和实战部署。\n\n---\n\n## ✨ 什么是 Docker？\n\nDocker 是一个**轻量级虚拟化平台**，它可以把你的应用程序及其所有依赖项打包成一个“容器”，这个容器可以在任何地方运行——不需要担心环境不一致的问题。\n\n**简单理解：**  \n传统部署 = 装系统 + 装运行环境 + 装依赖库  \nDocker 部署 = 打包成一个“集装箱”，一搬就走 ✅\n\n---\n\n## 🧠 Docker 工作原理简图\n\n```\n+-----------------------+\n|     应用（App）      |\n|  +-----------------+ |\n|  | 所有依赖 & 运行时 | |\n|  +-----------------+ |\n+----------容器----------+\n          ↓\n     由 Docker 引擎统一管理\n```\n\nDocker 利用 Linux 内核的容器技术（如 namespaces 和 cgroups）隔离进程，实现“轻量级虚拟机”的效果。\n\n---\n\n## 🧰 一、安装 Docker\n\n### ✅ Windows / macOS 用户\n\n1. 访问官网：https://www.docker.com/products/docker-desktop\n2. 下载 Docker Desktop 安装包\n3. 一路点击“下一步”即可\n4. 安装完成后重启电脑，右下角会出现🐳图标\n\n### 🐧 Ubuntu Linux 用户\n\n```bash\n# 1. 更新系统\nsudo apt-get update\n\n# 2. 安装依赖\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n\n# 3. 添加 GPG 密钥\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\\n    sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# 4. 添加 Docker 软件源\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \\\n  https://download.docker.com/linux/ubuntu \\\n  $(lsb_release -cs) stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n\n# 5. 安装 Docker\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n\n# 6. 启动 Docker 并设置开机启动\nsudo systemctl start docker\nsudo systemctl enable docker\n\n# 7. 查看 Docker 版本\ndocker --version\n```\n\n---\n\n## 🚀 二、第一个 Docker 容器\n\n我们用 nginx（一个常见的 Web 服务器）举例。\n\n```bash\n# 拉取 nginx 镜像\ndocker pull nginx\n\n# 启动容器（映射本地 8080 到容器的 80）\ndocker run -d -p 8080:80 --name my-nginx nginx\n\n# 查看正在运行的容器\ndocker ps\n\n# 打开浏览器访问：\nhttp://localhost:8080\n```\n\n---\n\n## 📦 三、常用 Docker 命令详解\n\n| 命令 | 作用 |\n|------|------|\n| `docker pull 镜像名` | 下载镜像 |\n| `docker run` | 启动容器 |\n| `docker ps` | 查看正在运行的容器 |\n| `docker ps -a` | 查看所有容器 |\n| `docker stop 容器ID` | 停止容器 |\n| `docker rm 容器ID` | 删除容器 |\n| `docker images` | 查看本地镜像 |\n| `docker rmi 镜像ID` | 删除镜像 |\n| `docker exec -it 容器ID bash` | 进入容器终端 |\n\n---\n\n## 🔧 四、使用 Dockerfile 构建自己的镜像\n\n一个 Node.js 项目的 Dockerfile 示例：\n\n```Dockerfile\n# 使用官方 Node.js 镜像\nFROM node:18\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制 package.json 并安装依赖\nCOPY package*.json ./\nRUN npm install\n\n# 复制项目文件\nCOPY . .\n\n# 暴露端口\nEXPOSE 3000\n\n# 启动命令\nCMD [\"npm\", \"start\"]\n```\n\n### 构建镜像\n\n```bash\ndocker build -t my-node-app .\n```\n\n### 运行镜像\n\n```bash\ndocker run -p 3000:3000 my-node-app\n```\n\n---\n\n## 🧱 五、使用 Docker Compose 管理多个服务\n\n`docker-compose.yml` 示例：\n\n```yaml\nversion: '3'\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"8080:80\"\n\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n```\n\n运行：\n\n```bash\ndocker-compose up -d\n```\n\n关闭：\n\n```bash\ndocker-compose down\n```\n\n---\n\n## 🧯 六、常见问题与排查\n\n### ❓ Docker 无法启动\n\n- 检查是否有虚拟化支持（BIOS 中开启 VT）\n- macOS/Windows 重启 Docker Desktop\n\n### ❓ 端口无法访问？\n\n- 确认端口映射正确\n- 本地防火墙是否阻止\n- 用 `docker logs 容器ID` 查看日志\n\n### ❓ 容器运行后秒退？\n\n- 使用 `docker logs 容器ID` 检查错误日志\n- 某些服务（如 Node）可能需要前台运行 (`CMD [\"npm\", \"start\"]`)\n\n---\n\n## 📚 七、学习资源推荐\n\n- Docker 官网：https://www.docker.com/\n- Docker 中文文档：https://docs.docker.com/get-started/\n- 镜像仓库：https://hub.docker.com/\n- 《Docker — 从入门到实践》：https://yeasy.gitbook.io/docker_practice/\n\n---\n\n> 📌 本文适合 2025 年 Docker 主流版本，如有问题欢迎留言交流。\n>  \n> 作者：**[937bb]**｜转载请注明出处 🙏\n","source":"_posts/Docker/Docker 从零开始入门教程（超详细）.md","raw":"---\ntitle: Docker 从零开始入门教程（超详细）\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 3065\ndate: 2025-06-06 00:00:00\n---\n\n# 🚢 Docker 从零开始入门教程（超详细）\n\nDocker 是现代开发中最常用的容器技术之一。本文将带你从 0 开始，逐步掌握 Docker 的安装、使用、构建和实战部署。\n\n---\n\n## ✨ 什么是 Docker？\n\nDocker 是一个**轻量级虚拟化平台**，它可以把你的应用程序及其所有依赖项打包成一个“容器”，这个容器可以在任何地方运行——不需要担心环境不一致的问题。\n\n**简单理解：**  \n传统部署 = 装系统 + 装运行环境 + 装依赖库  \nDocker 部署 = 打包成一个“集装箱”，一搬就走 ✅\n\n---\n\n## 🧠 Docker 工作原理简图\n\n```\n+-----------------------+\n|     应用（App）      |\n|  +-----------------+ |\n|  | 所有依赖 & 运行时 | |\n|  +-----------------+ |\n+----------容器----------+\n          ↓\n     由 Docker 引擎统一管理\n```\n\nDocker 利用 Linux 内核的容器技术（如 namespaces 和 cgroups）隔离进程，实现“轻量级虚拟机”的效果。\n\n---\n\n## 🧰 一、安装 Docker\n\n### ✅ Windows / macOS 用户\n\n1. 访问官网：https://www.docker.com/products/docker-desktop\n2. 下载 Docker Desktop 安装包\n3. 一路点击“下一步”即可\n4. 安装完成后重启电脑，右下角会出现🐳图标\n\n### 🐧 Ubuntu Linux 用户\n\n```bash\n# 1. 更新系统\nsudo apt-get update\n\n# 2. 安装依赖\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n\n# 3. 添加 GPG 密钥\nsudo mkdir -p /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\\n    sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n# 4. 添加 Docker 软件源\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \\\n  https://download.docker.com/linux/ubuntu \\\n  $(lsb_release -cs) stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n\n# 5. 安装 Docker\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n\n# 6. 启动 Docker 并设置开机启动\nsudo systemctl start docker\nsudo systemctl enable docker\n\n# 7. 查看 Docker 版本\ndocker --version\n```\n\n---\n\n## 🚀 二、第一个 Docker 容器\n\n我们用 nginx（一个常见的 Web 服务器）举例。\n\n```bash\n# 拉取 nginx 镜像\ndocker pull nginx\n\n# 启动容器（映射本地 8080 到容器的 80）\ndocker run -d -p 8080:80 --name my-nginx nginx\n\n# 查看正在运行的容器\ndocker ps\n\n# 打开浏览器访问：\nhttp://localhost:8080\n```\n\n---\n\n## 📦 三、常用 Docker 命令详解\n\n| 命令 | 作用 |\n|------|------|\n| `docker pull 镜像名` | 下载镜像 |\n| `docker run` | 启动容器 |\n| `docker ps` | 查看正在运行的容器 |\n| `docker ps -a` | 查看所有容器 |\n| `docker stop 容器ID` | 停止容器 |\n| `docker rm 容器ID` | 删除容器 |\n| `docker images` | 查看本地镜像 |\n| `docker rmi 镜像ID` | 删除镜像 |\n| `docker exec -it 容器ID bash` | 进入容器终端 |\n\n---\n\n## 🔧 四、使用 Dockerfile 构建自己的镜像\n\n一个 Node.js 项目的 Dockerfile 示例：\n\n```Dockerfile\n# 使用官方 Node.js 镜像\nFROM node:18\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制 package.json 并安装依赖\nCOPY package*.json ./\nRUN npm install\n\n# 复制项目文件\nCOPY . .\n\n# 暴露端口\nEXPOSE 3000\n\n# 启动命令\nCMD [\"npm\", \"start\"]\n```\n\n### 构建镜像\n\n```bash\ndocker build -t my-node-app .\n```\n\n### 运行镜像\n\n```bash\ndocker run -p 3000:3000 my-node-app\n```\n\n---\n\n## 🧱 五、使用 Docker Compose 管理多个服务\n\n`docker-compose.yml` 示例：\n\n```yaml\nversion: '3'\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"8080:80\"\n\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    volumes:\n      - .:/app\n```\n\n运行：\n\n```bash\ndocker-compose up -d\n```\n\n关闭：\n\n```bash\ndocker-compose down\n```\n\n---\n\n## 🧯 六、常见问题与排查\n\n### ❓ Docker 无法启动\n\n- 检查是否有虚拟化支持（BIOS 中开启 VT）\n- macOS/Windows 重启 Docker Desktop\n\n### ❓ 端口无法访问？\n\n- 确认端口映射正确\n- 本地防火墙是否阻止\n- 用 `docker logs 容器ID` 查看日志\n\n### ❓ 容器运行后秒退？\n\n- 使用 `docker logs 容器ID` 检查错误日志\n- 某些服务（如 Node）可能需要前台运行 (`CMD [\"npm\", \"start\"]`)\n\n---\n\n## 📚 七、学习资源推荐\n\n- Docker 官网：https://www.docker.com/\n- Docker 中文文档：https://docs.docker.com/get-started/\n- 镜像仓库：https://hub.docker.com/\n- 《Docker — 从入门到实践》：https://yeasy.gitbook.io/docker_practice/\n\n---\n\n> 📌 本文适合 2025 年 Docker 主流版本，如有问题欢迎留言交流。\n>  \n> 作者：**[937bb]**｜转载请注明出处 🙏\n","slug":"Docker/Docker 从零开始入门教程（超详细）","published":1,"updated":"2025-06-07T15:58:53.665Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzwwc001ppkrc0oc3gx2f","content":"<h1 id=\"🚢-Docker-从零开始入门教程（超详细）\"><a href=\"#🚢-Docker-从零开始入门教程（超详细）\" class=\"headerlink\" title=\"🚢 Docker 从零开始入门教程（超详细）\"></a>🚢 Docker 从零开始入门教程（超详细）</h1><p>Docker 是现代开发中最常用的容器技术之一。本文将带你从 0 开始，逐步掌握 Docker 的安装、使用、构建和实战部署。</p>\n<hr>\n<h2 id=\"✨-什么是-Docker？\"><a href=\"#✨-什么是-Docker？\" class=\"headerlink\" title=\"✨ 什么是 Docker？\"></a>✨ 什么是 Docker？</h2><p>Docker 是一个<strong>轻量级虚拟化平台</strong>，它可以把你的应用程序及其所有依赖项打包成一个“容器”，这个容器可以在任何地方运行——不需要担心环境不一致的问题。</p>\n<p><strong>简单理解：</strong><br>传统部署 &#x3D; 装系统 + 装运行环境 + 装依赖库<br>Docker 部署 &#x3D; 打包成一个“集装箱”，一搬就走 ✅</p>\n<hr>\n<h2 id=\"🧠-Docker-工作原理简图\"><a href=\"#🧠-Docker-工作原理简图\" class=\"headerlink\" title=\"🧠 Docker 工作原理简图\"></a>🧠 Docker 工作原理简图</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------------+</span><br><span class=\"line\">|     应用（App）      |</span><br><span class=\"line\">|  +-----------------+ |</span><br><span class=\"line\">|  | 所有依赖 &amp; 运行时 | |</span><br><span class=\"line\">|  +-----------------+ |</span><br><span class=\"line\">+----------容器----------+</span><br><span class=\"line\">          ↓</span><br><span class=\"line\">     由 Docker 引擎统一管理</span><br></pre></td></tr></table></figure>\n\n<p>Docker 利用 Linux 内核的容器技术（如 namespaces 和 cgroups）隔离进程，实现“轻量级虚拟机”的效果。</p>\n<hr>\n<h2 id=\"🧰-一、安装-Docker\"><a href=\"#🧰-一、安装-Docker\" class=\"headerlink\" title=\"🧰 一、安装 Docker\"></a>🧰 一、安装 Docker</h2><h3 id=\"✅-Windows-macOS-用户\"><a href=\"#✅-Windows-macOS-用户\" class=\"headerlink\" title=\"✅ Windows &#x2F; macOS 用户\"></a>✅ Windows &#x2F; macOS 用户</h3><ol>\n<li>访问官网：<a href=\"https://www.docker.com/products/docker-desktop\">https://www.docker.com/products/docker-desktop</a></li>\n<li>下载 Docker Desktop 安装包</li>\n<li>一路点击“下一步”即可</li>\n<li>安装完成后重启电脑，右下角会出现🐳图标</li>\n</ol>\n<h3 id=\"🐧-Ubuntu-Linux-用户\"><a href=\"#🐧-Ubuntu-Linux-用户\" class=\"headerlink\" title=\"🐧 Ubuntu Linux 用户\"></a>🐧 Ubuntu Linux 用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 更新系统</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 安装依赖</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg \\</span><br><span class=\"line\">    lsb-release</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 添加 GPG 密钥</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/apt/keyrings</span><br><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\</span><br><span class=\"line\">    <span class=\"built_in\">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 添加 Docker 软件源</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> \\</span><br><span class=\"line\">  <span class=\"string\">&quot;deb [arch=<span class=\"subst\">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] \\</span></span><br><span class=\"line\"><span class=\"string\">  https://download.docker.com/linux/ubuntu \\</span></span><br><span class=\"line\"><span class=\"string\">  <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span> | \\</span><br><span class=\"line\">  <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 安装 Docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get update</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 启动 Docker 并设置开机启动</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 查看 Docker 版本</span></span><br><span class=\"line\">docker --version</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-二、第一个-Docker-容器\"><a href=\"#🚀-二、第一个-Docker-容器\" class=\"headerlink\" title=\"🚀 二、第一个 Docker 容器\"></a>🚀 二、第一个 Docker 容器</h2><p>我们用 nginx（一个常见的 Web 服务器）举例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取 nginx 镜像</span></span><br><span class=\"line\">docker pull nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器（映射本地 8080 到容器的 80）</span></span><br><span class=\"line\">docker run -d -p 8080:80 --name my-nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打开浏览器访问：</span></span><br><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📦-三、常用-Docker-命令详解\"><a href=\"#📦-三、常用-Docker-命令详解\" class=\"headerlink\" title=\"📦 三、常用 Docker 命令详解\"></a>📦 三、常用 Docker 命令详解</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>docker pull 镜像名</code></td>\n<td>下载镜像</td>\n</tr>\n<tr>\n<td><code>docker run</code></td>\n<td>启动容器</td>\n</tr>\n<tr>\n<td><code>docker ps</code></td>\n<td>查看正在运行的容器</td>\n</tr>\n<tr>\n<td><code>docker ps -a</code></td>\n<td>查看所有容器</td>\n</tr>\n<tr>\n<td><code>docker stop 容器ID</code></td>\n<td>停止容器</td>\n</tr>\n<tr>\n<td><code>docker rm 容器ID</code></td>\n<td>删除容器</td>\n</tr>\n<tr>\n<td><code>docker images</code></td>\n<td>查看本地镜像</td>\n</tr>\n<tr>\n<td><code>docker rmi 镜像ID</code></td>\n<td>删除镜像</td>\n</tr>\n<tr>\n<td><code>docker exec -it 容器ID bash</code></td>\n<td>进入容器终端</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔧-四、使用-Dockerfile-构建自己的镜像\"><a href=\"#🔧-四、使用-Dockerfile-构建自己的镜像\" class=\"headerlink\" title=\"🔧 四、使用 Dockerfile 构建自己的镜像\"></a>🔧 四、使用 Dockerfile 构建自己的镜像</h2><p>一个 Node.js 项目的 Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用官方 Node.js 镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 package.json 并安装依赖</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package*.json ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制项目文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动命令</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t my-node-app .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行镜像\"><a href=\"#运行镜像\" class=\"headerlink\" title=\"运行镜像\"></a>运行镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 3000:3000 my-node-app</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧱-五、使用-Docker-Compose-管理多个服务\"><a href=\"#🧱-五、使用-Docker-Compose-管理多个服务\" class=\"headerlink\" title=\"🧱 五、使用 Docker Compose 管理多个服务\"></a>🧱 五、使用 Docker Compose 管理多个服务</h2><p><code>docker-compose.yml</code> 示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:80&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<p>关闭：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose down</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-六、常见问题与排查\"><a href=\"#🧯-六、常见问题与排查\" class=\"headerlink\" title=\"🧯 六、常见问题与排查\"></a>🧯 六、常见问题与排查</h2><h3 id=\"❓-Docker-无法启动\"><a href=\"#❓-Docker-无法启动\" class=\"headerlink\" title=\"❓ Docker 无法启动\"></a>❓ Docker 无法启动</h3><ul>\n<li>检查是否有虚拟化支持（BIOS 中开启 VT）</li>\n<li>macOS&#x2F;Windows 重启 Docker Desktop</li>\n</ul>\n<h3 id=\"❓-端口无法访问？\"><a href=\"#❓-端口无法访问？\" class=\"headerlink\" title=\"❓ 端口无法访问？\"></a>❓ 端口无法访问？</h3><ul>\n<li>确认端口映射正确</li>\n<li>本地防火墙是否阻止</li>\n<li>用 <code>docker logs 容器ID</code> 查看日志</li>\n</ul>\n<h3 id=\"❓-容器运行后秒退？\"><a href=\"#❓-容器运行后秒退？\" class=\"headerlink\" title=\"❓ 容器运行后秒退？\"></a>❓ 容器运行后秒退？</h3><ul>\n<li>使用 <code>docker logs 容器ID</code> 检查错误日志</li>\n<li>某些服务（如 Node）可能需要前台运行 (<code>CMD [&quot;npm&quot;, &quot;start&quot;]</code>)</li>\n</ul>\n<hr>\n<h2 id=\"📚-七、学习资源推荐\"><a href=\"#📚-七、学习资源推荐\" class=\"headerlink\" title=\"📚 七、学习资源推荐\"></a>📚 七、学习资源推荐</h2><ul>\n<li>Docker 官网：<a href=\"https://www.docker.com/\">https://www.docker.com/</a></li>\n<li>Docker 中文文档：<a href=\"https://docs.docker.com/get-started/\">https://docs.docker.com/get-started/</a></li>\n<li>镜像仓库：<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></li>\n<li>《Docker — 从入门到实践》：<a href=\"https://yeasy.gitbook.io/docker_practice/\">https://yeasy.gitbook.io/docker_practice/</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>📌 本文适合 2025 年 Docker 主流版本，如有问题欢迎留言交流。</p>\n<p>作者：<strong>[937bb]</strong>｜转载请注明出处 🙏</p>\n</blockquote>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🚢-Docker-从零开始入门教程（超详细）\"><a href=\"#🚢-Docker-从零开始入门教程（超详细）\" class=\"headerlink\" title=\"🚢 Docker 从零开始入门教程（超详细）\"></a>🚢 Docker 从零开始入门教程（超详细）</h1><p>Docker 是现代开发中最常用的容器技术之一。本文将带你从 0 开始，逐步掌握 Docker 的安装、使用、构建和实战部署。</p>\n<hr>\n<h2 id=\"✨-什么是-Docker？\"><a href=\"#✨-什么是-Docker？\" class=\"headerlink\" title=\"✨ 什么是 Docker？\"></a>✨ 什么是 Docker？</h2><p>Docker 是一个<strong>轻量级虚拟化平台</strong>，它可以把你的应用程序及其所有依赖项打包成一个“容器”，这个容器可以在任何地方运行——不需要担心环境不一致的问题。</p>\n<p><strong>简单理解：</strong><br>传统部署 &#x3D; 装系统 + 装运行环境 + 装依赖库<br>Docker 部署 &#x3D; 打包成一个“集装箱”，一搬就走 ✅</p>\n<hr>\n<h2 id=\"🧠-Docker-工作原理简图\"><a href=\"#🧠-Docker-工作原理简图\" class=\"headerlink\" title=\"🧠 Docker 工作原理简图\"></a>🧠 Docker 工作原理简图</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------------+</span><br><span class=\"line\">|     应用（App）      |</span><br><span class=\"line\">|  +-----------------+ |</span><br><span class=\"line\">|  | 所有依赖 &amp; 运行时 | |</span><br><span class=\"line\">|  +-----------------+ |</span><br><span class=\"line\">+----------容器----------+</span><br><span class=\"line\">          ↓</span><br><span class=\"line\">     由 Docker 引擎统一管理</span><br></pre></td></tr></table></figure>\n\n<p>Docker 利用 Linux 内核的容器技术（如 namespaces 和 cgroups）隔离进程，实现“轻量级虚拟机”的效果。</p>\n<hr>\n<h2 id=\"🧰-一、安装-Docker\"><a href=\"#🧰-一、安装-Docker\" class=\"headerlink\" title=\"🧰 一、安装 Docker\"></a>🧰 一、安装 Docker</h2><h3 id=\"✅-Windows-macOS-用户\"><a href=\"#✅-Windows-macOS-用户\" class=\"headerlink\" title=\"✅ Windows &#x2F; macOS 用户\"></a>✅ Windows &#x2F; macOS 用户</h3><ol>\n<li>访问官网：<a href=\"https://www.docker.com/products/docker-desktop\">https://www.docker.com/products/docker-desktop</a></li>\n<li>下载 Docker Desktop 安装包</li>\n<li>一路点击“下一步”即可</li>\n<li>安装完成后重启电脑，右下角会出现🐳图标</li>\n</ol>\n<h3 id=\"🐧-Ubuntu-Linux-用户\"><a href=\"#🐧-Ubuntu-Linux-用户\" class=\"headerlink\" title=\"🐧 Ubuntu Linux 用户\"></a>🐧 Ubuntu Linux 用户</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 更新系统</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 安装依赖</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install \\</span><br><span class=\"line\">    ca-certificates \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    gnupg \\</span><br><span class=\"line\">    lsb-release</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 添加 GPG 密钥</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/apt/keyrings</span><br><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \\</span><br><span class=\"line\">    <span class=\"built_in\">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 添加 Docker 软件源</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> \\</span><br><span class=\"line\">  <span class=\"string\">&quot;deb [arch=<span class=\"subst\">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] \\</span></span><br><span class=\"line\"><span class=\"string\">  https://download.docker.com/linux/ubuntu \\</span></span><br><span class=\"line\"><span class=\"string\">  <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span> | \\</span><br><span class=\"line\">  <span class=\"built_in\">sudo</span> <span class=\"built_in\">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5. 安装 Docker</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get update</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 启动 Docker 并设置开机启动</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl start docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 查看 Docker 版本</span></span><br><span class=\"line\">docker --version</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🚀-二、第一个-Docker-容器\"><a href=\"#🚀-二、第一个-Docker-容器\" class=\"headerlink\" title=\"🚀 二、第一个 Docker 容器\"></a>🚀 二、第一个 Docker 容器</h2><p>我们用 nginx（一个常见的 Web 服务器）举例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取 nginx 镜像</span></span><br><span class=\"line\">docker pull nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动容器（映射本地 8080 到容器的 80）</span></span><br><span class=\"line\">docker run -d -p 8080:80 --name my-nginx nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看正在运行的容器</span></span><br><span class=\"line\">docker ps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打开浏览器访问：</span></span><br><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"📦-三、常用-Docker-命令详解\"><a href=\"#📦-三、常用-Docker-命令详解\" class=\"headerlink\" title=\"📦 三、常用 Docker 命令详解\"></a>📦 三、常用 Docker 命令详解</h2><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>docker pull 镜像名</code></td>\n<td>下载镜像</td>\n</tr>\n<tr>\n<td><code>docker run</code></td>\n<td>启动容器</td>\n</tr>\n<tr>\n<td><code>docker ps</code></td>\n<td>查看正在运行的容器</td>\n</tr>\n<tr>\n<td><code>docker ps -a</code></td>\n<td>查看所有容器</td>\n</tr>\n<tr>\n<td><code>docker stop 容器ID</code></td>\n<td>停止容器</td>\n</tr>\n<tr>\n<td><code>docker rm 容器ID</code></td>\n<td>删除容器</td>\n</tr>\n<tr>\n<td><code>docker images</code></td>\n<td>查看本地镜像</td>\n</tr>\n<tr>\n<td><code>docker rmi 镜像ID</code></td>\n<td>删除镜像</td>\n</tr>\n<tr>\n<td><code>docker exec -it 容器ID bash</code></td>\n<td>进入容器终端</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🔧-四、使用-Dockerfile-构建自己的镜像\"><a href=\"#🔧-四、使用-Dockerfile-构建自己的镜像\" class=\"headerlink\" title=\"🔧 四、使用 Dockerfile 构建自己的镜像\"></a>🔧 四、使用 Dockerfile 构建自己的镜像</h2><p>一个 Node.js 项目的 Dockerfile 示例：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用官方 Node.js 镜像</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置工作目录</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> /app</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 package.json 并安装依赖</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> package*.json ./</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> npm install</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制项目文件</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> . .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 暴露端口</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">3000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动命令</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;npm&quot;</span>, <span class=\"string\">&quot;start&quot;</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t my-node-app .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行镜像\"><a href=\"#运行镜像\" class=\"headerlink\" title=\"运行镜像\"></a>运行镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 3000:3000 my-node-app</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧱-五、使用-Docker-Compose-管理多个服务\"><a href=\"#🧱-五、使用-Docker-Compose-管理多个服务\" class=\"headerlink\" title=\"🧱 五、使用 Docker Compose 管理多个服务\"></a>🧱 五、使用 Docker Compose 管理多个服务</h2><p><code>docker-compose.yml</code> 示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:80&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">.</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;3000:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">.:/app</span></span><br></pre></td></tr></table></figure>\n\n<p>运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<p>关闭：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose down</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"🧯-六、常见问题与排查\"><a href=\"#🧯-六、常见问题与排查\" class=\"headerlink\" title=\"🧯 六、常见问题与排查\"></a>🧯 六、常见问题与排查</h2><h3 id=\"❓-Docker-无法启动\"><a href=\"#❓-Docker-无法启动\" class=\"headerlink\" title=\"❓ Docker 无法启动\"></a>❓ Docker 无法启动</h3><ul>\n<li>检查是否有虚拟化支持（BIOS 中开启 VT）</li>\n<li>macOS&#x2F;Windows 重启 Docker Desktop</li>\n</ul>\n<h3 id=\"❓-端口无法访问？\"><a href=\"#❓-端口无法访问？\" class=\"headerlink\" title=\"❓ 端口无法访问？\"></a>❓ 端口无法访问？</h3><ul>\n<li>确认端口映射正确</li>\n<li>本地防火墙是否阻止</li>\n<li>用 <code>docker logs 容器ID</code> 查看日志</li>\n</ul>\n<h3 id=\"❓-容器运行后秒退？\"><a href=\"#❓-容器运行后秒退？\" class=\"headerlink\" title=\"❓ 容器运行后秒退？\"></a>❓ 容器运行后秒退？</h3><ul>\n<li>使用 <code>docker logs 容器ID</code> 检查错误日志</li>\n<li>某些服务（如 Node）可能需要前台运行 (<code>CMD [&quot;npm&quot;, &quot;start&quot;]</code>)</li>\n</ul>\n<hr>\n<h2 id=\"📚-七、学习资源推荐\"><a href=\"#📚-七、学习资源推荐\" class=\"headerlink\" title=\"📚 七、学习资源推荐\"></a>📚 七、学习资源推荐</h2><ul>\n<li>Docker 官网：<a href=\"https://www.docker.com/\">https://www.docker.com/</a></li>\n<li>Docker 中文文档：<a href=\"https://docs.docker.com/get-started/\">https://docs.docker.com/get-started/</a></li>\n<li>镜像仓库：<a href=\"https://hub.docker.com/\">https://hub.docker.com/</a></li>\n<li>《Docker — 从入门到实践》：<a href=\"https://yeasy.gitbook.io/docker_practice/\">https://yeasy.gitbook.io/docker_practice/</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>📌 本文适合 2025 年 Docker 主流版本，如有问题欢迎留言交流。</p>\n<p>作者：<strong>[937bb]</strong>｜转载请注明出处 🙏</p>\n</blockquote>\n"},{"title":"🐳 Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战","date":"2025-06-07T04:58:00.000Z","top_img":"/images/post/docker/docker.jpg","cover":"/images/post/docker/docker.jpg","abbrlink":51177,"_content":"\n# 🐳 确保你的服务“准备好了”再启动 - `depends_on` 与 `healthcheck` 联动！\n\n嗨！欢迎回到 Docker Compose 学习之旅！前几章，我们学会了如何描述单个服务（`services` 下的字段），如何定义项目的整体结构和共享资源（顶层 `version`, `volumes`, `networks`），以及如何使用命令（`up`, `down`, `logs` 等）来操作你的应用栈。\n\n现在，你的应用栈可能不仅仅是一个孤立的服务了，它可能包含一个需要数据库的后端 API，或者一个依赖后端 API 的前端。服务之间是有**依赖关系**的！我们之前在 `services` 字段中介绍了 `depends_on` 来处理启动顺序。\n\n但是，这里有一个陷阱！默认的 `depends_on` 只能保证依赖的容器**启动**了（里面的主进程跑起来了），它并不能保证容器里运行的**应用**已经“准备好了”（比如数据库开始监听连接、Web 服务器能响应请求了）。如果你的应用在依赖的服务还没完全就绪时就开始尝试连接，很可能会启动失败！\n\n今天，我们就来深入探讨如何结合 `depends_on` 和 `healthcheck` 这两个字段，确保你的服务在启动时，它依赖的服务不仅启动了，而且已经“健康”地准备就绪了！\n\n---\n\n## 🤔 回顾 `depends_on` 的“局限性”\n\n我们之前在第一章讲 `depends_on` 时举了一个例子：\n\n```yaml\nservices:\n  web: # 你的后端 API 服务\n    image: my-backend-api\n    depends_on:\n      - db # web 服务依赖 db 服务\n\n  db: # 你的数据库服务\n    image: mysql:5.7\n    # db 没有 depends_on，会先启动\n```\n\n当你运行 `docker-compose up` 时，Docker Compose 会先启动 `db` 服务，**然后**启动 `web` 服务。这听起来很合理，后端当然需要数据库先启动嘛！\n\n**然而，问题在于：** Docker Compose 默认只等 `db` 容器里的主进程（也就是 MySQL 的启动进程）跑起来，就认为 `db` 服务“启动成功”了，然后立即开始启动 `web` 服务。\n\n但 MySQL 进程启动后，可能还需要一些时间来完成初始化、加载数据、开启网络端口监听等。如果在 `web` 容器启动的那一刻，MySQL 还没完全准备好接受连接，`web` 服务尝试连接数据库时就会失败，导致 `web` 容器启动失败或进入重启循环！\n\n这就是默认 `depends_on` 的局限性：**它只管容器的启动状态，不管容器里应用的就绪状态。**\n\n---\n\n## ❤️ 再看 `healthcheck`：判断服务是否“健康”的体检员\n\n还记得第一章讲的 `healthcheck` 吗？它的作用是定义一个检查机制，周期性地运行一个命令或脚本，来判断容器里运行的**应用**是否真的“健康”（能正常工作）。\n\n```yaml\nservices:\n  db:\n    image: mysql:5.7\n    healthcheck:\n      # test: 检查命令。这里用 mysqladmin ping 来检查数据库是否响应\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"] # CMD 格式\n      # 或者使用 CMD-SHELL 格式，更灵活，但要注意 shell 语法和路径\n      # test: [\"CMD-SHELL\", \"mysqladmin ping -h localhost || exit 1\"]\n      interval: 10s # 每隔 10 秒检查一次\n      timeout: 5s   # 每次检查最多等 5 秒\n      retries: 5    # 连续失败 5 次后标记为 unhealthy\n      start_period: 30s # 容器启动后 30 秒内失败不算 retries (给应用一些启动时间)\n    # ... 其他 db 配置 ...\n```\n\n配置了 `healthcheck` 后，Docker (以及 Docker Compose) 就会知道 `db` 服务不仅仅是进程在跑，它还会根据你的 `test` 命令的返回结果来判断服务是 `starting` (正在健康检查)、`healthy` (健康) 还是 `unhealthy` (不健康)。\n\n**`healthcheck` 解决了“就绪状态”的判断问题，但默认情况下，`depends_on` 并不理会这个健康状态！** 它仍然只等待容器启动。\n\n---\n\n## 🤝 完美组合：`depends_on` + `condition: service_healthy`\n\n既然 `depends_on` 需要等待依赖的服务真正“就绪”，而 `healthcheck` 正好提供了“就绪”状态的判断，那么把它们结合起来不就行了吗？\n\nDocker Compose 在 `version 2.1` 及更高版本中，为 `depends_on` 引入了更灵活的写法，不再是简单的列表，而是一个字典（map），可以指定依赖的**条件 (condition)**。\n\n最常用的条件就是 `service_healthy`！\n\n```yaml\nversion: '3.8' # 确保你的 version 是 2.1 或更高\n\nservices:\n  web: # 你的后端 API 服务\n    image: my-backend-api\n    depends_on:\n      # 这里不再是简单的列表，而是一个字典\n      db: # 依赖 db 服务\n        # condition: 指定依赖的条件\n        condition: service_healthy # 条件是：db 服务必须处于 'healthy' 状态\n\n    # ... 其他 web 配置 ...\n\n  db: # 你的数据库服务\n    image: mysql:5.7\n    # **重要！** 如果 web 依赖 db 的 healthy 状态，那么 db 服务必须配置 healthcheck！\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n      start_period: 30s\n    # ... 其他 db 配置 ...\n```\n\n*   **作用**：这种写法告诉 Docker Compose：“**在启动 `web` 服务之前，不仅要等 `db` 容器启动，还要等 `db` 容器的健康检查状态变成 `healthy` 之后，才能启动 `web` 服务！**”\n*   **流程**：当你运行 `docker-compose up` 时：\n    1.  Docker Compose 先尝试启动 `db` 容器。\n    2.  `db` 容器启动后，Docker 开始执行它的 `healthcheck`。\n    3.  同时，Docker Compose 知道 `web` 依赖 `db` 的 `service_healthy` 状态，它会等待 `db` 的健康检查结果。\n    4.  只有当 `db` 的健康检查连续成功达到阈值，状态变为 `healthy` 时，Docker Compose 才会继续创建并启动 `web` 容器。\n    5.  这样，当 `web` 服务启动时，它所依赖的数据库就 Guaranteed (保证) 是已经就绪并可以接受连接的了！\n\n*   **适合场景**：\n    *   任何需要连接数据库的应用服务 (后端 API, CMS, etc.)。\n    *   依赖于消息队列、缓存 (Redis, RabbitMQ)、其他微服务的应用服务。\n    *   需要确保依赖的基础设施服务 (如网关、配置中心) 已经完全启动并可用的场景。\n\n---\n\n## 📚 其他 `depends_on` 条件\n\n除了 `service_healthy`，`depends_on` 还支持其他条件，但 `service_healthy` 是处理服务就绪依赖最推荐的方式：\n\n*   `condition: service_started` (默认行为)：依赖的容器已经启动（进程已运行）。\n*   `condition: service_completed_successfully`：依赖的容器已运行完成并成功退出（状态码为 0）。这个条件主要用于一次性任务的容器（Job Containers），比如数据库迁移脚本，你可以让应用服务依赖于迁移脚本成功完成后再启动。\n\n```yaml\nservices:\n  migrate: # 数据库迁移服务\n    image: my-migration-tool\n    # ... 配置运行迁移脚本 ...\n    # 它会运行一次然后退出\n\n  app:\n    image: my-backend-api\n    depends_on:\n      migrate:\n        condition: service_completed_successfully # 等待 migrate 容器成功完成\n      db:\n        condition: service_healthy # 等待 db 容器健康\n    # ... 其他 app 配置 ...\n\n  db:\n    image: mysql:5.7\n    healthcheck:\n      # ... db 健康检查配置 ...\n    # ... 其他 db 配置 ...\n```\n\n**大部分情况下，`condition: service_healthy` 是你在构建多服务应用栈时最需要掌握和使用的依赖条件！**\n\n---\n\n## ✏️ 编写有效的 Healthcheck\n\n既然 `healthcheck` 对于实现 `service_healthy` 依赖至关重要，那么如何写好健康检查命令呢？\n\n*   **检查应用本身，而不是容器进程**：简单的 `exit 0` 或者检查容器进程是否运行都没用，你需要检查你的应用是否能正常响应请求或执行关键操作。\n*   **使用轻量级命令**：检查命令应该快速、开销小，不要执行耗时的操作。\n*   **根据服务类型选择命令**：\n    *   **Web/API 服务**：使用 `curl` 或 `wget` 访问一个专门的健康检查接口 (如 `/health`, `/status`)。这个接口应该检查内部依赖 (数据库连接、缓存连接等)。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:你的端口/healthz\"] # -f 参数让 curl 在非 2xx/3xx 状态码时失败\n          interval: 15s\n          timeout: 5s\n          retries: 3\n        ```\n    *   **数据库服务**：使用数据库客户端自带的工具，如 `mysqladmin ping`, `pg_isready`。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-P你的端口\"] # 检查 MySQL\n          # test: [\"CMD-SHELL\", \"pg_isready -U 你的用户 -d 你的数据库名\"] # 检查 PostgreSQL\n          interval: 10s\n          timeout: 5s\n          retries: 5\n        ```\n    *   **缓存服务**：使用客户端命令，如 `redis-cli ping`。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"redis-cli\", \"ping\"]\n          interval: 5s\n          timeout: 3s\n          retries: 3\n        ```\n*   **考虑 `start_period`**：给应用一个合理的启动时间，避免在应用还没完全启动好时就被健康检查标记为失败。\n\n---\n\n## 🚧 潜在问题与注意事项\n\n*   **循环依赖**：服务 A 依赖服务 B，同时服务 B 依赖服务 A，这是不允许的，会导致 Docker Compose 无法决定启动顺序。\n*   **健康检查不准确**：一个糟糕的 `healthcheck` 可能导致服务被错误地标记为健康或不健康，影响依赖服务的启动。确保你的检查命令真正反映了服务的可用性。\n*   **所有依赖都需要配置 `healthcheck`**：如果你使用 `condition: service_healthy`，那么你所依赖的所有服务都必须配置 `healthcheck` 字段，否则 Docker Compose 会报错。\n\n---\n\n## 总结一下，让服务优雅地按顺序启动的关键：\n\n1.  识别服务间的依赖关系。\n2.  对于需要等待依赖服务“准备就绪”的服务，配置 `depends_on` 为字典格式，使用 `condition: service_healthy`。\n3.  对于被依赖的服务，必须配置有效的 `healthcheck`。\n\n通过这种方式，你可以构建出更健壮、启动更可靠的多服务应用栈！\n\n---\n\n**本章小结**\n\n我们深入探讨了 `depends_on` 和 `healthcheck` 的结合使用，解决了服务启动时的“就绪”问题：\n*   默认 `depends_on` 只等待容器启动，不等待应用就绪。\n*   `healthcheck` 用于判断应用的健康状态。\n*   通过 `depends_on: service_name: { condition: service_healthy }` 语法，可以强制 Docker Compose 等待依赖的服务达到 `healthy` 状态后再启动当前服务。\n*   学习了如何编写有效的 `healthcheck` 命令。\n\n现在，你的 Docker Compose 文件已经能够表达复杂的服务依赖关系了！接下来，我们将转向如何更灵活地管理配置信息，特别是环境变量，以及如何使用 Docker Compose 来轻松切换不同的运行环境（开发、测试、生产）。这将在下一章“环境变量与多环境管理”中讲解！敬请期待！","source":"_posts/Docker/Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战.md","raw":"---\ntitle: \"\\U0001F433 Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战\"\ndate: '2025-06-07 12:58'\ntop_img: /images/post/docker/docker.jpg\ncover: /images/post/docker/docker.jpg\ncategories:\n  - Docker\ntags:\n  - Docker\n  - 教程\nabbrlink: 51177\n---\n\n# 🐳 确保你的服务“准备好了”再启动 - `depends_on` 与 `healthcheck` 联动！\n\n嗨！欢迎回到 Docker Compose 学习之旅！前几章，我们学会了如何描述单个服务（`services` 下的字段），如何定义项目的整体结构和共享资源（顶层 `version`, `volumes`, `networks`），以及如何使用命令（`up`, `down`, `logs` 等）来操作你的应用栈。\n\n现在，你的应用栈可能不仅仅是一个孤立的服务了，它可能包含一个需要数据库的后端 API，或者一个依赖后端 API 的前端。服务之间是有**依赖关系**的！我们之前在 `services` 字段中介绍了 `depends_on` 来处理启动顺序。\n\n但是，这里有一个陷阱！默认的 `depends_on` 只能保证依赖的容器**启动**了（里面的主进程跑起来了），它并不能保证容器里运行的**应用**已经“准备好了”（比如数据库开始监听连接、Web 服务器能响应请求了）。如果你的应用在依赖的服务还没完全就绪时就开始尝试连接，很可能会启动失败！\n\n今天，我们就来深入探讨如何结合 `depends_on` 和 `healthcheck` 这两个字段，确保你的服务在启动时，它依赖的服务不仅启动了，而且已经“健康”地准备就绪了！\n\n---\n\n## 🤔 回顾 `depends_on` 的“局限性”\n\n我们之前在第一章讲 `depends_on` 时举了一个例子：\n\n```yaml\nservices:\n  web: # 你的后端 API 服务\n    image: my-backend-api\n    depends_on:\n      - db # web 服务依赖 db 服务\n\n  db: # 你的数据库服务\n    image: mysql:5.7\n    # db 没有 depends_on，会先启动\n```\n\n当你运行 `docker-compose up` 时，Docker Compose 会先启动 `db` 服务，**然后**启动 `web` 服务。这听起来很合理，后端当然需要数据库先启动嘛！\n\n**然而，问题在于：** Docker Compose 默认只等 `db` 容器里的主进程（也就是 MySQL 的启动进程）跑起来，就认为 `db` 服务“启动成功”了，然后立即开始启动 `web` 服务。\n\n但 MySQL 进程启动后，可能还需要一些时间来完成初始化、加载数据、开启网络端口监听等。如果在 `web` 容器启动的那一刻，MySQL 还没完全准备好接受连接，`web` 服务尝试连接数据库时就会失败，导致 `web` 容器启动失败或进入重启循环！\n\n这就是默认 `depends_on` 的局限性：**它只管容器的启动状态，不管容器里应用的就绪状态。**\n\n---\n\n## ❤️ 再看 `healthcheck`：判断服务是否“健康”的体检员\n\n还记得第一章讲的 `healthcheck` 吗？它的作用是定义一个检查机制，周期性地运行一个命令或脚本，来判断容器里运行的**应用**是否真的“健康”（能正常工作）。\n\n```yaml\nservices:\n  db:\n    image: mysql:5.7\n    healthcheck:\n      # test: 检查命令。这里用 mysqladmin ping 来检查数据库是否响应\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"] # CMD 格式\n      # 或者使用 CMD-SHELL 格式，更灵活，但要注意 shell 语法和路径\n      # test: [\"CMD-SHELL\", \"mysqladmin ping -h localhost || exit 1\"]\n      interval: 10s # 每隔 10 秒检查一次\n      timeout: 5s   # 每次检查最多等 5 秒\n      retries: 5    # 连续失败 5 次后标记为 unhealthy\n      start_period: 30s # 容器启动后 30 秒内失败不算 retries (给应用一些启动时间)\n    # ... 其他 db 配置 ...\n```\n\n配置了 `healthcheck` 后，Docker (以及 Docker Compose) 就会知道 `db` 服务不仅仅是进程在跑，它还会根据你的 `test` 命令的返回结果来判断服务是 `starting` (正在健康检查)、`healthy` (健康) 还是 `unhealthy` (不健康)。\n\n**`healthcheck` 解决了“就绪状态”的判断问题，但默认情况下，`depends_on` 并不理会这个健康状态！** 它仍然只等待容器启动。\n\n---\n\n## 🤝 完美组合：`depends_on` + `condition: service_healthy`\n\n既然 `depends_on` 需要等待依赖的服务真正“就绪”，而 `healthcheck` 正好提供了“就绪”状态的判断，那么把它们结合起来不就行了吗？\n\nDocker Compose 在 `version 2.1` 及更高版本中，为 `depends_on` 引入了更灵活的写法，不再是简单的列表，而是一个字典（map），可以指定依赖的**条件 (condition)**。\n\n最常用的条件就是 `service_healthy`！\n\n```yaml\nversion: '3.8' # 确保你的 version 是 2.1 或更高\n\nservices:\n  web: # 你的后端 API 服务\n    image: my-backend-api\n    depends_on:\n      # 这里不再是简单的列表，而是一个字典\n      db: # 依赖 db 服务\n        # condition: 指定依赖的条件\n        condition: service_healthy # 条件是：db 服务必须处于 'healthy' 状态\n\n    # ... 其他 web 配置 ...\n\n  db: # 你的数据库服务\n    image: mysql:5.7\n    # **重要！** 如果 web 依赖 db 的 healthy 状态，那么 db 服务必须配置 healthcheck！\n    healthcheck:\n      test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n      start_period: 30s\n    # ... 其他 db 配置 ...\n```\n\n*   **作用**：这种写法告诉 Docker Compose：“**在启动 `web` 服务之前，不仅要等 `db` 容器启动，还要等 `db` 容器的健康检查状态变成 `healthy` 之后，才能启动 `web` 服务！**”\n*   **流程**：当你运行 `docker-compose up` 时：\n    1.  Docker Compose 先尝试启动 `db` 容器。\n    2.  `db` 容器启动后，Docker 开始执行它的 `healthcheck`。\n    3.  同时，Docker Compose 知道 `web` 依赖 `db` 的 `service_healthy` 状态，它会等待 `db` 的健康检查结果。\n    4.  只有当 `db` 的健康检查连续成功达到阈值，状态变为 `healthy` 时，Docker Compose 才会继续创建并启动 `web` 容器。\n    5.  这样，当 `web` 服务启动时，它所依赖的数据库就 Guaranteed (保证) 是已经就绪并可以接受连接的了！\n\n*   **适合场景**：\n    *   任何需要连接数据库的应用服务 (后端 API, CMS, etc.)。\n    *   依赖于消息队列、缓存 (Redis, RabbitMQ)、其他微服务的应用服务。\n    *   需要确保依赖的基础设施服务 (如网关、配置中心) 已经完全启动并可用的场景。\n\n---\n\n## 📚 其他 `depends_on` 条件\n\n除了 `service_healthy`，`depends_on` 还支持其他条件，但 `service_healthy` 是处理服务就绪依赖最推荐的方式：\n\n*   `condition: service_started` (默认行为)：依赖的容器已经启动（进程已运行）。\n*   `condition: service_completed_successfully`：依赖的容器已运行完成并成功退出（状态码为 0）。这个条件主要用于一次性任务的容器（Job Containers），比如数据库迁移脚本，你可以让应用服务依赖于迁移脚本成功完成后再启动。\n\n```yaml\nservices:\n  migrate: # 数据库迁移服务\n    image: my-migration-tool\n    # ... 配置运行迁移脚本 ...\n    # 它会运行一次然后退出\n\n  app:\n    image: my-backend-api\n    depends_on:\n      migrate:\n        condition: service_completed_successfully # 等待 migrate 容器成功完成\n      db:\n        condition: service_healthy # 等待 db 容器健康\n    # ... 其他 app 配置 ...\n\n  db:\n    image: mysql:5.7\n    healthcheck:\n      # ... db 健康检查配置 ...\n    # ... 其他 db 配置 ...\n```\n\n**大部分情况下，`condition: service_healthy` 是你在构建多服务应用栈时最需要掌握和使用的依赖条件！**\n\n---\n\n## ✏️ 编写有效的 Healthcheck\n\n既然 `healthcheck` 对于实现 `service_healthy` 依赖至关重要，那么如何写好健康检查命令呢？\n\n*   **检查应用本身，而不是容器进程**：简单的 `exit 0` 或者检查容器进程是否运行都没用，你需要检查你的应用是否能正常响应请求或执行关键操作。\n*   **使用轻量级命令**：检查命令应该快速、开销小，不要执行耗时的操作。\n*   **根据服务类型选择命令**：\n    *   **Web/API 服务**：使用 `curl` 或 `wget` 访问一个专门的健康检查接口 (如 `/health`, `/status`)。这个接口应该检查内部依赖 (数据库连接、缓存连接等)。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:你的端口/healthz\"] # -f 参数让 curl 在非 2xx/3xx 状态码时失败\n          interval: 15s\n          timeout: 5s\n          retries: 3\n        ```\n    *   **数据库服务**：使用数据库客户端自带的工具，如 `mysqladmin ping`, `pg_isready`。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"mysqladmin\", \"ping\", \"-h\", \"localhost\", \"-P你的端口\"] # 检查 MySQL\n          # test: [\"CMD-SHELL\", \"pg_isready -U 你的用户 -d 你的数据库名\"] # 检查 PostgreSQL\n          interval: 10s\n          timeout: 5s\n          retries: 5\n        ```\n    *   **缓存服务**：使用客户端命令，如 `redis-cli ping`。\n        ```yaml\n        healthcheck:\n          test: [\"CMD\", \"redis-cli\", \"ping\"]\n          interval: 5s\n          timeout: 3s\n          retries: 3\n        ```\n*   **考虑 `start_period`**：给应用一个合理的启动时间，避免在应用还没完全启动好时就被健康检查标记为失败。\n\n---\n\n## 🚧 潜在问题与注意事项\n\n*   **循环依赖**：服务 A 依赖服务 B，同时服务 B 依赖服务 A，这是不允许的，会导致 Docker Compose 无法决定启动顺序。\n*   **健康检查不准确**：一个糟糕的 `healthcheck` 可能导致服务被错误地标记为健康或不健康，影响依赖服务的启动。确保你的检查命令真正反映了服务的可用性。\n*   **所有依赖都需要配置 `healthcheck`**：如果你使用 `condition: service_healthy`，那么你所依赖的所有服务都必须配置 `healthcheck` 字段，否则 Docker Compose 会报错。\n\n---\n\n## 总结一下，让服务优雅地按顺序启动的关键：\n\n1.  识别服务间的依赖关系。\n2.  对于需要等待依赖服务“准备就绪”的服务，配置 `depends_on` 为字典格式，使用 `condition: service_healthy`。\n3.  对于被依赖的服务，必须配置有效的 `healthcheck`。\n\n通过这种方式，你可以构建出更健壮、启动更可靠的多服务应用栈！\n\n---\n\n**本章小结**\n\n我们深入探讨了 `depends_on` 和 `healthcheck` 的结合使用，解决了服务启动时的“就绪”问题：\n*   默认 `depends_on` 只等待容器启动，不等待应用就绪。\n*   `healthcheck` 用于判断应用的健康状态。\n*   通过 `depends_on: service_name: { condition: service_healthy }` 语法，可以强制 Docker Compose 等待依赖的服务达到 `healthy` 状态后再启动当前服务。\n*   学习了如何编写有效的 `healthcheck` 命令。\n\n现在，你的 Docker Compose 文件已经能够表达复杂的服务依赖关系了！接下来，我们将转向如何更灵活地管理配置信息，特别是环境变量，以及如何使用 Docker Compose 来轻松切换不同的运行环境（开发、测试、生产）。这将在下一章“环境变量与多环境管理”中讲解！敬请期待！","slug":"Docker/Docker Compose 进阶应用篇（四）：服务依赖与健康检查实战","published":1,"updated":"2025-06-07T15:58:53.664Z","comments":1,"layout":"post","photos":[],"_id":"cmbmfzwwd001rpkrc1i6v44dl","content":"<h1 id=\"🐳-确保你的服务“准备好了”再启动-depends-on-与-healthcheck-联动！\"><a href=\"#🐳-确保你的服务“准备好了”再启动-depends-on-与-healthcheck-联动！\" class=\"headerlink\" title=\"🐳 确保你的服务“准备好了”再启动 - depends_on 与 healthcheck 联动！\"></a>🐳 确保你的服务“准备好了”再启动 - <code>depends_on</code> 与 <code>healthcheck</code> 联动！</h1><p>嗨！欢迎回到 Docker Compose 学习之旅！前几章，我们学会了如何描述单个服务（<code>services</code> 下的字段），如何定义项目的整体结构和共享资源（顶层 <code>version</code>, <code>volumes</code>, <code>networks</code>），以及如何使用命令（<code>up</code>, <code>down</code>, <code>logs</code> 等）来操作你的应用栈。</p>\n<p>现在，你的应用栈可能不仅仅是一个孤立的服务了，它可能包含一个需要数据库的后端 API，或者一个依赖后端 API 的前端。服务之间是有<strong>依赖关系</strong>的！我们之前在 <code>services</code> 字段中介绍了 <code>depends_on</code> 来处理启动顺序。</p>\n<p>但是，这里有一个陷阱！默认的 <code>depends_on</code> 只能保证依赖的容器<strong>启动</strong>了（里面的主进程跑起来了），它并不能保证容器里运行的<strong>应用</strong>已经“准备好了”（比如数据库开始监听连接、Web 服务器能响应请求了）。如果你的应用在依赖的服务还没完全就绪时就开始尝试连接，很可能会启动失败！</p>\n<p>今天，我们就来深入探讨如何结合 <code>depends_on</code> 和 <code>healthcheck</code> 这两个字段，确保你的服务在启动时，它依赖的服务不仅启动了，而且已经“健康”地准备就绪了！</p>\n<hr>\n<h2 id=\"🤔-回顾-depends-on-的“局限性”\"><a href=\"#🤔-回顾-depends-on-的“局限性”\" class=\"headerlink\" title=\"🤔 回顾 depends_on 的“局限性”\"></a>🤔 回顾 <code>depends_on</code> 的“局限性”</h2><p>我们之前在第一章讲 <code>depends_on</code> 时举了一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span> <span class=\"comment\"># 你的后端 API 服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span> <span class=\"comment\"># web 服务依赖 db 服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 你的数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># db 没有 depends_on，会先启动</span></span><br></pre></td></tr></table></figure>\n\n<p>当你运行 <code>docker-compose up</code> 时，Docker Compose 会先启动 <code>db</code> 服务，<strong>然后</strong>启动 <code>web</code> 服务。这听起来很合理，后端当然需要数据库先启动嘛！</p>\n<p><strong>然而，问题在于：</strong> Docker Compose 默认只等 <code>db</code> 容器里的主进程（也就是 MySQL 的启动进程）跑起来，就认为 <code>db</code> 服务“启动成功”了，然后立即开始启动 <code>web</code> 服务。</p>\n<p>但 MySQL 进程启动后，可能还需要一些时间来完成初始化、加载数据、开启网络端口监听等。如果在 <code>web</code> 容器启动的那一刻，MySQL 还没完全准备好接受连接，<code>web</code> 服务尝试连接数据库时就会失败，导致 <code>web</code> 容器启动失败或进入重启循环！</p>\n<p>这就是默认 <code>depends_on</code> 的局限性：<strong>它只管容器的启动状态，不管容器里应用的就绪状态。</strong></p>\n<hr>\n<h2 id=\"❤️-再看-healthcheck：判断服务是否“健康”的体检员\"><a href=\"#❤️-再看-healthcheck：判断服务是否“健康”的体检员\" class=\"headerlink\" title=\"❤️ 再看 healthcheck：判断服务是否“健康”的体检员\"></a>❤️ 再看 <code>healthcheck</code>：判断服务是否“健康”的体检员</h2><p>还记得第一章讲的 <code>healthcheck</code> 吗？它的作用是定义一个检查机制，周期性地运行一个命令或脚本，来判断容器里运行的<strong>应用</strong>是否真的“健康”（能正常工作）。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># test: 检查命令。这里用 mysqladmin ping 来检查数据库是否响应</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>] <span class=\"comment\"># CMD 格式</span></span><br><span class=\"line\">      <span class=\"comment\"># 或者使用 CMD-SHELL 格式，更灵活，但要注意 shell 语法和路径</span></span><br><span class=\"line\">      <span class=\"comment\"># test: [&quot;CMD-SHELL&quot;, &quot;mysqladmin ping -h localhost || exit 1&quot;]</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每隔 10 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 每次检查最多等 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span>    <span class=\"comment\"># 连续失败 5 次后标记为 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span> <span class=\"comment\"># 容器启动后 30 秒内失败不算 retries (给应用一些启动时间)</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<p>配置了 <code>healthcheck</code> 后，Docker (以及 Docker Compose) 就会知道 <code>db</code> 服务不仅仅是进程在跑，它还会根据你的 <code>test</code> 命令的返回结果来判断服务是 <code>starting</code> (正在健康检查)、<code>healthy</code> (健康) 还是 <code>unhealthy</code> (不健康)。</p>\n<p><strong><code>healthcheck</code> 解决了“就绪状态”的判断问题，但默认情况下，<code>depends_on</code> 并不理会这个健康状态！</strong> 它仍然只等待容器启动。</p>\n<hr>\n<h2 id=\"🤝-完美组合：depends-on-condition-service-healthy\"><a href=\"#🤝-完美组合：depends-on-condition-service-healthy\" class=\"headerlink\" title=\"🤝 完美组合：depends_on + condition: service_healthy\"></a>🤝 完美组合：<code>depends_on</code> + <code>condition: service_healthy</code></h2><p>既然 <code>depends_on</code> 需要等待依赖的服务真正“就绪”，而 <code>healthcheck</code> 正好提供了“就绪”状态的判断，那么把它们结合起来不就行了吗？</p>\n<p>Docker Compose 在 <code>version 2.1</code> 及更高版本中，为 <code>depends_on</code> 引入了更灵活的写法，不再是简单的列表，而是一个字典（map），可以指定依赖的<strong>条件 (condition)</strong>。</p>\n<p>最常用的条件就是 <code>service_healthy</code>！</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 确保你的 version 是 2.1 或更高</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span> <span class=\"comment\"># 你的后端 API 服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 这里不再是简单的列表，而是一个字典</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span> <span class=\"comment\"># 依赖 db 服务</span></span><br><span class=\"line\">        <span class=\"comment\"># condition: 指定依赖的条件</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 条件是：db 服务必须处于 &#x27;healthy&#x27; 状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 web 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 你的数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># **重要！** 如果 web 依赖 db 的 healthy 状态，那么 db 服务必须配置 healthcheck！</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>作用</strong>：这种写法告诉 Docker Compose：“<strong>在启动 <code>web</code> 服务之前，不仅要等 <code>db</code> 容器启动，还要等 <code>db</code> 容器的健康检查状态变成 <code>healthy</code> 之后，才能启动 <code>web</code> 服务！</strong>”</p>\n</li>\n<li><p><strong>流程</strong>：当你运行 <code>docker-compose up</code> 时：</p>\n<ol>\n<li>Docker Compose 先尝试启动 <code>db</code> 容器。</li>\n<li><code>db</code> 容器启动后，Docker 开始执行它的 <code>healthcheck</code>。</li>\n<li>同时，Docker Compose 知道 <code>web</code> 依赖 <code>db</code> 的 <code>service_healthy</code> 状态，它会等待 <code>db</code> 的健康检查结果。</li>\n<li>只有当 <code>db</code> 的健康检查连续成功达到阈值，状态变为 <code>healthy</code> 时，Docker Compose 才会继续创建并启动 <code>web</code> 容器。</li>\n<li>这样，当 <code>web</code> 服务启动时，它所依赖的数据库就 Guaranteed (保证) 是已经就绪并可以接受连接的了！</li>\n</ol>\n</li>\n<li><p><strong>适合场景</strong>：</p>\n<ul>\n<li>任何需要连接数据库的应用服务 (后端 API, CMS, etc.)。</li>\n<li>依赖于消息队列、缓存 (Redis, RabbitMQ)、其他微服务的应用服务。</li>\n<li>需要确保依赖的基础设施服务 (如网关、配置中心) 已经完全启动并可用的场景。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📚-其他-depends-on-条件\"><a href=\"#📚-其他-depends-on-条件\" class=\"headerlink\" title=\"📚 其他 depends_on 条件\"></a>📚 其他 <code>depends_on</code> 条件</h2><p>除了 <code>service_healthy</code>，<code>depends_on</code> 还支持其他条件，但 <code>service_healthy</code> 是处理服务就绪依赖最推荐的方式：</p>\n<ul>\n<li><code>condition: service_started</code> (默认行为)：依赖的容器已经启动（进程已运行）。</li>\n<li><code>condition: service_completed_successfully</code>：依赖的容器已运行完成并成功退出（状态码为 0）。这个条件主要用于一次性任务的容器（Job Containers），比如数据库迁移脚本，你可以让应用服务依赖于迁移脚本成功完成后再启动。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">migrate:</span> <span class=\"comment\"># 数据库迁移服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-migration-tool</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 配置运行迁移脚本 ...</span></span><br><span class=\"line\">    <span class=\"comment\"># 它会运行一次然后退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">migrate:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_completed_successfully</span> <span class=\"comment\"># 等待 migrate 容器成功完成</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 db 容器健康</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 app 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># ... db 健康检查配置 ...</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>大部分情况下，<code>condition: service_healthy</code> 是你在构建多服务应用栈时最需要掌握和使用的依赖条件！</strong></p>\n<hr>\n<h2 id=\"✏️-编写有效的-Healthcheck\"><a href=\"#✏️-编写有效的-Healthcheck\" class=\"headerlink\" title=\"✏️ 编写有效的 Healthcheck\"></a>✏️ 编写有效的 Healthcheck</h2><p>既然 <code>healthcheck</code> 对于实现 <code>service_healthy</code> 依赖至关重要，那么如何写好健康检查命令呢？</p>\n<ul>\n<li><strong>检查应用本身，而不是容器进程</strong>：简单的 <code>exit 0</code> 或者检查容器进程是否运行都没用，你需要检查你的应用是否能正常响应请求或执行关键操作。</li>\n<li><strong>使用轻量级命令</strong>：检查命令应该快速、开销小，不要执行耗时的操作。</li>\n<li><strong>根据服务类型选择命令</strong>：<ul>\n<li><strong>Web&#x2F;API 服务</strong>：使用 <code>curl</code> 或 <code>wget</code> 访问一个专门的健康检查接口 (如 <code>/health</code>, <code>/status</code>)。这个接口应该检查内部依赖 (数据库连接、缓存连接等)。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:你的端口/healthz&quot;</span>] <span class=\"comment\"># -f 参数让 curl 在非 2xx/3xx 状态码时失败</span></span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">15s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>数据库服务</strong>：使用数据库客户端自带的工具，如 <code>mysqladmin ping</code>, <code>pg_isready</code>。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>, <span class=\"string\">&quot;-P你的端口&quot;</span>] <span class=\"comment\"># 检查 MySQL</span></span><br><span class=\"line\">  <span class=\"comment\"># test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U 你的用户 -d 你的数据库名&quot;] # 检查 PostgreSQL</span></span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>缓存服务</strong>：使用客户端命令，如 <code>redis-cli ping</code>。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;redis-cli&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>考虑 <code>start_period</code></strong>：给应用一个合理的启动时间，避免在应用还没完全启动好时就被健康检查标记为失败。</li>\n</ul>\n<hr>\n<h2 id=\"🚧-潜在问题与注意事项\"><a href=\"#🚧-潜在问题与注意事项\" class=\"headerlink\" title=\"🚧 潜在问题与注意事项\"></a>🚧 潜在问题与注意事项</h2><ul>\n<li><strong>循环依赖</strong>：服务 A 依赖服务 B，同时服务 B 依赖服务 A，这是不允许的，会导致 Docker Compose 无法决定启动顺序。</li>\n<li><strong>健康检查不准确</strong>：一个糟糕的 <code>healthcheck</code> 可能导致服务被错误地标记为健康或不健康，影响依赖服务的启动。确保你的检查命令真正反映了服务的可用性。</li>\n<li><strong>所有依赖都需要配置 <code>healthcheck</code></strong>：如果你使用 <code>condition: service_healthy</code>，那么你所依赖的所有服务都必须配置 <code>healthcheck</code> 字段，否则 Docker Compose 会报错。</li>\n</ul>\n<hr>\n<h2 id=\"总结一下，让服务优雅地按顺序启动的关键：\"><a href=\"#总结一下，让服务优雅地按顺序启动的关键：\" class=\"headerlink\" title=\"总结一下，让服务优雅地按顺序启动的关键：\"></a>总结一下，让服务优雅地按顺序启动的关键：</h2><ol>\n<li>识别服务间的依赖关系。</li>\n<li>对于需要等待依赖服务“准备就绪”的服务，配置 <code>depends_on</code> 为字典格式，使用 <code>condition: service_healthy</code>。</li>\n<li>对于被依赖的服务，必须配置有效的 <code>healthcheck</code>。</li>\n</ol>\n<p>通过这种方式，你可以构建出更健壮、启动更可靠的多服务应用栈！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们深入探讨了 <code>depends_on</code> 和 <code>healthcheck</code> 的结合使用，解决了服务启动时的“就绪”问题：</p>\n<ul>\n<li>默认 <code>depends_on</code> 只等待容器启动，不等待应用就绪。</li>\n<li><code>healthcheck</code> 用于判断应用的健康状态。</li>\n<li>通过 <code>depends_on: service_name: &#123; condition: service_healthy &#125;</code> 语法，可以强制 Docker Compose 等待依赖的服务达到 <code>healthy</code> 状态后再启动当前服务。</li>\n<li>学习了如何编写有效的 <code>healthcheck</code> 命令。</li>\n</ul>\n<p>现在，你的 Docker Compose 文件已经能够表达复杂的服务依赖关系了！接下来，我们将转向如何更灵活地管理配置信息，特别是环境变量，以及如何使用 Docker Compose 来轻松切换不同的运行环境（开发、测试、生产）。这将在下一章“环境变量与多环境管理”中讲解！敬请期待！</p>\n","cover_type":"img","excerpt":"","more":"<h1 id=\"🐳-确保你的服务“准备好了”再启动-depends-on-与-healthcheck-联动！\"><a href=\"#🐳-确保你的服务“准备好了”再启动-depends-on-与-healthcheck-联动！\" class=\"headerlink\" title=\"🐳 确保你的服务“准备好了”再启动 - depends_on 与 healthcheck 联动！\"></a>🐳 确保你的服务“准备好了”再启动 - <code>depends_on</code> 与 <code>healthcheck</code> 联动！</h1><p>嗨！欢迎回到 Docker Compose 学习之旅！前几章，我们学会了如何描述单个服务（<code>services</code> 下的字段），如何定义项目的整体结构和共享资源（顶层 <code>version</code>, <code>volumes</code>, <code>networks</code>），以及如何使用命令（<code>up</code>, <code>down</code>, <code>logs</code> 等）来操作你的应用栈。</p>\n<p>现在，你的应用栈可能不仅仅是一个孤立的服务了，它可能包含一个需要数据库的后端 API，或者一个依赖后端 API 的前端。服务之间是有<strong>依赖关系</strong>的！我们之前在 <code>services</code> 字段中介绍了 <code>depends_on</code> 来处理启动顺序。</p>\n<p>但是，这里有一个陷阱！默认的 <code>depends_on</code> 只能保证依赖的容器<strong>启动</strong>了（里面的主进程跑起来了），它并不能保证容器里运行的<strong>应用</strong>已经“准备好了”（比如数据库开始监听连接、Web 服务器能响应请求了）。如果你的应用在依赖的服务还没完全就绪时就开始尝试连接，很可能会启动失败！</p>\n<p>今天，我们就来深入探讨如何结合 <code>depends_on</code> 和 <code>healthcheck</code> 这两个字段，确保你的服务在启动时，它依赖的服务不仅启动了，而且已经“健康”地准备就绪了！</p>\n<hr>\n<h2 id=\"🤔-回顾-depends-on-的“局限性”\"><a href=\"#🤔-回顾-depends-on-的“局限性”\" class=\"headerlink\" title=\"🤔 回顾 depends_on 的“局限性”\"></a>🤔 回顾 <code>depends_on</code> 的“局限性”</h2><p>我们之前在第一章讲 <code>depends_on</code> 时举了一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span> <span class=\"comment\"># 你的后端 API 服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">db</span> <span class=\"comment\"># web 服务依赖 db 服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 你的数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># db 没有 depends_on，会先启动</span></span><br></pre></td></tr></table></figure>\n\n<p>当你运行 <code>docker-compose up</code> 时，Docker Compose 会先启动 <code>db</code> 服务，<strong>然后</strong>启动 <code>web</code> 服务。这听起来很合理，后端当然需要数据库先启动嘛！</p>\n<p><strong>然而，问题在于：</strong> Docker Compose 默认只等 <code>db</code> 容器里的主进程（也就是 MySQL 的启动进程）跑起来，就认为 <code>db</code> 服务“启动成功”了，然后立即开始启动 <code>web</code> 服务。</p>\n<p>但 MySQL 进程启动后，可能还需要一些时间来完成初始化、加载数据、开启网络端口监听等。如果在 <code>web</code> 容器启动的那一刻，MySQL 还没完全准备好接受连接，<code>web</code> 服务尝试连接数据库时就会失败，导致 <code>web</code> 容器启动失败或进入重启循环！</p>\n<p>这就是默认 <code>depends_on</code> 的局限性：<strong>它只管容器的启动状态，不管容器里应用的就绪状态。</strong></p>\n<hr>\n<h2 id=\"❤️-再看-healthcheck：判断服务是否“健康”的体检员\"><a href=\"#❤️-再看-healthcheck：判断服务是否“健康”的体检员\" class=\"headerlink\" title=\"❤️ 再看 healthcheck：判断服务是否“健康”的体检员\"></a>❤️ 再看 <code>healthcheck</code>：判断服务是否“健康”的体检员</h2><p>还记得第一章讲的 <code>healthcheck</code> 吗？它的作用是定义一个检查机制，周期性地运行一个命令或脚本，来判断容器里运行的<strong>应用</strong>是否真的“健康”（能正常工作）。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># test: 检查命令。这里用 mysqladmin ping 来检查数据库是否响应</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>] <span class=\"comment\"># CMD 格式</span></span><br><span class=\"line\">      <span class=\"comment\"># 或者使用 CMD-SHELL 格式，更灵活，但要注意 shell 语法和路径</span></span><br><span class=\"line\">      <span class=\"comment\"># test: [&quot;CMD-SHELL&quot;, &quot;mysqladmin ping -h localhost || exit 1&quot;]</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span> <span class=\"comment\"># 每隔 10 秒检查一次</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span>   <span class=\"comment\"># 每次检查最多等 5 秒</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span>    <span class=\"comment\"># 连续失败 5 次后标记为 unhealthy</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span> <span class=\"comment\"># 容器启动后 30 秒内失败不算 retries (给应用一些启动时间)</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<p>配置了 <code>healthcheck</code> 后，Docker (以及 Docker Compose) 就会知道 <code>db</code> 服务不仅仅是进程在跑，它还会根据你的 <code>test</code> 命令的返回结果来判断服务是 <code>starting</code> (正在健康检查)、<code>healthy</code> (健康) 还是 <code>unhealthy</code> (不健康)。</p>\n<p><strong><code>healthcheck</code> 解决了“就绪状态”的判断问题，但默认情况下，<code>depends_on</code> 并不理会这个健康状态！</strong> 它仍然只等待容器启动。</p>\n<hr>\n<h2 id=\"🤝-完美组合：depends-on-condition-service-healthy\"><a href=\"#🤝-完美组合：depends-on-condition-service-healthy\" class=\"headerlink\" title=\"🤝 完美组合：depends_on + condition: service_healthy\"></a>🤝 完美组合：<code>depends_on</code> + <code>condition: service_healthy</code></h2><p>既然 <code>depends_on</code> 需要等待依赖的服务真正“就绪”，而 <code>healthcheck</code> 正好提供了“就绪”状态的判断，那么把它们结合起来不就行了吗？</p>\n<p>Docker Compose 在 <code>version 2.1</code> 及更高版本中，为 <code>depends_on</code> 引入了更灵活的写法，不再是简单的列表，而是一个字典（map），可以指定依赖的<strong>条件 (condition)</strong>。</p>\n<p>最常用的条件就是 <code>service_healthy</code>！</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span> <span class=\"comment\"># 确保你的 version 是 2.1 或更高</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">web:</span> <span class=\"comment\"># 你的后端 API 服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"comment\"># 这里不再是简单的列表，而是一个字典</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span> <span class=\"comment\"># 依赖 db 服务</span></span><br><span class=\"line\">        <span class=\"comment\"># condition: 指定依赖的条件</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 条件是：db 服务必须处于 &#x27;healthy&#x27; 状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 web 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span> <span class=\"comment\"># 你的数据库服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"comment\"># **重要！** 如果 web 依赖 db 的 healthy 状态，那么 db 服务必须配置 healthcheck！</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>]</span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">      <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">      <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"attr\">start_period:</span> <span class=\"string\">30s</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>作用</strong>：这种写法告诉 Docker Compose：“<strong>在启动 <code>web</code> 服务之前，不仅要等 <code>db</code> 容器启动，还要等 <code>db</code> 容器的健康检查状态变成 <code>healthy</code> 之后，才能启动 <code>web</code> 服务！</strong>”</p>\n</li>\n<li><p><strong>流程</strong>：当你运行 <code>docker-compose up</code> 时：</p>\n<ol>\n<li>Docker Compose 先尝试启动 <code>db</code> 容器。</li>\n<li><code>db</code> 容器启动后，Docker 开始执行它的 <code>healthcheck</code>。</li>\n<li>同时，Docker Compose 知道 <code>web</code> 依赖 <code>db</code> 的 <code>service_healthy</code> 状态，它会等待 <code>db</code> 的健康检查结果。</li>\n<li>只有当 <code>db</code> 的健康检查连续成功达到阈值，状态变为 <code>healthy</code> 时，Docker Compose 才会继续创建并启动 <code>web</code> 容器。</li>\n<li>这样，当 <code>web</code> 服务启动时，它所依赖的数据库就 Guaranteed (保证) 是已经就绪并可以接受连接的了！</li>\n</ol>\n</li>\n<li><p><strong>适合场景</strong>：</p>\n<ul>\n<li>任何需要连接数据库的应用服务 (后端 API, CMS, etc.)。</li>\n<li>依赖于消息队列、缓存 (Redis, RabbitMQ)、其他微服务的应用服务。</li>\n<li>需要确保依赖的基础设施服务 (如网关、配置中心) 已经完全启动并可用的场景。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"📚-其他-depends-on-条件\"><a href=\"#📚-其他-depends-on-条件\" class=\"headerlink\" title=\"📚 其他 depends_on 条件\"></a>📚 其他 <code>depends_on</code> 条件</h2><p>除了 <code>service_healthy</code>，<code>depends_on</code> 还支持其他条件，但 <code>service_healthy</code> 是处理服务就绪依赖最推荐的方式：</p>\n<ul>\n<li><code>condition: service_started</code> (默认行为)：依赖的容器已经启动（进程已运行）。</li>\n<li><code>condition: service_completed_successfully</code>：依赖的容器已运行完成并成功退出（状态码为 0）。这个条件主要用于一次性任务的容器（Job Containers），比如数据库迁移脚本，你可以让应用服务依赖于迁移脚本成功完成后再启动。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">migrate:</span> <span class=\"comment\"># 数据库迁移服务</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-migration-tool</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 配置运行迁移脚本 ...</span></span><br><span class=\"line\">    <span class=\"comment\"># 它会运行一次然后退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">app:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">my-backend-api</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"attr\">migrate:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_completed_successfully</span> <span class=\"comment\"># 等待 migrate 容器成功完成</span></span><br><span class=\"line\">      <span class=\"attr\">db:</span></span><br><span class=\"line\">        <span class=\"attr\">condition:</span> <span class=\"string\">service_healthy</span> <span class=\"comment\"># 等待 db 容器健康</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 app 配置 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">db:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mysql:5.7</span></span><br><span class=\"line\">    <span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">      <span class=\"comment\"># ... db 健康检查配置 ...</span></span><br><span class=\"line\">    <span class=\"comment\"># ... 其他 db 配置 ...</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>大部分情况下，<code>condition: service_healthy</code> 是你在构建多服务应用栈时最需要掌握和使用的依赖条件！</strong></p>\n<hr>\n<h2 id=\"✏️-编写有效的-Healthcheck\"><a href=\"#✏️-编写有效的-Healthcheck\" class=\"headerlink\" title=\"✏️ 编写有效的 Healthcheck\"></a>✏️ 编写有效的 Healthcheck</h2><p>既然 <code>healthcheck</code> 对于实现 <code>service_healthy</code> 依赖至关重要，那么如何写好健康检查命令呢？</p>\n<ul>\n<li><strong>检查应用本身，而不是容器进程</strong>：简单的 <code>exit 0</code> 或者检查容器进程是否运行都没用，你需要检查你的应用是否能正常响应请求或执行关键操作。</li>\n<li><strong>使用轻量级命令</strong>：检查命令应该快速、开销小，不要执行耗时的操作。</li>\n<li><strong>根据服务类型选择命令</strong>：<ul>\n<li><strong>Web&#x2F;API 服务</strong>：使用 <code>curl</code> 或 <code>wget</code> 访问一个专门的健康检查接口 (如 <code>/health</code>, <code>/status</code>)。这个接口应该检查内部依赖 (数据库连接、缓存连接等)。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;curl&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;http://localhost:你的端口/healthz&quot;</span>] <span class=\"comment\"># -f 参数让 curl 在非 2xx/3xx 状态码时失败</span></span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">15s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>数据库服务</strong>：使用数据库客户端自带的工具，如 <code>mysqladmin ping</code>, <code>pg_isready</code>。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;mysqladmin&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>, <span class=\"string\">&quot;-h&quot;</span>, <span class=\"string\">&quot;localhost&quot;</span>, <span class=\"string\">&quot;-P你的端口&quot;</span>] <span class=\"comment\"># 检查 MySQL</span></span><br><span class=\"line\">  <span class=\"comment\"># test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U 你的用户 -d 你的数据库名&quot;] # 检查 PostgreSQL</span></span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">10s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>缓存服务</strong>：使用客户端命令，如 <code>redis-cli ping</code>。<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">healthcheck:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span> [<span class=\"string\">&quot;CMD&quot;</span>, <span class=\"string\">&quot;redis-cli&quot;</span>, <span class=\"string\">&quot;ping&quot;</span>]</span><br><span class=\"line\">  <span class=\"attr\">interval:</span> <span class=\"string\">5s</span></span><br><span class=\"line\">  <span class=\"attr\">timeout:</span> <span class=\"string\">3s</span></span><br><span class=\"line\">  <span class=\"attr\">retries:</span> <span class=\"number\">3</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><strong>考虑 <code>start_period</code></strong>：给应用一个合理的启动时间，避免在应用还没完全启动好时就被健康检查标记为失败。</li>\n</ul>\n<hr>\n<h2 id=\"🚧-潜在问题与注意事项\"><a href=\"#🚧-潜在问题与注意事项\" class=\"headerlink\" title=\"🚧 潜在问题与注意事项\"></a>🚧 潜在问题与注意事项</h2><ul>\n<li><strong>循环依赖</strong>：服务 A 依赖服务 B，同时服务 B 依赖服务 A，这是不允许的，会导致 Docker Compose 无法决定启动顺序。</li>\n<li><strong>健康检查不准确</strong>：一个糟糕的 <code>healthcheck</code> 可能导致服务被错误地标记为健康或不健康，影响依赖服务的启动。确保你的检查命令真正反映了服务的可用性。</li>\n<li><strong>所有依赖都需要配置 <code>healthcheck</code></strong>：如果你使用 <code>condition: service_healthy</code>，那么你所依赖的所有服务都必须配置 <code>healthcheck</code> 字段，否则 Docker Compose 会报错。</li>\n</ul>\n<hr>\n<h2 id=\"总结一下，让服务优雅地按顺序启动的关键：\"><a href=\"#总结一下，让服务优雅地按顺序启动的关键：\" class=\"headerlink\" title=\"总结一下，让服务优雅地按顺序启动的关键：\"></a>总结一下，让服务优雅地按顺序启动的关键：</h2><ol>\n<li>识别服务间的依赖关系。</li>\n<li>对于需要等待依赖服务“准备就绪”的服务，配置 <code>depends_on</code> 为字典格式，使用 <code>condition: service_healthy</code>。</li>\n<li>对于被依赖的服务，必须配置有效的 <code>healthcheck</code>。</li>\n</ol>\n<p>通过这种方式，你可以构建出更健壮、启动更可靠的多服务应用栈！</p>\n<hr>\n<p><strong>本章小结</strong></p>\n<p>我们深入探讨了 <code>depends_on</code> 和 <code>healthcheck</code> 的结合使用，解决了服务启动时的“就绪”问题：</p>\n<ul>\n<li>默认 <code>depends_on</code> 只等待容器启动，不等待应用就绪。</li>\n<li><code>healthcheck</code> 用于判断应用的健康状态。</li>\n<li>通过 <code>depends_on: service_name: &#123; condition: service_healthy &#125;</code> 语法，可以强制 Docker Compose 等待依赖的服务达到 <code>healthy</code> 状态后再启动当前服务。</li>\n<li>学习了如何编写有效的 <code>healthcheck</code> 命令。</li>\n</ul>\n<p>现在，你的 Docker Compose 文件已经能够表达复杂的服务依赖关系了！接下来，我们将转向如何更灵活地管理配置信息，特别是环境变量，以及如何使用 Docker Compose 来轻松切换不同的运行环境（开发、测试、生产）。这将在下一章“环境变量与多环境管理”中讲解！敬请期待！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmbmfzwvz0001pkrc6kkoh208","category_id":"cmbmfzww20004pkrc71c0bvao","_id":"cmbmfzww7000ipkrcckv51ymo"},{"post_id":"cmbmfzww10003pkrcbga7b6pz","category_id":"cmbmfzww5000cpkrc70fx6zao","_id":"cmbmfzww9000qpkrc3argan4j"},{"post_id":"cmbmfzww8000mpkrc6ra5fuu2","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzww9000upkrc3y5c05nu"},{"post_id":"cmbmfzww30007pkrc23y0glsb","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwa000xpkrc0v7whkxy"},{"post_id":"cmbmfzww40009pkrc0kmm4d49","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwa0011pkrcea33fuop"},{"post_id":"cmbmfzww5000bpkrcgh7g1mbp","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwa0014pkrcbatg4nyo"},{"post_id":"cmbmfzww6000fpkrc60aic9wa","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwa0017pkrc46k5ctrj"},{"post_id":"cmbmfzww6000hpkrc9lkpbxj8","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwb001bpkrc6vb4bepm"},{"post_id":"cmbmfzwwc001opkrcdrmz14li","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwd001tpkrcelj04c58"},{"post_id":"cmbmfzwwc001ppkrc0oc3gx2f","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwd001vpkrcaap6dxvu"},{"post_id":"cmbmfzwwd001rpkrc1i6v44dl","category_id":"cmbmfzww7000jpkrc5v4keyk9","_id":"cmbmfzwwd001xpkrc9hokbipx"}],"PostTag":[{"post_id":"cmbmfzwvz0001pkrc6kkoh208","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzww8000npkrcf6h05uq0"},{"post_id":"cmbmfzwvz0001pkrc6kkoh208","tag_id":"cmbmfzww5000dpkrcbob53f8t","_id":"cmbmfzww9000ppkrc9wcsguho"},{"post_id":"cmbmfzww10003pkrcbga7b6pz","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwa000ypkrc2009925u"},{"post_id":"cmbmfzww10003pkrcbga7b6pz","tag_id":"cmbmfzww9000rpkrcatwx7nal","_id":"cmbmfzwwa000zpkrcgjh4924y"},{"post_id":"cmbmfzww30007pkrc23y0glsb","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwa0016pkrc2pli84p7"},{"post_id":"cmbmfzww30007pkrc23y0glsb","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwa0018pkrc2n8ygv1l"},{"post_id":"cmbmfzww40009pkrc0kmm4d49","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwb001apkrc70ox8jbg"},{"post_id":"cmbmfzww40009pkrc0kmm4d49","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwb001cpkrcej7dhofp"},{"post_id":"cmbmfzww5000bpkrcgh7g1mbp","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwb001epkrchr6e022z"},{"post_id":"cmbmfzww5000bpkrcgh7g1mbp","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwb001fpkrccaljg98c"},{"post_id":"cmbmfzww6000fpkrc60aic9wa","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwb001hpkrc56ne5vsr"},{"post_id":"cmbmfzww6000fpkrc60aic9wa","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwb001ipkrcd6xebqms"},{"post_id":"cmbmfzww6000hpkrc9lkpbxj8","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwb001kpkrchunjfun4"},{"post_id":"cmbmfzww6000hpkrc9lkpbxj8","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwb001lpkrc04swe7tf"},{"post_id":"cmbmfzww8000mpkrc6ra5fuu2","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwb001mpkrcb1eecv9i"},{"post_id":"cmbmfzww8000mpkrc6ra5fuu2","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwb001npkrcdcn52i2v"},{"post_id":"cmbmfzwwc001opkrcdrmz14li","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwd001qpkrc65c1bjha"},{"post_id":"cmbmfzwwc001opkrcdrmz14li","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwd001spkrc19ujcwo9"},{"post_id":"cmbmfzwwc001ppkrc0oc3gx2f","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwd001upkrcfggs26ly"},{"post_id":"cmbmfzwwc001ppkrc0oc3gx2f","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwd001wpkrc7kelgfcv"},{"post_id":"cmbmfzwwd001rpkrc1i6v44dl","tag_id":"cmbmfzwwa000wpkrc4e9h2l0h","_id":"cmbmfzwwd001ypkrchoqlh7ya"},{"post_id":"cmbmfzwwd001rpkrc1i6v44dl","tag_id":"cmbmfzww30005pkrchhc486sx","_id":"cmbmfzwwd001zpkrc0n1g2w89"}],"Tag":[{"name":"教程","_id":"cmbmfzww30005pkrchhc486sx"},{"name":"GIT","_id":"cmbmfzww5000dpkrcbob53f8t"},{"name":"Linux","_id":"cmbmfzww9000rpkrcatwx7nal"},{"name":"Docker","_id":"cmbmfzwwa000wpkrc4e9h2l0h"}]}}